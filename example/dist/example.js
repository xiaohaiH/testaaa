import require$$2 from "chalk";
import { defineComponent as defineComponent$3, computed, ref as ref$3, markRaw as markRaw$1, onMounted as onMounted$2, watch, h as h$1 } from "vue-demi";
import * as O from "monaco-editor";
import { editor, Uri, languages } from "monaco-editor";
import editorWorker from "monaco-editor/esm/vs/editor/editor.worker?worker";
import tsWorker from "monaco-editor/esm/vs/language/typescript/ts.worker?worker";
typeof Buffer > "u" && (window.Buffer = {});
typeof Buffer.isBuffer > "u" && (Buffer.isBuffer = (e) => !1);
const { set: set$2 } = window.Vue, { defineCondition: defineCondition$1 } = window.HCondition, conditionFactory = () => ({
  description: "",
  wrapperOption: {
    toast: (e) => alert(e),
    resetToInitialValue: !0,
    resetTriggerSearch: !0,
    size: "small",
    // tag: 'main',
    class: "h-condition",
    key: "",
    rules: {
      ra2: { required: !0, message: "哈哈哈" }
    }
  },
  condition: defineCondition$1({
    ageBegin: {
      t: "input",
      label: "年龄段搜索",
      placeholder: "青少年",
      clearable: !0,
      defaultValue: "10",
      postfix: "-",
      rules: [{ required: !0 }]
    },
    ageMiddle: {
      t: "input",
      placeholder: "中年",
      clearable: !0,
      defaultValue: "40",
      postfix: "-",
      validator: (e) => !isNaN(e.ageBegin) && Number(e.ageBegin) >= Number(e.ageMiddle) && "值不能小于青少年的值"
    },
    ageEnd: {
      t: "input",
      placeholder: "老年",
      defaultValue: "80",
      clearable: !0,
      validator: (e) => !isNaN(e.ageMiddle) && Number(e.ageMiddle) >= Number(e.ageEnd) && "值不能小于中年的值"
    },
    ra1: {
      t: "radio",
      label: "单选(可取消)",
      type: "button",
      valueKey: "dictValue",
      labelKey: "dictLabel",
      cancelable: !0,
      options: [
        { dictValue: "1", dictLabel: "单选1" },
        { dictValue: "2", dictLabel: "单选2" }
      ],
      defaultValue: "1"
    },
    ra2: {
      t: "radio",
      label: "单选",
      type: "button",
      valueKey: "dictValue",
      labelKey: "dictLabel",
      options: [
        { dictValue: "3", dictLabel: "单选1" },
        { dictValue: "4", dictLabel: "单选2" }
      ]
      // defaultValue: '3',
    },
    check: {
      t: "checkbox",
      label: "多选",
      type: "button",
      valueKey: "dictValue",
      labelKey: "dictLabel",
      options: [
        { dictValue: "1", dictLabel: "多选1" },
        { dictValue: "2", dictLabel: "多选2" }
      ]
      // defaultValue: () => ['1'],
    },
    sel1: {
      t: "select",
      label: "依赖单选",
      placeholder: "请先选择单选",
      disabled: ({ query: e }) => !e.ra1,
      valueKey: "dictValue",
      labelKey: "dictLabel",
      options: [],
      defaultValue: "2",
      getOptions(e, t, s) {
        setTimeout(() => {
          e([
            { dictValue: "1", dictLabel: "选项一" },
            { dictValue: "2", dictLabel: "选项二" },
            { dictValue: "example", dictLabel: "选项三" }
          ]), s.trigger === "initial" && s.search("example");
        });
      }
    },
    sel2: {
      t: "select",
      label: "分组下拉框",
      placeholder: "请选择...",
      valueKey: "dictValue",
      labelKey: "dictLabel",
      options: [
        {
          dictValue: "group-1",
          dictLabel: "分组选项A",
          group: !0,
          children: [
            { dictValue: "group-1-1", dictLabel: "v3-分组一" },
            { dictValue: "group-1-2", dictLabel: "v3-分组二" }
          ]
        },
        {
          dictValue: "222",
          dictLabel: "分组选项B",
          group: !0,
          children: [
            { dictValue: "group-2-1", dictLabel: "v3-group-分组一" },
            { dictValue: "group-2-2", dictLabel: "v3-group-分组二" }
          ]
        },
        { dictValue: "2", dictLabel: "选项二" },
        { dictValue: "example", dictLabel: "选项三" }
      ],
      defaultValue: () => "example"
    },
    cas1: {
      t: "cascader",
      label: "级联(可选任意一级)",
      placeholder: "请选择...",
      resetToInitialValue: !0,
      valueKey: "value",
      fields: ["cascader-a", "cascader-b"],
      // emitPath: true,
      props: { checkStrictly: !0 },
      defaultValue: ["2", "2-1"],
      getOptions(e, t, s) {
        setTimeout(() => {
          e([
            { label: "A", value: "1", children: [{ label: "A-11111", value: "1-1" }] },
            {
              label: "B",
              value: "2",
              children: [
                { label: "B-11111", value: "2-1" },
                { label: "B-22222", value: "2-2" }
              ]
            },
            {
              label: "C",
              value: "3",
              children: [
                { label: "C-11111", value: "3-1" },
                { label: "C-22222", value: "3-2" },
                { label: "C-33333", value: "3-3" },
                { label: "C-44444", value: "3-4" }
              ]
            }
          ]);
        }, 2e3);
      }
    },
    cas2: {
      t: "cascader",
      label: "级联(最后一级)",
      placeholder: "级联选择",
      fields: ["level1", "level2", "level3"],
      resetToInitialValue: !0,
      valueKey: "value",
      emitPath: !0,
      // disabled: ({ query }) => !query.ac?.length,
      // hide: ({query}) => !query.ac?.length,
      options: [
        { label: "A", value: "bc_1", children: [{ label: "A-11111", value: "bc_1-1" }] },
        {
          label: "B",
          value: "bc_2",
          children: [
            { label: "B-11111", value: "bc_2-1" },
            { label: "B-22222", value: "bc_2-2" }
          ]
        },
        {
          label: "C",
          value: "bc_3",
          children: [
            { label: "C-11111", value: "bc_3-1" },
            { label: "C-22222", value: "bc_3-2" },
            { label: "C-33333", value: "bc_3-3" },
            { label: "C-44444", value: "bc_3-4" }
          ]
        }
      ]
    },
    date: {
      t: "datepicker",
      placeholder: "没有 label"
      // defaultValue: '2023-10-10',
    },
    date2: {
      t: "datepicker",
      type: "daterange",
      label: "日期区间",
      placeholder: "日期区间选择",
      startPlaceholder: "开始",
      endPlaceholder: "结束",
      beginField: "startTime",
      endField: "endTime",
      defaultValue: ["2023-10-08", "2023-10-11"]
    }
  }),
  query: { e: "1-1", "cascader-a": "3", "cascader-b": "3-3" },
  setQuery(e) {
    set$2(e.query, "a", "手动设置"), set$2(e.query, "b", "1"), set$2(e.query, "dd", (e.query.dd || 0) + 1), set$2(e.query, "ad", (e.query.ad || 0) + 1);
  }
});
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var lib$c = {}, visitors = {}, virtualTypes$1 = {};
Object.defineProperty(virtualTypes$1, "__esModule", {
  value: !0
});
virtualTypes$1.Var = virtualTypes$1.User = virtualTypes$1.Statement = virtualTypes$1.SpreadProperty = virtualTypes$1.Scope = virtualTypes$1.RestProperty = virtualTypes$1.ReferencedMemberExpression = virtualTypes$1.ReferencedIdentifier = virtualTypes$1.Referenced = virtualTypes$1.Pure = virtualTypes$1.NumericLiteralTypeAnnotation = virtualTypes$1.Generated = virtualTypes$1.ForAwaitStatement = virtualTypes$1.Flow = virtualTypes$1.Expression = virtualTypes$1.ExistentialTypeParam = virtualTypes$1.BlockScoped = virtualTypes$1.BindingIdentifier = void 0;
virtualTypes$1.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
virtualTypes$1.ReferencedMemberExpression = ["MemberExpression"];
virtualTypes$1.BindingIdentifier = ["Identifier"];
virtualTypes$1.Statement = ["Statement"];
virtualTypes$1.Expression = ["Expression"];
virtualTypes$1.Scope = ["Scopable", "Pattern"];
virtualTypes$1.Referenced = null;
virtualTypes$1.BlockScoped = null;
virtualTypes$1.Var = ["VariableDeclaration"];
virtualTypes$1.User = null;
virtualTypes$1.Generated = null;
virtualTypes$1.Pure = null;
virtualTypes$1.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
virtualTypes$1.RestProperty = ["RestElement"];
virtualTypes$1.SpreadProperty = ["RestElement"];
virtualTypes$1.ExistentialTypeParam = ["ExistsTypeAnnotation"];
virtualTypes$1.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
virtualTypes$1.ForAwaitStatement = ["ForOfStatement"];
var virtualTypesValidator = {}, lib$b = {}, isReactComponent$1 = {}, buildMatchMemberExpression$1 = {}, matchesPattern$2 = {}, generated$3 = {}, shallowEqual$1 = {};
Object.defineProperty(shallowEqual$1, "__esModule", {
  value: !0
});
shallowEqual$1.default = shallowEqual;
function shallowEqual(e, t) {
  const s = Object.keys(t);
  for (const i of s)
    if (e[i] !== t[i])
      return !1;
  return !0;
}
var deprecationWarning$2 = {};
Object.defineProperty(deprecationWarning$2, "__esModule", {
  value: !0
});
deprecationWarning$2.default = deprecationWarning$1;
const warnings = /* @__PURE__ */ new Set();
function deprecationWarning$1(e, t, s = "") {
  if (warnings.has(e))
    return;
  warnings.add(e);
  const {
    internal: i,
    trace: a
  } = captureShortStackTrace(1, 2);
  i || console.warn(`${s}\`${e}\` has been deprecated, please migrate to \`${t}\`
${a}`);
}
function captureShortStackTrace(e, t) {
  const {
    stackTraceLimit: s,
    prepareStackTrace: i
  } = Error;
  let a;
  if (Error.stackTraceLimit = 1 + e + t, Error.prepareStackTrace = function(l, f) {
    a = f;
  }, new Error().stack, Error.stackTraceLimit = s, Error.prepareStackTrace = i, !a)
    return {
      internal: !1,
      trace: ""
    };
  const o = a.slice(1 + e, 1 + e + t);
  return {
    internal: /[\\/]@babel[\\/]/.test(o[1].getFileName()),
    trace: o.map((l) => `    at ${l}`).join(`
`)
  };
}
Object.defineProperty(generated$3, "__esModule", {
  value: !0
});
generated$3.isAccessor = isAccessor;
generated$3.isAnyTypeAnnotation = isAnyTypeAnnotation$1;
generated$3.isArgumentPlaceholder = isArgumentPlaceholder;
generated$3.isArrayExpression = isArrayExpression$1;
generated$3.isArrayPattern = isArrayPattern;
generated$3.isArrayTypeAnnotation = isArrayTypeAnnotation$2;
generated$3.isArrowFunctionExpression = isArrowFunctionExpression$1;
generated$3.isAssignmentExpression = isAssignmentExpression$2;
generated$3.isAssignmentPattern = isAssignmentPattern$2;
generated$3.isAwaitExpression = isAwaitExpression;
generated$3.isBigIntLiteral = isBigIntLiteral;
generated$3.isBinary = isBinary$1;
generated$3.isBinaryExpression = isBinaryExpression$1;
generated$3.isBindExpression = isBindExpression;
generated$3.isBlock = isBlock;
generated$3.isBlockParent = isBlockParent;
generated$3.isBlockStatement = isBlockStatement$2;
generated$3.isBooleanLiteral = isBooleanLiteral;
generated$3.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
generated$3.isBooleanTypeAnnotation = isBooleanTypeAnnotation$1;
generated$3.isBreakStatement = isBreakStatement;
generated$3.isCallExpression = isCallExpression$5;
generated$3.isCatchClause = isCatchClause;
generated$3.isClass = isClass;
generated$3.isClassAccessorProperty = isClassAccessorProperty;
generated$3.isClassBody = isClassBody$1;
generated$3.isClassDeclaration = isClassDeclaration$1;
generated$3.isClassExpression = isClassExpression;
generated$3.isClassImplements = isClassImplements;
generated$3.isClassMethod = isClassMethod;
generated$3.isClassPrivateMethod = isClassPrivateMethod;
generated$3.isClassPrivateProperty = isClassPrivateProperty;
generated$3.isClassProperty = isClassProperty;
generated$3.isCompletionStatement = isCompletionStatement;
generated$3.isConditional = isConditional;
generated$3.isConditionalExpression = isConditionalExpression;
generated$3.isContinueStatement = isContinueStatement;
generated$3.isDebuggerStatement = isDebuggerStatement;
generated$3.isDecimalLiteral = isDecimalLiteral;
generated$3.isDeclaration = isDeclaration;
generated$3.isDeclareClass = isDeclareClass;
generated$3.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
generated$3.isDeclareExportDeclaration = isDeclareExportDeclaration;
generated$3.isDeclareFunction = isDeclareFunction;
generated$3.isDeclareInterface = isDeclareInterface;
generated$3.isDeclareModule = isDeclareModule;
generated$3.isDeclareModuleExports = isDeclareModuleExports;
generated$3.isDeclareOpaqueType = isDeclareOpaqueType;
generated$3.isDeclareTypeAlias = isDeclareTypeAlias;
generated$3.isDeclareVariable = isDeclareVariable;
generated$3.isDeclaredPredicate = isDeclaredPredicate;
generated$3.isDecorator = isDecorator;
generated$3.isDirective = isDirective;
generated$3.isDirectiveLiteral = isDirectiveLiteral;
generated$3.isDoExpression = isDoExpression;
generated$3.isDoWhileStatement = isDoWhileStatement;
generated$3.isEmptyStatement = isEmptyStatement;
generated$3.isEmptyTypeAnnotation = isEmptyTypeAnnotation$1;
generated$3.isEnumBody = isEnumBody;
generated$3.isEnumBooleanBody = isEnumBooleanBody;
generated$3.isEnumBooleanMember = isEnumBooleanMember;
generated$3.isEnumDeclaration = isEnumDeclaration;
generated$3.isEnumDefaultedMember = isEnumDefaultedMember;
generated$3.isEnumMember = isEnumMember;
generated$3.isEnumNumberBody = isEnumNumberBody;
generated$3.isEnumNumberMember = isEnumNumberMember;
generated$3.isEnumStringBody = isEnumStringBody;
generated$3.isEnumStringMember = isEnumStringMember;
generated$3.isEnumSymbolBody = isEnumSymbolBody;
generated$3.isExistsTypeAnnotation = isExistsTypeAnnotation;
generated$3.isExportAllDeclaration = isExportAllDeclaration;
generated$3.isExportDeclaration = isExportDeclaration$2;
generated$3.isExportDefaultDeclaration = isExportDefaultDeclaration$1;
generated$3.isExportDefaultSpecifier = isExportDefaultSpecifier$1;
generated$3.isExportNamedDeclaration = isExportNamedDeclaration$1;
generated$3.isExportNamespaceSpecifier = isExportNamespaceSpecifier$1;
generated$3.isExportSpecifier = isExportSpecifier;
generated$3.isExpression = isExpression$2;
generated$3.isExpressionStatement = isExpressionStatement$2;
generated$3.isExpressionWrapper = isExpressionWrapper;
generated$3.isFile = isFile;
generated$3.isFlow = isFlow$1;
generated$3.isFlowBaseAnnotation = isFlowBaseAnnotation$1;
generated$3.isFlowDeclaration = isFlowDeclaration;
generated$3.isFlowPredicate = isFlowPredicate;
generated$3.isFlowType = isFlowType$1;
generated$3.isFor = isFor$1;
generated$3.isForInStatement = isForInStatement;
generated$3.isForOfStatement = isForOfStatement$2;
generated$3.isForStatement = isForStatement$2;
generated$3.isForXStatement = isForXStatement$1;
generated$3.isFunction = isFunction$5;
generated$3.isFunctionDeclaration = isFunctionDeclaration;
generated$3.isFunctionExpression = isFunctionExpression;
generated$3.isFunctionParent = isFunctionParent;
generated$3.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
generated$3.isFunctionTypeParam = isFunctionTypeParam;
generated$3.isGenericTypeAnnotation = isGenericTypeAnnotation$1;
generated$3.isIdentifier = isIdentifier$9;
generated$3.isIfStatement = isIfStatement$1;
generated$3.isImmutable = isImmutable$2;
generated$3.isImport = isImport;
generated$3.isImportAttribute = isImportAttribute;
generated$3.isImportDeclaration = isImportDeclaration$1;
generated$3.isImportDefaultSpecifier = isImportDefaultSpecifier$1;
generated$3.isImportExpression = isImportExpression;
generated$3.isImportNamespaceSpecifier = isImportNamespaceSpecifier$1;
generated$3.isImportOrExportDeclaration = isImportOrExportDeclaration;
generated$3.isImportSpecifier = isImportSpecifier$1;
generated$3.isIndexedAccessType = isIndexedAccessType$1;
generated$3.isInferredPredicate = isInferredPredicate;
generated$3.isInterfaceDeclaration = isInterfaceDeclaration;
generated$3.isInterfaceExtends = isInterfaceExtends;
generated$3.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
generated$3.isInterpreterDirective = isInterpreterDirective;
generated$3.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
generated$3.isJSX = isJSX;
generated$3.isJSXAttribute = isJSXAttribute;
generated$3.isJSXClosingElement = isJSXClosingElement;
generated$3.isJSXClosingFragment = isJSXClosingFragment;
generated$3.isJSXElement = isJSXElement;
generated$3.isJSXEmptyExpression = isJSXEmptyExpression;
generated$3.isJSXExpressionContainer = isJSXExpressionContainer;
generated$3.isJSXFragment = isJSXFragment;
generated$3.isJSXIdentifier = isJSXIdentifier$2;
generated$3.isJSXMemberExpression = isJSXMemberExpression$1;
generated$3.isJSXNamespacedName = isJSXNamespacedName;
generated$3.isJSXOpeningElement = isJSXOpeningElement;
generated$3.isJSXOpeningFragment = isJSXOpeningFragment;
generated$3.isJSXSpreadAttribute = isJSXSpreadAttribute;
generated$3.isJSXSpreadChild = isJSXSpreadChild;
generated$3.isJSXText = isJSXText;
generated$3.isLVal = isLVal;
generated$3.isLabeledStatement = isLabeledStatement;
generated$3.isLiteral = isLiteral$4;
generated$3.isLogicalExpression = isLogicalExpression;
generated$3.isLoop = isLoop$1;
generated$3.isMemberExpression = isMemberExpression$5;
generated$3.isMetaProperty = isMetaProperty;
generated$3.isMethod = isMethod;
generated$3.isMiscellaneous = isMiscellaneous;
generated$3.isMixedTypeAnnotation = isMixedTypeAnnotation$1;
generated$3.isModuleDeclaration = isModuleDeclaration;
generated$3.isModuleExpression = isModuleExpression;
generated$3.isModuleSpecifier = isModuleSpecifier;
generated$3.isNewExpression = isNewExpression$3;
generated$3.isNoop = isNoop;
generated$3.isNullLiteral = isNullLiteral$1;
generated$3.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
generated$3.isNullableTypeAnnotation = isNullableTypeAnnotation;
generated$3.isNumberLiteral = isNumberLiteral;
generated$3.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
generated$3.isNumberTypeAnnotation = isNumberTypeAnnotation$1;
generated$3.isNumericLiteral = isNumericLiteral;
generated$3.isObjectExpression = isObjectExpression$1;
generated$3.isObjectMember = isObjectMember;
generated$3.isObjectMethod = isObjectMethod$1;
generated$3.isObjectPattern = isObjectPattern$1;
generated$3.isObjectProperty = isObjectProperty$1;
generated$3.isObjectTypeAnnotation = isObjectTypeAnnotation;
generated$3.isObjectTypeCallProperty = isObjectTypeCallProperty;
generated$3.isObjectTypeIndexer = isObjectTypeIndexer;
generated$3.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
generated$3.isObjectTypeProperty = isObjectTypeProperty;
generated$3.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
generated$3.isOpaqueType = isOpaqueType;
generated$3.isOptionalCallExpression = isOptionalCallExpression$1;
generated$3.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
generated$3.isOptionalMemberExpression = isOptionalMemberExpression$2;
generated$3.isParenthesizedExpression = isParenthesizedExpression;
generated$3.isPattern = isPattern;
generated$3.isPatternLike = isPatternLike;
generated$3.isPipelineBareFunction = isPipelineBareFunction;
generated$3.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
generated$3.isPipelineTopicExpression = isPipelineTopicExpression;
generated$3.isPlaceholder = isPlaceholder$1;
generated$3.isPrivate = isPrivate;
generated$3.isPrivateName = isPrivateName;
generated$3.isProgram = isProgram;
generated$3.isProperty = isProperty;
generated$3.isPureish = isPureish;
generated$3.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
generated$3.isRecordExpression = isRecordExpression;
generated$3.isRegExpLiteral = isRegExpLiteral$1;
generated$3.isRegexLiteral = isRegexLiteral;
generated$3.isRestElement = isRestElement$1;
generated$3.isRestProperty = isRestProperty$1;
generated$3.isReturnStatement = isReturnStatement;
generated$3.isScopable = isScopable;
generated$3.isSequenceExpression = isSequenceExpression;
generated$3.isSpreadElement = isSpreadElement;
generated$3.isSpreadProperty = isSpreadProperty$1;
generated$3.isStandardized = isStandardized;
generated$3.isStatement = isStatement$6;
generated$3.isStaticBlock = isStaticBlock;
generated$3.isStringLiteral = isStringLiteral$4;
generated$3.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
generated$3.isStringTypeAnnotation = isStringTypeAnnotation$1;
generated$3.isSuper = isSuper;
generated$3.isSwitchCase = isSwitchCase;
generated$3.isSwitchStatement = isSwitchStatement;
generated$3.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
generated$3.isTSAnyKeyword = isTSAnyKeyword;
generated$3.isTSArrayType = isTSArrayType$1;
generated$3.isTSAsExpression = isTSAsExpression;
generated$3.isTSBaseType = isTSBaseType;
generated$3.isTSBigIntKeyword = isTSBigIntKeyword;
generated$3.isTSBooleanKeyword = isTSBooleanKeyword;
generated$3.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
generated$3.isTSConditionalType = isTSConditionalType;
generated$3.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
generated$3.isTSConstructorType = isTSConstructorType;
generated$3.isTSDeclareFunction = isTSDeclareFunction;
generated$3.isTSDeclareMethod = isTSDeclareMethod;
generated$3.isTSEntityName = isTSEntityName;
generated$3.isTSEnumDeclaration = isTSEnumDeclaration$1;
generated$3.isTSEnumMember = isTSEnumMember;
generated$3.isTSExportAssignment = isTSExportAssignment;
generated$3.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
generated$3.isTSExternalModuleReference = isTSExternalModuleReference;
generated$3.isTSFunctionType = isTSFunctionType;
generated$3.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
generated$3.isTSImportType = isTSImportType;
generated$3.isTSIndexSignature = isTSIndexSignature;
generated$3.isTSIndexedAccessType = isTSIndexedAccessType;
generated$3.isTSInferType = isTSInferType;
generated$3.isTSInstantiationExpression = isTSInstantiationExpression;
generated$3.isTSInterfaceBody = isTSInterfaceBody$1;
generated$3.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
generated$3.isTSIntersectionType = isTSIntersectionType;
generated$3.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
generated$3.isTSLiteralType = isTSLiteralType;
generated$3.isTSMappedType = isTSMappedType;
generated$3.isTSMethodSignature = isTSMethodSignature;
generated$3.isTSModuleBlock = isTSModuleBlock;
generated$3.isTSModuleDeclaration = isTSModuleDeclaration;
generated$3.isTSNamedTupleMember = isTSNamedTupleMember;
generated$3.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
generated$3.isTSNeverKeyword = isTSNeverKeyword;
generated$3.isTSNonNullExpression = isTSNonNullExpression;
generated$3.isTSNullKeyword = isTSNullKeyword;
generated$3.isTSNumberKeyword = isTSNumberKeyword;
generated$3.isTSObjectKeyword = isTSObjectKeyword;
generated$3.isTSOptionalType = isTSOptionalType;
generated$3.isTSParameterProperty = isTSParameterProperty;
generated$3.isTSParenthesizedType = isTSParenthesizedType;
generated$3.isTSPropertySignature = isTSPropertySignature;
generated$3.isTSQualifiedName = isTSQualifiedName;
generated$3.isTSRestType = isTSRestType;
generated$3.isTSSatisfiesExpression = isTSSatisfiesExpression;
generated$3.isTSStringKeyword = isTSStringKeyword;
generated$3.isTSSymbolKeyword = isTSSymbolKeyword;
generated$3.isTSThisType = isTSThisType;
generated$3.isTSTupleType = isTSTupleType;
generated$3.isTSType = isTSType$1;
generated$3.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
generated$3.isTSTypeAnnotation = isTSTypeAnnotation$1;
generated$3.isTSTypeAssertion = isTSTypeAssertion;
generated$3.isTSTypeElement = isTSTypeElement;
generated$3.isTSTypeLiteral = isTSTypeLiteral;
generated$3.isTSTypeOperator = isTSTypeOperator;
generated$3.isTSTypeParameter = isTSTypeParameter;
generated$3.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
generated$3.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
generated$3.isTSTypePredicate = isTSTypePredicate;
generated$3.isTSTypeQuery = isTSTypeQuery;
generated$3.isTSTypeReference = isTSTypeReference$1;
generated$3.isTSUndefinedKeyword = isTSUndefinedKeyword;
generated$3.isTSUnionType = isTSUnionType;
generated$3.isTSUnknownKeyword = isTSUnknownKeyword;
generated$3.isTSVoidKeyword = isTSVoidKeyword;
generated$3.isTaggedTemplateExpression = isTaggedTemplateExpression;
generated$3.isTemplateElement = isTemplateElement;
generated$3.isTemplateLiteral = isTemplateLiteral$1;
generated$3.isTerminatorless = isTerminatorless;
generated$3.isThisExpression = isThisExpression;
generated$3.isThisTypeAnnotation = isThisTypeAnnotation;
generated$3.isThrowStatement = isThrowStatement;
generated$3.isTopicReference = isTopicReference;
generated$3.isTryStatement = isTryStatement;
generated$3.isTupleExpression = isTupleExpression;
generated$3.isTupleTypeAnnotation = isTupleTypeAnnotation$1;
generated$3.isTypeAlias = isTypeAlias;
generated$3.isTypeAnnotation = isTypeAnnotation$1;
generated$3.isTypeCastExpression = isTypeCastExpression;
generated$3.isTypeParameter = isTypeParameter;
generated$3.isTypeParameterDeclaration = isTypeParameterDeclaration;
generated$3.isTypeParameterInstantiation = isTypeParameterInstantiation;
generated$3.isTypeScript = isTypeScript;
generated$3.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
generated$3.isUnaryExpression = isUnaryExpression;
generated$3.isUnaryLike = isUnaryLike;
generated$3.isUnionTypeAnnotation = isUnionTypeAnnotation$1;
generated$3.isUpdateExpression = isUpdateExpression;
generated$3.isUserWhitespacable = isUserWhitespacable;
generated$3.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
generated$3.isVariableDeclaration = isVariableDeclaration$1;
generated$3.isVariableDeclarator = isVariableDeclarator$1;
generated$3.isVariance = isVariance;
generated$3.isVoidTypeAnnotation = isVoidTypeAnnotation$1;
generated$3.isWhile = isWhile;
generated$3.isWhileStatement = isWhileStatement;
generated$3.isWithStatement = isWithStatement;
generated$3.isYieldExpression = isYieldExpression$1;
var _shallowEqual = shallowEqual$1, _deprecationWarning$1 = deprecationWarning$2;
function isArrayExpression$1(e, t) {
  return !e || e.type !== "ArrayExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isAssignmentExpression$2(e, t) {
  return !e || e.type !== "AssignmentExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isBinaryExpression$1(e, t) {
  return !e || e.type !== "BinaryExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isInterpreterDirective(e, t) {
  return !e || e.type !== "InterpreterDirective" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDirective(e, t) {
  return !e || e.type !== "Directive" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDirectiveLiteral(e, t) {
  return !e || e.type !== "DirectiveLiteral" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isBlockStatement$2(e, t) {
  return !e || e.type !== "BlockStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isBreakStatement(e, t) {
  return !e || e.type !== "BreakStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isCallExpression$5(e, t) {
  return !e || e.type !== "CallExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isCatchClause(e, t) {
  return !e || e.type !== "CatchClause" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isConditionalExpression(e, t) {
  return !e || e.type !== "ConditionalExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isContinueStatement(e, t) {
  return !e || e.type !== "ContinueStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDebuggerStatement(e, t) {
  return !e || e.type !== "DebuggerStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDoWhileStatement(e, t) {
  return !e || e.type !== "DoWhileStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isEmptyStatement(e, t) {
  return !e || e.type !== "EmptyStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isExpressionStatement$2(e, t) {
  return !e || e.type !== "ExpressionStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isFile(e, t) {
  return !e || e.type !== "File" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isForInStatement(e, t) {
  return !e || e.type !== "ForInStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isForStatement$2(e, t) {
  return !e || e.type !== "ForStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isFunctionDeclaration(e, t) {
  return !e || e.type !== "FunctionDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isFunctionExpression(e, t) {
  return !e || e.type !== "FunctionExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isIdentifier$9(e, t) {
  return !e || e.type !== "Identifier" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isIfStatement$1(e, t) {
  return !e || e.type !== "IfStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isLabeledStatement(e, t) {
  return !e || e.type !== "LabeledStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isStringLiteral$4(e, t) {
  return !e || e.type !== "StringLiteral" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isNumericLiteral(e, t) {
  return !e || e.type !== "NumericLiteral" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isNullLiteral$1(e, t) {
  return !e || e.type !== "NullLiteral" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isBooleanLiteral(e, t) {
  return !e || e.type !== "BooleanLiteral" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isRegExpLiteral$1(e, t) {
  return !e || e.type !== "RegExpLiteral" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isLogicalExpression(e, t) {
  return !e || e.type !== "LogicalExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isMemberExpression$5(e, t) {
  return !e || e.type !== "MemberExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isNewExpression$3(e, t) {
  return !e || e.type !== "NewExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isProgram(e, t) {
  return !e || e.type !== "Program" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isObjectExpression$1(e, t) {
  return !e || e.type !== "ObjectExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isObjectMethod$1(e, t) {
  return !e || e.type !== "ObjectMethod" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isObjectProperty$1(e, t) {
  return !e || e.type !== "ObjectProperty" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isRestElement$1(e, t) {
  return !e || e.type !== "RestElement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isReturnStatement(e, t) {
  return !e || e.type !== "ReturnStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isSequenceExpression(e, t) {
  return !e || e.type !== "SequenceExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isParenthesizedExpression(e, t) {
  return !e || e.type !== "ParenthesizedExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isSwitchCase(e, t) {
  return !e || e.type !== "SwitchCase" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isSwitchStatement(e, t) {
  return !e || e.type !== "SwitchStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isThisExpression(e, t) {
  return !e || e.type !== "ThisExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isThrowStatement(e, t) {
  return !e || e.type !== "ThrowStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTryStatement(e, t) {
  return !e || e.type !== "TryStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isUnaryExpression(e, t) {
  return !e || e.type !== "UnaryExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isUpdateExpression(e, t) {
  return !e || e.type !== "UpdateExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isVariableDeclaration$1(e, t) {
  return !e || e.type !== "VariableDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isVariableDeclarator$1(e, t) {
  return !e || e.type !== "VariableDeclarator" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isWhileStatement(e, t) {
  return !e || e.type !== "WhileStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isWithStatement(e, t) {
  return !e || e.type !== "WithStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isAssignmentPattern$2(e, t) {
  return !e || e.type !== "AssignmentPattern" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isArrayPattern(e, t) {
  return !e || e.type !== "ArrayPattern" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isArrowFunctionExpression$1(e, t) {
  return !e || e.type !== "ArrowFunctionExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isClassBody$1(e, t) {
  return !e || e.type !== "ClassBody" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isClassExpression(e, t) {
  return !e || e.type !== "ClassExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isClassDeclaration$1(e, t) {
  return !e || e.type !== "ClassDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isExportAllDeclaration(e, t) {
  return !e || e.type !== "ExportAllDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isExportDefaultDeclaration$1(e, t) {
  return !e || e.type !== "ExportDefaultDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isExportNamedDeclaration$1(e, t) {
  return !e || e.type !== "ExportNamedDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isExportSpecifier(e, t) {
  return !e || e.type !== "ExportSpecifier" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isForOfStatement$2(e, t) {
  return !e || e.type !== "ForOfStatement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isImportDeclaration$1(e, t) {
  return !e || e.type !== "ImportDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isImportDefaultSpecifier$1(e, t) {
  return !e || e.type !== "ImportDefaultSpecifier" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isImportNamespaceSpecifier$1(e, t) {
  return !e || e.type !== "ImportNamespaceSpecifier" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isImportSpecifier$1(e, t) {
  return !e || e.type !== "ImportSpecifier" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isImportExpression(e, t) {
  return !e || e.type !== "ImportExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isMetaProperty(e, t) {
  return !e || e.type !== "MetaProperty" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isClassMethod(e, t) {
  return !e || e.type !== "ClassMethod" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isObjectPattern$1(e, t) {
  return !e || e.type !== "ObjectPattern" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isSpreadElement(e, t) {
  return !e || e.type !== "SpreadElement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isSuper(e, t) {
  return !e || e.type !== "Super" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTaggedTemplateExpression(e, t) {
  return !e || e.type !== "TaggedTemplateExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTemplateElement(e, t) {
  return !e || e.type !== "TemplateElement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTemplateLiteral$1(e, t) {
  return !e || e.type !== "TemplateLiteral" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isYieldExpression$1(e, t) {
  return !e || e.type !== "YieldExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isAwaitExpression(e, t) {
  return !e || e.type !== "AwaitExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isImport(e, t) {
  return !e || e.type !== "Import" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isBigIntLiteral(e, t) {
  return !e || e.type !== "BigIntLiteral" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isExportNamespaceSpecifier$1(e, t) {
  return !e || e.type !== "ExportNamespaceSpecifier" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isOptionalMemberExpression$2(e, t) {
  return !e || e.type !== "OptionalMemberExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isOptionalCallExpression$1(e, t) {
  return !e || e.type !== "OptionalCallExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isClassProperty(e, t) {
  return !e || e.type !== "ClassProperty" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isClassAccessorProperty(e, t) {
  return !e || e.type !== "ClassAccessorProperty" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isClassPrivateProperty(e, t) {
  return !e || e.type !== "ClassPrivateProperty" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isClassPrivateMethod(e, t) {
  return !e || e.type !== "ClassPrivateMethod" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isPrivateName(e, t) {
  return !e || e.type !== "PrivateName" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isStaticBlock(e, t) {
  return !e || e.type !== "StaticBlock" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isAnyTypeAnnotation$1(e, t) {
  return !e || e.type !== "AnyTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isArrayTypeAnnotation$2(e, t) {
  return !e || e.type !== "ArrayTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isBooleanTypeAnnotation$1(e, t) {
  return !e || e.type !== "BooleanTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isBooleanLiteralTypeAnnotation(e, t) {
  return !e || e.type !== "BooleanLiteralTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isNullLiteralTypeAnnotation(e, t) {
  return !e || e.type !== "NullLiteralTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isClassImplements(e, t) {
  return !e || e.type !== "ClassImplements" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDeclareClass(e, t) {
  return !e || e.type !== "DeclareClass" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDeclareFunction(e, t) {
  return !e || e.type !== "DeclareFunction" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDeclareInterface(e, t) {
  return !e || e.type !== "DeclareInterface" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDeclareModule(e, t) {
  return !e || e.type !== "DeclareModule" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDeclareModuleExports(e, t) {
  return !e || e.type !== "DeclareModuleExports" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDeclareTypeAlias(e, t) {
  return !e || e.type !== "DeclareTypeAlias" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDeclareOpaqueType(e, t) {
  return !e || e.type !== "DeclareOpaqueType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDeclareVariable(e, t) {
  return !e || e.type !== "DeclareVariable" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDeclareExportDeclaration(e, t) {
  return !e || e.type !== "DeclareExportDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDeclareExportAllDeclaration(e, t) {
  return !e || e.type !== "DeclareExportAllDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDeclaredPredicate(e, t) {
  return !e || e.type !== "DeclaredPredicate" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isExistsTypeAnnotation(e, t) {
  return !e || e.type !== "ExistsTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isFunctionTypeAnnotation(e, t) {
  return !e || e.type !== "FunctionTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isFunctionTypeParam(e, t) {
  return !e || e.type !== "FunctionTypeParam" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isGenericTypeAnnotation$1(e, t) {
  return !e || e.type !== "GenericTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isInferredPredicate(e, t) {
  return !e || e.type !== "InferredPredicate" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isInterfaceExtends(e, t) {
  return !e || e.type !== "InterfaceExtends" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isInterfaceDeclaration(e, t) {
  return !e || e.type !== "InterfaceDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isInterfaceTypeAnnotation(e, t) {
  return !e || e.type !== "InterfaceTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isIntersectionTypeAnnotation(e, t) {
  return !e || e.type !== "IntersectionTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isMixedTypeAnnotation$1(e, t) {
  return !e || e.type !== "MixedTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isEmptyTypeAnnotation$1(e, t) {
  return !e || e.type !== "EmptyTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isNullableTypeAnnotation(e, t) {
  return !e || e.type !== "NullableTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isNumberLiteralTypeAnnotation(e, t) {
  return !e || e.type !== "NumberLiteralTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isNumberTypeAnnotation$1(e, t) {
  return !e || e.type !== "NumberTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isObjectTypeAnnotation(e, t) {
  return !e || e.type !== "ObjectTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isObjectTypeInternalSlot(e, t) {
  return !e || e.type !== "ObjectTypeInternalSlot" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isObjectTypeCallProperty(e, t) {
  return !e || e.type !== "ObjectTypeCallProperty" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isObjectTypeIndexer(e, t) {
  return !e || e.type !== "ObjectTypeIndexer" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isObjectTypeProperty(e, t) {
  return !e || e.type !== "ObjectTypeProperty" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isObjectTypeSpreadProperty(e, t) {
  return !e || e.type !== "ObjectTypeSpreadProperty" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isOpaqueType(e, t) {
  return !e || e.type !== "OpaqueType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isQualifiedTypeIdentifier(e, t) {
  return !e || e.type !== "QualifiedTypeIdentifier" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isStringLiteralTypeAnnotation(e, t) {
  return !e || e.type !== "StringLiteralTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isStringTypeAnnotation$1(e, t) {
  return !e || e.type !== "StringTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isSymbolTypeAnnotation(e, t) {
  return !e || e.type !== "SymbolTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isThisTypeAnnotation(e, t) {
  return !e || e.type !== "ThisTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTupleTypeAnnotation$1(e, t) {
  return !e || e.type !== "TupleTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTypeofTypeAnnotation(e, t) {
  return !e || e.type !== "TypeofTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTypeAlias(e, t) {
  return !e || e.type !== "TypeAlias" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTypeAnnotation$1(e, t) {
  return !e || e.type !== "TypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTypeCastExpression(e, t) {
  return !e || e.type !== "TypeCastExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTypeParameter(e, t) {
  return !e || e.type !== "TypeParameter" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTypeParameterDeclaration(e, t) {
  return !e || e.type !== "TypeParameterDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTypeParameterInstantiation(e, t) {
  return !e || e.type !== "TypeParameterInstantiation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isUnionTypeAnnotation$1(e, t) {
  return !e || e.type !== "UnionTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isVariance(e, t) {
  return !e || e.type !== "Variance" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isVoidTypeAnnotation$1(e, t) {
  return !e || e.type !== "VoidTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isEnumDeclaration(e, t) {
  return !e || e.type !== "EnumDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isEnumBooleanBody(e, t) {
  return !e || e.type !== "EnumBooleanBody" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isEnumNumberBody(e, t) {
  return !e || e.type !== "EnumNumberBody" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isEnumStringBody(e, t) {
  return !e || e.type !== "EnumStringBody" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isEnumSymbolBody(e, t) {
  return !e || e.type !== "EnumSymbolBody" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isEnumBooleanMember(e, t) {
  return !e || e.type !== "EnumBooleanMember" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isEnumNumberMember(e, t) {
  return !e || e.type !== "EnumNumberMember" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isEnumStringMember(e, t) {
  return !e || e.type !== "EnumStringMember" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isEnumDefaultedMember(e, t) {
  return !e || e.type !== "EnumDefaultedMember" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isIndexedAccessType$1(e, t) {
  return !e || e.type !== "IndexedAccessType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isOptionalIndexedAccessType(e, t) {
  return !e || e.type !== "OptionalIndexedAccessType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isJSXAttribute(e, t) {
  return !e || e.type !== "JSXAttribute" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isJSXClosingElement(e, t) {
  return !e || e.type !== "JSXClosingElement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isJSXElement(e, t) {
  return !e || e.type !== "JSXElement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isJSXEmptyExpression(e, t) {
  return !e || e.type !== "JSXEmptyExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isJSXExpressionContainer(e, t) {
  return !e || e.type !== "JSXExpressionContainer" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isJSXSpreadChild(e, t) {
  return !e || e.type !== "JSXSpreadChild" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isJSXIdentifier$2(e, t) {
  return !e || e.type !== "JSXIdentifier" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isJSXMemberExpression$1(e, t) {
  return !e || e.type !== "JSXMemberExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isJSXNamespacedName(e, t) {
  return !e || e.type !== "JSXNamespacedName" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isJSXOpeningElement(e, t) {
  return !e || e.type !== "JSXOpeningElement" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isJSXSpreadAttribute(e, t) {
  return !e || e.type !== "JSXSpreadAttribute" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isJSXText(e, t) {
  return !e || e.type !== "JSXText" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isJSXFragment(e, t) {
  return !e || e.type !== "JSXFragment" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isJSXOpeningFragment(e, t) {
  return !e || e.type !== "JSXOpeningFragment" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isJSXClosingFragment(e, t) {
  return !e || e.type !== "JSXClosingFragment" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isNoop(e, t) {
  return !e || e.type !== "Noop" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isPlaceholder$1(e, t) {
  return !e || e.type !== "Placeholder" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isV8IntrinsicIdentifier(e, t) {
  return !e || e.type !== "V8IntrinsicIdentifier" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isArgumentPlaceholder(e, t) {
  return !e || e.type !== "ArgumentPlaceholder" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isBindExpression(e, t) {
  return !e || e.type !== "BindExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isImportAttribute(e, t) {
  return !e || e.type !== "ImportAttribute" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDecorator(e, t) {
  return !e || e.type !== "Decorator" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDoExpression(e, t) {
  return !e || e.type !== "DoExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isExportDefaultSpecifier$1(e, t) {
  return !e || e.type !== "ExportDefaultSpecifier" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isRecordExpression(e, t) {
  return !e || e.type !== "RecordExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTupleExpression(e, t) {
  return !e || e.type !== "TupleExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isDecimalLiteral(e, t) {
  return !e || e.type !== "DecimalLiteral" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isModuleExpression(e, t) {
  return !e || e.type !== "ModuleExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTopicReference(e, t) {
  return !e || e.type !== "TopicReference" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isPipelineTopicExpression(e, t) {
  return !e || e.type !== "PipelineTopicExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isPipelineBareFunction(e, t) {
  return !e || e.type !== "PipelineBareFunction" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isPipelinePrimaryTopicReference(e, t) {
  return !e || e.type !== "PipelinePrimaryTopicReference" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSParameterProperty(e, t) {
  return !e || e.type !== "TSParameterProperty" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSDeclareFunction(e, t) {
  return !e || e.type !== "TSDeclareFunction" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSDeclareMethod(e, t) {
  return !e || e.type !== "TSDeclareMethod" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSQualifiedName(e, t) {
  return !e || e.type !== "TSQualifiedName" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSCallSignatureDeclaration(e, t) {
  return !e || e.type !== "TSCallSignatureDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSConstructSignatureDeclaration(e, t) {
  return !e || e.type !== "TSConstructSignatureDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSPropertySignature(e, t) {
  return !e || e.type !== "TSPropertySignature" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSMethodSignature(e, t) {
  return !e || e.type !== "TSMethodSignature" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSIndexSignature(e, t) {
  return !e || e.type !== "TSIndexSignature" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSAnyKeyword(e, t) {
  return !e || e.type !== "TSAnyKeyword" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSBooleanKeyword(e, t) {
  return !e || e.type !== "TSBooleanKeyword" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSBigIntKeyword(e, t) {
  return !e || e.type !== "TSBigIntKeyword" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSIntrinsicKeyword(e, t) {
  return !e || e.type !== "TSIntrinsicKeyword" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSNeverKeyword(e, t) {
  return !e || e.type !== "TSNeverKeyword" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSNullKeyword(e, t) {
  return !e || e.type !== "TSNullKeyword" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSNumberKeyword(e, t) {
  return !e || e.type !== "TSNumberKeyword" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSObjectKeyword(e, t) {
  return !e || e.type !== "TSObjectKeyword" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSStringKeyword(e, t) {
  return !e || e.type !== "TSStringKeyword" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSSymbolKeyword(e, t) {
  return !e || e.type !== "TSSymbolKeyword" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSUndefinedKeyword(e, t) {
  return !e || e.type !== "TSUndefinedKeyword" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSUnknownKeyword(e, t) {
  return !e || e.type !== "TSUnknownKeyword" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSVoidKeyword(e, t) {
  return !e || e.type !== "TSVoidKeyword" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSThisType(e, t) {
  return !e || e.type !== "TSThisType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSFunctionType(e, t) {
  return !e || e.type !== "TSFunctionType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSConstructorType(e, t) {
  return !e || e.type !== "TSConstructorType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSTypeReference$1(e, t) {
  return !e || e.type !== "TSTypeReference" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSTypePredicate(e, t) {
  return !e || e.type !== "TSTypePredicate" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSTypeQuery(e, t) {
  return !e || e.type !== "TSTypeQuery" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSTypeLiteral(e, t) {
  return !e || e.type !== "TSTypeLiteral" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSArrayType$1(e, t) {
  return !e || e.type !== "TSArrayType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSTupleType(e, t) {
  return !e || e.type !== "TSTupleType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSOptionalType(e, t) {
  return !e || e.type !== "TSOptionalType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSRestType(e, t) {
  return !e || e.type !== "TSRestType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSNamedTupleMember(e, t) {
  return !e || e.type !== "TSNamedTupleMember" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSUnionType(e, t) {
  return !e || e.type !== "TSUnionType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSIntersectionType(e, t) {
  return !e || e.type !== "TSIntersectionType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSConditionalType(e, t) {
  return !e || e.type !== "TSConditionalType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSInferType(e, t) {
  return !e || e.type !== "TSInferType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSParenthesizedType(e, t) {
  return !e || e.type !== "TSParenthesizedType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSTypeOperator(e, t) {
  return !e || e.type !== "TSTypeOperator" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSIndexedAccessType(e, t) {
  return !e || e.type !== "TSIndexedAccessType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSMappedType(e, t) {
  return !e || e.type !== "TSMappedType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSLiteralType(e, t) {
  return !e || e.type !== "TSLiteralType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSExpressionWithTypeArguments(e, t) {
  return !e || e.type !== "TSExpressionWithTypeArguments" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSInterfaceDeclaration(e, t) {
  return !e || e.type !== "TSInterfaceDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSInterfaceBody$1(e, t) {
  return !e || e.type !== "TSInterfaceBody" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSTypeAliasDeclaration(e, t) {
  return !e || e.type !== "TSTypeAliasDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSInstantiationExpression(e, t) {
  return !e || e.type !== "TSInstantiationExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSAsExpression(e, t) {
  return !e || e.type !== "TSAsExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSSatisfiesExpression(e, t) {
  return !e || e.type !== "TSSatisfiesExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSTypeAssertion(e, t) {
  return !e || e.type !== "TSTypeAssertion" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSEnumDeclaration$1(e, t) {
  return !e || e.type !== "TSEnumDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSEnumMember(e, t) {
  return !e || e.type !== "TSEnumMember" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSModuleDeclaration(e, t) {
  return !e || e.type !== "TSModuleDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSModuleBlock(e, t) {
  return !e || e.type !== "TSModuleBlock" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSImportType(e, t) {
  return !e || e.type !== "TSImportType" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSImportEqualsDeclaration(e, t) {
  return !e || e.type !== "TSImportEqualsDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSExternalModuleReference(e, t) {
  return !e || e.type !== "TSExternalModuleReference" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSNonNullExpression(e, t) {
  return !e || e.type !== "TSNonNullExpression" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSExportAssignment(e, t) {
  return !e || e.type !== "TSExportAssignment" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSNamespaceExportDeclaration(e, t) {
  return !e || e.type !== "TSNamespaceExportDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSTypeAnnotation$1(e, t) {
  return !e || e.type !== "TSTypeAnnotation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSTypeParameterInstantiation(e, t) {
  return !e || e.type !== "TSTypeParameterInstantiation" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSTypeParameterDeclaration(e, t) {
  return !e || e.type !== "TSTypeParameterDeclaration" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isTSTypeParameter(e, t) {
  return !e || e.type !== "TSTypeParameter" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isStandardized(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ArrayExpression":
    case "AssignmentExpression":
    case "BinaryExpression":
    case "InterpreterDirective":
    case "Directive":
    case "DirectiveLiteral":
    case "BlockStatement":
    case "BreakStatement":
    case "CallExpression":
    case "CatchClause":
    case "ConditionalExpression":
    case "ContinueStatement":
    case "DebuggerStatement":
    case "DoWhileStatement":
    case "EmptyStatement":
    case "ExpressionStatement":
    case "File":
    case "ForInStatement":
    case "ForStatement":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "Identifier":
    case "IfStatement":
    case "LabeledStatement":
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "RegExpLiteral":
    case "LogicalExpression":
    case "MemberExpression":
    case "NewExpression":
    case "Program":
    case "ObjectExpression":
    case "ObjectMethod":
    case "ObjectProperty":
    case "RestElement":
    case "ReturnStatement":
    case "SequenceExpression":
    case "ParenthesizedExpression":
    case "SwitchCase":
    case "SwitchStatement":
    case "ThisExpression":
    case "ThrowStatement":
    case "TryStatement":
    case "UnaryExpression":
    case "UpdateExpression":
    case "VariableDeclaration":
    case "VariableDeclarator":
    case "WhileStatement":
    case "WithStatement":
    case "AssignmentPattern":
    case "ArrayPattern":
    case "ArrowFunctionExpression":
    case "ClassBody":
    case "ClassExpression":
    case "ClassDeclaration":
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ExportSpecifier":
    case "ForOfStatement":
    case "ImportDeclaration":
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
    case "ImportExpression":
    case "MetaProperty":
    case "ClassMethod":
    case "ObjectPattern":
    case "SpreadElement":
    case "Super":
    case "TaggedTemplateExpression":
    case "TemplateElement":
    case "TemplateLiteral":
    case "YieldExpression":
    case "AwaitExpression":
    case "Import":
    case "BigIntLiteral":
    case "ExportNamespaceSpecifier":
    case "OptionalMemberExpression":
    case "OptionalCallExpression":
    case "ClassProperty":
    case "ClassAccessorProperty":
    case "ClassPrivateProperty":
    case "ClassPrivateMethod":
    case "PrivateName":
    case "StaticBlock":
      break;
    case "Placeholder":
      switch (e.expectedNode) {
        case "Identifier":
        case "StringLiteral":
        case "BlockStatement":
        case "ClassBody":
          break;
        default:
          return !1;
      }
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isExpression$2(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ArrayExpression":
    case "AssignmentExpression":
    case "BinaryExpression":
    case "CallExpression":
    case "ConditionalExpression":
    case "FunctionExpression":
    case "Identifier":
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "RegExpLiteral":
    case "LogicalExpression":
    case "MemberExpression":
    case "NewExpression":
    case "ObjectExpression":
    case "SequenceExpression":
    case "ParenthesizedExpression":
    case "ThisExpression":
    case "UnaryExpression":
    case "UpdateExpression":
    case "ArrowFunctionExpression":
    case "ClassExpression":
    case "ImportExpression":
    case "MetaProperty":
    case "Super":
    case "TaggedTemplateExpression":
    case "TemplateLiteral":
    case "YieldExpression":
    case "AwaitExpression":
    case "Import":
    case "BigIntLiteral":
    case "OptionalMemberExpression":
    case "OptionalCallExpression":
    case "TypeCastExpression":
    case "JSXElement":
    case "JSXFragment":
    case "BindExpression":
    case "DoExpression":
    case "RecordExpression":
    case "TupleExpression":
    case "DecimalLiteral":
    case "ModuleExpression":
    case "TopicReference":
    case "PipelineTopicExpression":
    case "PipelineBareFunction":
    case "PipelinePrimaryTopicReference":
    case "TSInstantiationExpression":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "TSTypeAssertion":
    case "TSNonNullExpression":
      break;
    case "Placeholder":
      switch (e.expectedNode) {
        case "Expression":
        case "Identifier":
        case "StringLiteral":
          break;
        default:
          return !1;
      }
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isBinary$1(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "BinaryExpression":
    case "LogicalExpression":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isScopable(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "BlockStatement":
    case "CatchClause":
    case "DoWhileStatement":
    case "ForInStatement":
    case "ForStatement":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "Program":
    case "ObjectMethod":
    case "SwitchStatement":
    case "WhileStatement":
    case "ArrowFunctionExpression":
    case "ClassExpression":
    case "ClassDeclaration":
    case "ForOfStatement":
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "StaticBlock":
    case "TSModuleBlock":
      break;
    case "Placeholder":
      if (e.expectedNode === "BlockStatement")
        break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isBlockParent(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "BlockStatement":
    case "CatchClause":
    case "DoWhileStatement":
    case "ForInStatement":
    case "ForStatement":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "Program":
    case "ObjectMethod":
    case "SwitchStatement":
    case "WhileStatement":
    case "ArrowFunctionExpression":
    case "ForOfStatement":
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "StaticBlock":
    case "TSModuleBlock":
      break;
    case "Placeholder":
      if (e.expectedNode === "BlockStatement")
        break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isBlock(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "BlockStatement":
    case "Program":
    case "TSModuleBlock":
      break;
    case "Placeholder":
      if (e.expectedNode === "BlockStatement")
        break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isStatement$6(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "BlockStatement":
    case "BreakStatement":
    case "ContinueStatement":
    case "DebuggerStatement":
    case "DoWhileStatement":
    case "EmptyStatement":
    case "ExpressionStatement":
    case "ForInStatement":
    case "ForStatement":
    case "FunctionDeclaration":
    case "IfStatement":
    case "LabeledStatement":
    case "ReturnStatement":
    case "SwitchStatement":
    case "ThrowStatement":
    case "TryStatement":
    case "VariableDeclaration":
    case "WhileStatement":
    case "WithStatement":
    case "ClassDeclaration":
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ForOfStatement":
    case "ImportDeclaration":
    case "DeclareClass":
    case "DeclareFunction":
    case "DeclareInterface":
    case "DeclareModule":
    case "DeclareModuleExports":
    case "DeclareTypeAlias":
    case "DeclareOpaqueType":
    case "DeclareVariable":
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
    case "InterfaceDeclaration":
    case "OpaqueType":
    case "TypeAlias":
    case "EnumDeclaration":
    case "TSDeclareFunction":
    case "TSInterfaceDeclaration":
    case "TSTypeAliasDeclaration":
    case "TSEnumDeclaration":
    case "TSModuleDeclaration":
    case "TSImportEqualsDeclaration":
    case "TSExportAssignment":
    case "TSNamespaceExportDeclaration":
      break;
    case "Placeholder":
      switch (e.expectedNode) {
        case "Statement":
        case "Declaration":
        case "BlockStatement":
          break;
        default:
          return !1;
      }
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isTerminatorless(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "BreakStatement":
    case "ContinueStatement":
    case "ReturnStatement":
    case "ThrowStatement":
    case "YieldExpression":
    case "AwaitExpression":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isCompletionStatement(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "BreakStatement":
    case "ContinueStatement":
    case "ReturnStatement":
    case "ThrowStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isConditional(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ConditionalExpression":
    case "IfStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isLoop$1(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "DoWhileStatement":
    case "ForInStatement":
    case "ForStatement":
    case "WhileStatement":
    case "ForOfStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isWhile(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "DoWhileStatement":
    case "WhileStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isExpressionWrapper(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ExpressionStatement":
    case "ParenthesizedExpression":
    case "TypeCastExpression":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isFor$1(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ForInStatement":
    case "ForStatement":
    case "ForOfStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isForXStatement$1(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ForInStatement":
    case "ForOfStatement":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isFunction$5(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ObjectMethod":
    case "ArrowFunctionExpression":
    case "ClassMethod":
    case "ClassPrivateMethod":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isFunctionParent(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ObjectMethod":
    case "ArrowFunctionExpression":
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "StaticBlock":
    case "TSModuleBlock":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isPureish(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "RegExpLiteral":
    case "ArrowFunctionExpression":
    case "BigIntLiteral":
    case "DecimalLiteral":
      break;
    case "Placeholder":
      if (e.expectedNode === "StringLiteral")
        break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isDeclaration(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "FunctionDeclaration":
    case "VariableDeclaration":
    case "ClassDeclaration":
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ImportDeclaration":
    case "DeclareClass":
    case "DeclareFunction":
    case "DeclareInterface":
    case "DeclareModule":
    case "DeclareModuleExports":
    case "DeclareTypeAlias":
    case "DeclareOpaqueType":
    case "DeclareVariable":
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
    case "InterfaceDeclaration":
    case "OpaqueType":
    case "TypeAlias":
    case "EnumDeclaration":
    case "TSDeclareFunction":
    case "TSInterfaceDeclaration":
    case "TSTypeAliasDeclaration":
    case "TSEnumDeclaration":
    case "TSModuleDeclaration":
      break;
    case "Placeholder":
      if (e.expectedNode === "Declaration")
        break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isPatternLike(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "Identifier":
    case "RestElement":
    case "AssignmentPattern":
    case "ArrayPattern":
    case "ObjectPattern":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "TSTypeAssertion":
    case "TSNonNullExpression":
      break;
    case "Placeholder":
      switch (e.expectedNode) {
        case "Pattern":
        case "Identifier":
          break;
        default:
          return !1;
      }
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isLVal(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "Identifier":
    case "MemberExpression":
    case "RestElement":
    case "AssignmentPattern":
    case "ArrayPattern":
    case "ObjectPattern":
    case "TSParameterProperty":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "TSTypeAssertion":
    case "TSNonNullExpression":
      break;
    case "Placeholder":
      switch (e.expectedNode) {
        case "Pattern":
        case "Identifier":
          break;
        default:
          return !1;
      }
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isTSEntityName(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "Identifier":
    case "TSQualifiedName":
      break;
    case "Placeholder":
      if (e.expectedNode === "Identifier")
        break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isLiteral$4(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "RegExpLiteral":
    case "TemplateLiteral":
    case "BigIntLiteral":
    case "DecimalLiteral":
      break;
    case "Placeholder":
      if (e.expectedNode === "StringLiteral")
        break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isImmutable$2(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "StringLiteral":
    case "NumericLiteral":
    case "NullLiteral":
    case "BooleanLiteral":
    case "BigIntLiteral":
    case "JSXAttribute":
    case "JSXClosingElement":
    case "JSXElement":
    case "JSXExpressionContainer":
    case "JSXSpreadChild":
    case "JSXOpeningElement":
    case "JSXText":
    case "JSXFragment":
    case "JSXOpeningFragment":
    case "JSXClosingFragment":
    case "DecimalLiteral":
      break;
    case "Placeholder":
      if (e.expectedNode === "StringLiteral")
        break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isUserWhitespacable(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ObjectMethod":
    case "ObjectProperty":
    case "ObjectTypeInternalSlot":
    case "ObjectTypeCallProperty":
    case "ObjectTypeIndexer":
    case "ObjectTypeProperty":
    case "ObjectTypeSpreadProperty":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isMethod(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ObjectMethod":
    case "ClassMethod":
    case "ClassPrivateMethod":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isObjectMember(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ObjectMethod":
    case "ObjectProperty":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isProperty(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ObjectProperty":
    case "ClassProperty":
    case "ClassAccessorProperty":
    case "ClassPrivateProperty":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isUnaryLike(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "UnaryExpression":
    case "SpreadElement":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isPattern(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "AssignmentPattern":
    case "ArrayPattern":
    case "ObjectPattern":
      break;
    case "Placeholder":
      if (e.expectedNode === "Pattern")
        break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isClass(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ClassExpression":
    case "ClassDeclaration":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isImportOrExportDeclaration(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ImportDeclaration":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isExportDeclaration$2(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isModuleSpecifier(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ExportSpecifier":
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isAccessor(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ClassAccessorProperty":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isPrivate(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "ClassPrivateProperty":
    case "ClassPrivateMethod":
    case "PrivateName":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isFlow$1(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "AnyTypeAnnotation":
    case "ArrayTypeAnnotation":
    case "BooleanTypeAnnotation":
    case "BooleanLiteralTypeAnnotation":
    case "NullLiteralTypeAnnotation":
    case "ClassImplements":
    case "DeclareClass":
    case "DeclareFunction":
    case "DeclareInterface":
    case "DeclareModule":
    case "DeclareModuleExports":
    case "DeclareTypeAlias":
    case "DeclareOpaqueType":
    case "DeclareVariable":
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
    case "DeclaredPredicate":
    case "ExistsTypeAnnotation":
    case "FunctionTypeAnnotation":
    case "FunctionTypeParam":
    case "GenericTypeAnnotation":
    case "InferredPredicate":
    case "InterfaceExtends":
    case "InterfaceDeclaration":
    case "InterfaceTypeAnnotation":
    case "IntersectionTypeAnnotation":
    case "MixedTypeAnnotation":
    case "EmptyTypeAnnotation":
    case "NullableTypeAnnotation":
    case "NumberLiteralTypeAnnotation":
    case "NumberTypeAnnotation":
    case "ObjectTypeAnnotation":
    case "ObjectTypeInternalSlot":
    case "ObjectTypeCallProperty":
    case "ObjectTypeIndexer":
    case "ObjectTypeProperty":
    case "ObjectTypeSpreadProperty":
    case "OpaqueType":
    case "QualifiedTypeIdentifier":
    case "StringLiteralTypeAnnotation":
    case "StringTypeAnnotation":
    case "SymbolTypeAnnotation":
    case "ThisTypeAnnotation":
    case "TupleTypeAnnotation":
    case "TypeofTypeAnnotation":
    case "TypeAlias":
    case "TypeAnnotation":
    case "TypeCastExpression":
    case "TypeParameter":
    case "TypeParameterDeclaration":
    case "TypeParameterInstantiation":
    case "UnionTypeAnnotation":
    case "Variance":
    case "VoidTypeAnnotation":
    case "EnumDeclaration":
    case "EnumBooleanBody":
    case "EnumNumberBody":
    case "EnumStringBody":
    case "EnumSymbolBody":
    case "EnumBooleanMember":
    case "EnumNumberMember":
    case "EnumStringMember":
    case "EnumDefaultedMember":
    case "IndexedAccessType":
    case "OptionalIndexedAccessType":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isFlowType$1(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "AnyTypeAnnotation":
    case "ArrayTypeAnnotation":
    case "BooleanTypeAnnotation":
    case "BooleanLiteralTypeAnnotation":
    case "NullLiteralTypeAnnotation":
    case "ExistsTypeAnnotation":
    case "FunctionTypeAnnotation":
    case "GenericTypeAnnotation":
    case "InterfaceTypeAnnotation":
    case "IntersectionTypeAnnotation":
    case "MixedTypeAnnotation":
    case "EmptyTypeAnnotation":
    case "NullableTypeAnnotation":
    case "NumberLiteralTypeAnnotation":
    case "NumberTypeAnnotation":
    case "ObjectTypeAnnotation":
    case "StringLiteralTypeAnnotation":
    case "StringTypeAnnotation":
    case "SymbolTypeAnnotation":
    case "ThisTypeAnnotation":
    case "TupleTypeAnnotation":
    case "TypeofTypeAnnotation":
    case "UnionTypeAnnotation":
    case "VoidTypeAnnotation":
    case "IndexedAccessType":
    case "OptionalIndexedAccessType":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isFlowBaseAnnotation$1(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "AnyTypeAnnotation":
    case "BooleanTypeAnnotation":
    case "NullLiteralTypeAnnotation":
    case "MixedTypeAnnotation":
    case "EmptyTypeAnnotation":
    case "NumberTypeAnnotation":
    case "StringTypeAnnotation":
    case "SymbolTypeAnnotation":
    case "ThisTypeAnnotation":
    case "VoidTypeAnnotation":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isFlowDeclaration(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "DeclareClass":
    case "DeclareFunction":
    case "DeclareInterface":
    case "DeclareModule":
    case "DeclareModuleExports":
    case "DeclareTypeAlias":
    case "DeclareOpaqueType":
    case "DeclareVariable":
    case "DeclareExportDeclaration":
    case "DeclareExportAllDeclaration":
    case "InterfaceDeclaration":
    case "OpaqueType":
    case "TypeAlias":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isFlowPredicate(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "DeclaredPredicate":
    case "InferredPredicate":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isEnumBody(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "EnumBooleanBody":
    case "EnumNumberBody":
    case "EnumStringBody":
    case "EnumSymbolBody":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isEnumMember(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "EnumBooleanMember":
    case "EnumNumberMember":
    case "EnumStringMember":
    case "EnumDefaultedMember":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isJSX(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "JSXAttribute":
    case "JSXClosingElement":
    case "JSXElement":
    case "JSXEmptyExpression":
    case "JSXExpressionContainer":
    case "JSXSpreadChild":
    case "JSXIdentifier":
    case "JSXMemberExpression":
    case "JSXNamespacedName":
    case "JSXOpeningElement":
    case "JSXSpreadAttribute":
    case "JSXText":
    case "JSXFragment":
    case "JSXOpeningFragment":
    case "JSXClosingFragment":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isMiscellaneous(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "Noop":
    case "Placeholder":
    case "V8IntrinsicIdentifier":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isTypeScript(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "TSParameterProperty":
    case "TSDeclareFunction":
    case "TSDeclareMethod":
    case "TSQualifiedName":
    case "TSCallSignatureDeclaration":
    case "TSConstructSignatureDeclaration":
    case "TSPropertySignature":
    case "TSMethodSignature":
    case "TSIndexSignature":
    case "TSAnyKeyword":
    case "TSBooleanKeyword":
    case "TSBigIntKeyword":
    case "TSIntrinsicKeyword":
    case "TSNeverKeyword":
    case "TSNullKeyword":
    case "TSNumberKeyword":
    case "TSObjectKeyword":
    case "TSStringKeyword":
    case "TSSymbolKeyword":
    case "TSUndefinedKeyword":
    case "TSUnknownKeyword":
    case "TSVoidKeyword":
    case "TSThisType":
    case "TSFunctionType":
    case "TSConstructorType":
    case "TSTypeReference":
    case "TSTypePredicate":
    case "TSTypeQuery":
    case "TSTypeLiteral":
    case "TSArrayType":
    case "TSTupleType":
    case "TSOptionalType":
    case "TSRestType":
    case "TSNamedTupleMember":
    case "TSUnionType":
    case "TSIntersectionType":
    case "TSConditionalType":
    case "TSInferType":
    case "TSParenthesizedType":
    case "TSTypeOperator":
    case "TSIndexedAccessType":
    case "TSMappedType":
    case "TSLiteralType":
    case "TSExpressionWithTypeArguments":
    case "TSInterfaceDeclaration":
    case "TSInterfaceBody":
    case "TSTypeAliasDeclaration":
    case "TSInstantiationExpression":
    case "TSAsExpression":
    case "TSSatisfiesExpression":
    case "TSTypeAssertion":
    case "TSEnumDeclaration":
    case "TSEnumMember":
    case "TSModuleDeclaration":
    case "TSModuleBlock":
    case "TSImportType":
    case "TSImportEqualsDeclaration":
    case "TSExternalModuleReference":
    case "TSNonNullExpression":
    case "TSExportAssignment":
    case "TSNamespaceExportDeclaration":
    case "TSTypeAnnotation":
    case "TSTypeParameterInstantiation":
    case "TSTypeParameterDeclaration":
    case "TSTypeParameter":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isTSTypeElement(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "TSCallSignatureDeclaration":
    case "TSConstructSignatureDeclaration":
    case "TSPropertySignature":
    case "TSMethodSignature":
    case "TSIndexSignature":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isTSType$1(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "TSAnyKeyword":
    case "TSBooleanKeyword":
    case "TSBigIntKeyword":
    case "TSIntrinsicKeyword":
    case "TSNeverKeyword":
    case "TSNullKeyword":
    case "TSNumberKeyword":
    case "TSObjectKeyword":
    case "TSStringKeyword":
    case "TSSymbolKeyword":
    case "TSUndefinedKeyword":
    case "TSUnknownKeyword":
    case "TSVoidKeyword":
    case "TSThisType":
    case "TSFunctionType":
    case "TSConstructorType":
    case "TSTypeReference":
    case "TSTypePredicate":
    case "TSTypeQuery":
    case "TSTypeLiteral":
    case "TSArrayType":
    case "TSTupleType":
    case "TSOptionalType":
    case "TSRestType":
    case "TSUnionType":
    case "TSIntersectionType":
    case "TSConditionalType":
    case "TSInferType":
    case "TSParenthesizedType":
    case "TSTypeOperator":
    case "TSIndexedAccessType":
    case "TSMappedType":
    case "TSLiteralType":
    case "TSExpressionWithTypeArguments":
    case "TSImportType":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isTSBaseType(e, t) {
  if (!e)
    return !1;
  switch (e.type) {
    case "TSAnyKeyword":
    case "TSBooleanKeyword":
    case "TSBigIntKeyword":
    case "TSIntrinsicKeyword":
    case "TSNeverKeyword":
    case "TSNullKeyword":
    case "TSNumberKeyword":
    case "TSObjectKeyword":
    case "TSStringKeyword":
    case "TSSymbolKeyword":
    case "TSUndefinedKeyword":
    case "TSUnknownKeyword":
    case "TSVoidKeyword":
    case "TSThisType":
    case "TSLiteralType":
      break;
    default:
      return !1;
  }
  return t == null || (0, _shallowEqual.default)(e, t);
}
function isNumberLiteral(e, t) {
  return (0, _deprecationWarning$1.default)("isNumberLiteral", "isNumericLiteral"), !e || e.type !== "NumberLiteral" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isRegexLiteral(e, t) {
  return (0, _deprecationWarning$1.default)("isRegexLiteral", "isRegExpLiteral"), !e || e.type !== "RegexLiteral" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isRestProperty$1(e, t) {
  return (0, _deprecationWarning$1.default)("isRestProperty", "isRestElement"), !e || e.type !== "RestProperty" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isSpreadProperty$1(e, t) {
  return (0, _deprecationWarning$1.default)("isSpreadProperty", "isSpreadElement"), !e || e.type !== "SpreadProperty" ? !1 : t == null || (0, _shallowEqual.default)(e, t);
}
function isModuleDeclaration(e, t) {
  return (0, _deprecationWarning$1.default)("isModuleDeclaration", "isImportOrExportDeclaration"), isImportOrExportDeclaration(e, t);
}
Object.defineProperty(matchesPattern$2, "__esModule", {
  value: !0
});
matchesPattern$2.default = matchesPattern$1;
var _index$k = generated$3;
function matchesPattern$1(e, t, s) {
  if (!(0, _index$k.isMemberExpression)(e))
    return !1;
  const i = Array.isArray(t) ? t : t.split("."), a = [];
  let o;
  for (o = e; (0, _index$k.isMemberExpression)(o); o = o.object)
    a.push(o.property);
  if (a.push(o), a.length < i.length || !s && a.length > i.length)
    return !1;
  for (let l = 0, f = a.length - 1; l < i.length; l++, f--) {
    const y = a[f];
    let g;
    if ((0, _index$k.isIdentifier)(y))
      g = y.name;
    else if ((0, _index$k.isStringLiteral)(y))
      g = y.value;
    else if ((0, _index$k.isThisExpression)(y))
      g = "this";
    else
      return !1;
    if (i[l] !== g)
      return !1;
  }
  return !0;
}
Object.defineProperty(buildMatchMemberExpression$1, "__esModule", {
  value: !0
});
buildMatchMemberExpression$1.default = buildMatchMemberExpression;
var _matchesPattern$1 = matchesPattern$2;
function buildMatchMemberExpression(e, t) {
  const s = e.split(".");
  return (i) => (0, _matchesPattern$1.default)(i, s, t);
}
Object.defineProperty(isReactComponent$1, "__esModule", {
  value: !0
});
isReactComponent$1.default = void 0;
var _buildMatchMemberExpression = buildMatchMemberExpression$1;
const isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
isReactComponent$1.default = isReactComponent;
var isCompatTag$2 = {};
Object.defineProperty(isCompatTag$2, "__esModule", {
  value: !0
});
isCompatTag$2.default = isCompatTag$1;
function isCompatTag$1(e) {
  return !!e && /^[a-z]/.test(e);
}
var buildChildren = {}, cleanJSXElementLiteralChild = {}, generated$2 = {}, validateNode = {}, validate$2 = {}, definitions = {};
let fastProto = null;
function FastObject(e) {
  if (fastProto !== null && typeof fastProto.property) {
    const t = fastProto;
    return fastProto = FastObject.prototype = null, t;
  }
  return fastProto = FastObject.prototype = e ?? /* @__PURE__ */ Object.create(null), new FastObject();
}
FastObject();
var toFastProperties = function(t) {
  return FastObject(t);
}, core = {}, is = {}, isType$2 = {}, hasRequiredIsType;
function requireIsType() {
  if (hasRequiredIsType)
    return isType$2;
  hasRequiredIsType = 1, Object.defineProperty(isType$2, "__esModule", {
    value: !0
  }), isType$2.default = t;
  var e = requireDefinitions();
  function t(s, i) {
    if (s === i)
      return !0;
    if (s == null || e.ALIAS_KEYS[i])
      return !1;
    const a = e.FLIPPED_ALIAS_KEYS[i];
    if (a) {
      if (a[0] === s)
        return !0;
      for (const o of a)
        if (s === o)
          return !0;
    }
    return !1;
  }
  return isType$2;
}
var isPlaceholderType = {}, hasRequiredIsPlaceholderType;
function requireIsPlaceholderType() {
  if (hasRequiredIsPlaceholderType)
    return isPlaceholderType;
  hasRequiredIsPlaceholderType = 1, Object.defineProperty(isPlaceholderType, "__esModule", {
    value: !0
  }), isPlaceholderType.default = t;
  var e = requireDefinitions();
  function t(s, i) {
    if (s === i)
      return !0;
    const a = e.PLACEHOLDERS_ALIAS[s];
    if (a) {
      for (const o of a)
        if (i === o)
          return !0;
    }
    return !1;
  }
  return isPlaceholderType;
}
var hasRequiredIs;
function requireIs() {
  if (hasRequiredIs)
    return is;
  hasRequiredIs = 1, Object.defineProperty(is, "__esModule", {
    value: !0
  }), is.default = a;
  var e = shallowEqual$1, t = requireIsType(), s = requireIsPlaceholderType(), i = requireDefinitions();
  function a(o, l, f) {
    return l ? (0, t.default)(l.type, o) ? typeof f > "u" ? !0 : (0, e.default)(l, f) : !f && l.type === "Placeholder" && o in i.FLIPPED_ALIAS_KEYS ? (0, s.default)(l.expectedNode, o) : !1 : !1;
  }
  return is;
}
var isValidIdentifier$1 = {}, lib$a = {}, identifier$5 = {};
Object.defineProperty(identifier$5, "__esModule", {
  value: !0
});
identifier$5.isIdentifierChar = isIdentifierChar$1;
identifier$5.isIdentifierName = isIdentifierName;
identifier$5.isIdentifierStart = isIdentifierStart$1;
let nonASCIIidentifierStartChars$1 = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", nonASCIIidentifierChars$1 = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
const nonASCIIidentifierStart$1 = new RegExp("[" + nonASCIIidentifierStartChars$1 + "]"), nonASCIIidentifier$1 = new RegExp("[" + nonASCIIidentifierStartChars$1 + nonASCIIidentifierChars$1 + "]");
nonASCIIidentifierStartChars$1 = nonASCIIidentifierChars$1 = null;
const astralIdentifierStartCodes$1 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], astralIdentifierCodes$1 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function isInAstralSet$1(e, t) {
  let s = 65536;
  for (let i = 0, a = t.length; i < a; i += 2) {
    if (s += t[i], s > e)
      return !1;
    if (s += t[i + 1], s >= e)
      return !0;
  }
  return !1;
}
function isIdentifierStart$1(e) {
  return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && nonASCIIidentifierStart$1.test(String.fromCharCode(e)) : isInAstralSet$1(e, astralIdentifierStartCodes$1);
}
function isIdentifierChar$1(e) {
  return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && nonASCIIidentifier$1.test(String.fromCharCode(e)) : isInAstralSet$1(e, astralIdentifierStartCodes$1) || isInAstralSet$1(e, astralIdentifierCodes$1);
}
function isIdentifierName(e) {
  let t = !0;
  for (let s = 0; s < e.length; s++) {
    let i = e.charCodeAt(s);
    if ((i & 64512) === 55296 && s + 1 < e.length) {
      const a = e.charCodeAt(++s);
      (a & 64512) === 56320 && (i = 65536 + ((i & 1023) << 10) + (a & 1023));
    }
    if (t) {
      if (t = !1, !isIdentifierStart$1(i))
        return !1;
    } else if (!isIdentifierChar$1(i))
      return !1;
  }
  return !t;
}
var keyword = {};
Object.defineProperty(keyword, "__esModule", {
  value: !0
});
keyword.isKeyword = isKeyword$1;
keyword.isReservedWord = isReservedWord$1;
keyword.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord$1;
keyword.isStrictBindReservedWord = isStrictBindReservedWord$1;
keyword.isStrictReservedWord = isStrictReservedWord$1;
const reservedWords$1 = {
  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
}, keywords$2 = new Set(reservedWords$1.keyword), reservedWordsStrictSet$1 = new Set(reservedWords$1.strict), reservedWordsStrictBindSet$1 = new Set(reservedWords$1.strictBind);
function isReservedWord$1(e, t) {
  return t && e === "await" || e === "enum";
}
function isStrictReservedWord$1(e, t) {
  return isReservedWord$1(e, t) || reservedWordsStrictSet$1.has(e);
}
function isStrictBindOnlyReservedWord$1(e) {
  return reservedWordsStrictBindSet$1.has(e);
}
function isStrictBindReservedWord$1(e, t) {
  return isStrictReservedWord$1(e, t) || isStrictBindOnlyReservedWord$1(e);
}
function isKeyword$1(e) {
  return keywords$2.has(e);
}
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), Object.defineProperty(e, "isIdentifierChar", {
    enumerable: !0,
    get: function() {
      return t.isIdentifierChar;
    }
  }), Object.defineProperty(e, "isIdentifierName", {
    enumerable: !0,
    get: function() {
      return t.isIdentifierName;
    }
  }), Object.defineProperty(e, "isIdentifierStart", {
    enumerable: !0,
    get: function() {
      return t.isIdentifierStart;
    }
  }), Object.defineProperty(e, "isKeyword", {
    enumerable: !0,
    get: function() {
      return s.isKeyword;
    }
  }), Object.defineProperty(e, "isReservedWord", {
    enumerable: !0,
    get: function() {
      return s.isReservedWord;
    }
  }), Object.defineProperty(e, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: function() {
      return s.isStrictBindOnlyReservedWord;
    }
  }), Object.defineProperty(e, "isStrictBindReservedWord", {
    enumerable: !0,
    get: function() {
      return s.isStrictBindReservedWord;
    }
  }), Object.defineProperty(e, "isStrictReservedWord", {
    enumerable: !0,
    get: function() {
      return s.isStrictReservedWord;
    }
  });
  var t = identifier$5, s = keyword;
})(lib$a);
Object.defineProperty(isValidIdentifier$1, "__esModule", {
  value: !0
});
isValidIdentifier$1.default = isValidIdentifier;
var _helperValidatorIdentifier$2 = lib$a;
function isValidIdentifier(e, t = !0) {
  return typeof e != "string" || t && ((0, _helperValidatorIdentifier$2.isKeyword)(e) || (0, _helperValidatorIdentifier$2.isStrictReservedWord)(e, !0)) ? !1 : (0, _helperValidatorIdentifier$2.isIdentifierName)(e);
}
var lib$9 = {};
Object.defineProperty(lib$9, "__esModule", {
  value: !0
});
lib$9.readCodePoint = readCodePoint$1;
lib$9.readInt = readInt$1;
lib$9.readStringContents = readStringContents$1;
var _isDigit$1 = function(t) {
  return t >= 48 && t <= 57;
};
const forbiddenNumericSeparatorSiblings$1 = {
  decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
  hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
}, isAllowedNumericSeparatorSibling$1 = {
  bin: (e) => e === 48 || e === 49,
  oct: (e) => e >= 48 && e <= 55,
  dec: (e) => e >= 48 && e <= 57,
  hex: (e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102
};
function readStringContents$1(e, t, s, i, a, o) {
  const l = s, f = i, y = a;
  let g = "", T = null, S = s;
  const {
    length: b
  } = t;
  for (; ; ) {
    if (s >= b) {
      o.unterminated(l, f, y), g += t.slice(S, s);
      break;
    }
    const v = t.charCodeAt(s);
    if (isStringEnd$1(e, v, t, s)) {
      g += t.slice(S, s);
      break;
    }
    if (v === 92) {
      g += t.slice(S, s);
      const $ = readEscapedChar$1(t, s, i, a, e === "template", o);
      $.ch === null && !T ? T = {
        pos: s,
        lineStart: i,
        curLine: a
      } : g += $.ch, {
        pos: s,
        lineStart: i,
        curLine: a
      } = $, S = s;
    } else
      v === 8232 || v === 8233 ? (++s, ++a, i = s) : v === 10 || v === 13 ? e === "template" ? (g += t.slice(S, s) + `
`, ++s, v === 13 && t.charCodeAt(s) === 10 && ++s, ++a, S = i = s) : o.unterminated(l, f, y) : ++s;
  }
  return {
    pos: s,
    str: g,
    firstInvalidLoc: T,
    lineStart: i,
    curLine: a,
    containsInvalid: !!T
  };
}
function isStringEnd$1(e, t, s, i) {
  return e === "template" ? t === 96 || t === 36 && s.charCodeAt(i + 1) === 123 : t === (e === "double" ? 34 : 39);
}
function readEscapedChar$1(e, t, s, i, a, o) {
  const l = !a;
  t++;
  const f = (g) => ({
    pos: t,
    ch: g,
    lineStart: s,
    curLine: i
  }), y = e.charCodeAt(t++);
  switch (y) {
    case 110:
      return f(`
`);
    case 114:
      return f("\r");
    case 120: {
      let g;
      return {
        code: g,
        pos: t
      } = readHexChar$1(e, t, s, i, 2, !1, l, o), f(g === null ? null : String.fromCharCode(g));
    }
    case 117: {
      let g;
      return {
        code: g,
        pos: t
      } = readCodePoint$1(e, t, s, i, l, o), f(g === null ? null : String.fromCodePoint(g));
    }
    case 116:
      return f("	");
    case 98:
      return f("\b");
    case 118:
      return f("\v");
    case 102:
      return f("\f");
    case 13:
      e.charCodeAt(t) === 10 && ++t;
    case 10:
      s = t, ++i;
    case 8232:
    case 8233:
      return f("");
    case 56:
    case 57:
      if (a)
        return f(null);
      o.strictNumericEscape(t - 1, s, i);
    default:
      if (y >= 48 && y <= 55) {
        const g = t - 1;
        let S = e.slice(g, t + 2).match(/^[0-7]+/)[0], b = parseInt(S, 8);
        b > 255 && (S = S.slice(0, -1), b = parseInt(S, 8)), t += S.length - 1;
        const v = e.charCodeAt(t);
        if (S !== "0" || v === 56 || v === 57) {
          if (a)
            return f(null);
          o.strictNumericEscape(g, s, i);
        }
        return f(String.fromCharCode(b));
      }
      return f(String.fromCharCode(y));
  }
}
function readHexChar$1(e, t, s, i, a, o, l, f) {
  const y = t;
  let g;
  return {
    n: g,
    pos: t
  } = readInt$1(e, t, s, i, 16, a, o, !1, f, !l), g === null && (l ? f.invalidEscapeSequence(y, s, i) : t = y - 1), {
    code: g,
    pos: t
  };
}
function readInt$1(e, t, s, i, a, o, l, f, y, g) {
  const T = t, S = a === 16 ? forbiddenNumericSeparatorSiblings$1.hex : forbiddenNumericSeparatorSiblings$1.decBinOct, b = a === 16 ? isAllowedNumericSeparatorSibling$1.hex : a === 10 ? isAllowedNumericSeparatorSibling$1.dec : a === 8 ? isAllowedNumericSeparatorSibling$1.oct : isAllowedNumericSeparatorSibling$1.bin;
  let v = !1, $ = 0;
  for (let U = 0, X = o ?? 1 / 0; U < X; ++U) {
    const k = e.charCodeAt(t);
    let D;
    if (k === 95 && f !== "bail") {
      const B = e.charCodeAt(t - 1), Z = e.charCodeAt(t + 1);
      if (f) {
        if (Number.isNaN(Z) || !b(Z) || S.has(B) || S.has(Z)) {
          if (g)
            return {
              n: null,
              pos: t
            };
          y.unexpectedNumericSeparator(t, s, i);
        }
      } else {
        if (g)
          return {
            n: null,
            pos: t
          };
        y.numericSeparatorInEscapeSequence(t, s, i);
      }
      ++t;
      continue;
    }
    if (k >= 97 ? D = k - 97 + 10 : k >= 65 ? D = k - 65 + 10 : _isDigit$1(k) ? D = k - 48 : D = 1 / 0, D >= a) {
      if (D <= 9 && g)
        return {
          n: null,
          pos: t
        };
      if (D <= 9 && y.invalidDigit(t, s, i, a))
        D = 0;
      else if (l)
        D = 0, v = !0;
      else
        break;
    }
    ++t, $ = $ * a + D;
  }
  return t === T || o != null && t - T !== o || v ? {
    n: null,
    pos: t
  } : {
    n: $,
    pos: t
  };
}
function readCodePoint$1(e, t, s, i, a, o) {
  const l = e.charCodeAt(t);
  let f;
  if (l === 123) {
    if (++t, {
      code: f,
      pos: t
    } = readHexChar$1(e, t, s, i, e.indexOf("}", t) - t, !0, a, o), ++t, f !== null && f > 1114111)
      if (a)
        o.invalidCodePoint(t, s, i);
      else
        return {
          code: null,
          pos: t
        };
  } else
    ({
      code: f,
      pos: t
    } = readHexChar$1(e, t, s, i, 4, !1, a, o));
  return {
    code: f,
    pos: t
  };
}
var constants = {};
Object.defineProperty(constants, "__esModule", {
  value: !0
});
constants.UPDATE_OPERATORS = constants.UNARY_OPERATORS = constants.STRING_UNARY_OPERATORS = constants.STATEMENT_OR_BLOCK_KEYS = constants.NUMBER_UNARY_OPERATORS = constants.NUMBER_BINARY_OPERATORS = constants.NOT_LOCAL_BINDING = constants.LOGICAL_OPERATORS = constants.INHERIT_KEYS = constants.FOR_INIT_KEYS = constants.FLATTENABLE_KEYS = constants.EQUALITY_BINARY_OPERATORS = constants.COMPARISON_BINARY_OPERATORS = constants.COMMENT_KEYS = constants.BOOLEAN_UNARY_OPERATORS = constants.BOOLEAN_NUMBER_BINARY_OPERATORS = constants.BOOLEAN_BINARY_OPERATORS = constants.BLOCK_SCOPED_SYMBOL = constants.BINARY_OPERATORS = constants.ASSIGNMENT_OPERATORS = void 0;
constants.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
constants.FLATTENABLE_KEYS = ["body", "expressions"];
constants.FOR_INIT_KEYS = ["left", "init"];
constants.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
const LOGICAL_OPERATORS$1 = constants.LOGICAL_OPERATORS = ["||", "&&", "??"];
constants.UPDATE_OPERATORS = ["++", "--"];
const BOOLEAN_NUMBER_BINARY_OPERATORS$1 = constants.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], EQUALITY_BINARY_OPERATORS = constants.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], COMPARISON_BINARY_OPERATORS = constants.COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"], BOOLEAN_BINARY_OPERATORS = constants.BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS$1], NUMBER_BINARY_OPERATORS = constants.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
constants.BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
constants.ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((e) => e + "="), ...LOGICAL_OPERATORS$1.map((e) => e + "=")];
const BOOLEAN_UNARY_OPERATORS = constants.BOOLEAN_UNARY_OPERATORS = ["delete", "!"], NUMBER_UNARY_OPERATORS = constants.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], STRING_UNARY_OPERATORS = constants.STRING_UNARY_OPERATORS = ["typeof"];
constants.UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
constants.INHERIT_KEYS = {
  optional: ["typeAnnotation", "typeParameters", "returnType"],
  force: ["start", "loc", "end"]
};
constants.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
constants.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
var utils = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils;
  hasRequiredUtils = 1, Object.defineProperty(utils, "__esModule", {
    value: !0
  }), utils.VISITOR_KEYS = utils.NODE_PARENT_VALIDATIONS = utils.NODE_FIELDS = utils.FLIPPED_ALIAS_KEYS = utils.DEPRECATED_KEYS = utils.BUILDER_KEYS = utils.ALIAS_KEYS = void 0, utils.arrayOf = U, utils.arrayOfType = X, utils.assertEach = D, utils.assertNodeOrValueType = H, utils.assertNodeType = Z, utils.assertOneOf = B, utils.assertOptionalChainStart = j, utils.assertShape = _, utils.assertValueType = q, utils.chain = V, utils.default = ve, utils.defineAliasedType = be, utils.typeIs = S, utils.validate = T, utils.validateArrayOfType = k, utils.validateOptional = v, utils.validateOptionalType = $, utils.validateType = b;
  var e = requireIs(), t = requireValidate();
  const s = utils.VISITOR_KEYS = {}, i = utils.ALIAS_KEYS = {}, a = utils.FLIPPED_ALIAS_KEYS = {}, o = utils.NODE_FIELDS = {}, l = utils.BUILDER_KEYS = {}, f = utils.DEPRECATED_KEYS = {}, y = utils.NODE_PARENT_VALIDATIONS = {};
  function g(F) {
    return Array.isArray(F) ? "array" : F === null ? "null" : typeof F;
  }
  function T(F) {
    return {
      validate: F
    };
  }
  function S(F) {
    return typeof F == "string" ? Z(F) : Z(...F);
  }
  function b(F) {
    return T(S(F));
  }
  function v(F) {
    return {
      validate: F,
      optional: !0
    };
  }
  function $(F) {
    return {
      validate: S(F),
      optional: !0
    };
  }
  function U(F) {
    return V(q("array"), D(F));
  }
  function X(F) {
    return U(S(F));
  }
  function k(F) {
    return T(X(F));
  }
  function D(F) {
    function R(K, z, re) {
      if (Array.isArray(re))
        for (let ie = 0; ie < re.length; ie++) {
          const fe = `${z}[${ie}]`, ce = re[ie];
          F(K, fe, ce);
        }
    }
    return R.each = F, R;
  }
  function B(...F) {
    function R(K, z, re) {
      if (F.indexOf(re) < 0)
        throw new TypeError(`Property ${z} expected value to be one of ${JSON.stringify(F)} but got ${JSON.stringify(re)}`);
    }
    return R.oneOf = F, R;
  }
  function Z(...F) {
    function R(K, z, re) {
      for (const ie of F)
        if ((0, e.default)(ie, re)) {
          (0, t.validateChild)(K, z, re);
          return;
        }
      throw new TypeError(`Property ${z} of ${K.type} expected node to be of a type ${JSON.stringify(F)} but instead got ${JSON.stringify(re == null ? void 0 : re.type)}`);
    }
    return R.oneOfNodeTypes = F, R;
  }
  function H(...F) {
    function R(K, z, re) {
      for (const ie of F)
        if (g(re) === ie || (0, e.default)(ie, re)) {
          (0, t.validateChild)(K, z, re);
          return;
        }
      throw new TypeError(`Property ${z} of ${K.type} expected node to be of a type ${JSON.stringify(F)} but instead got ${JSON.stringify(re == null ? void 0 : re.type)}`);
    }
    return R.oneOfNodeOrValueTypes = F, R;
  }
  function q(F) {
    function R(K, z, re) {
      if (!(g(re) === F))
        throw new TypeError(`Property ${z} expected type of ${F} but got ${g(re)}`);
    }
    return R.type = F, R;
  }
  function _(F) {
    function R(K, z, re) {
      const ie = [];
      for (const fe of Object.keys(F))
        try {
          (0, t.validateField)(K, fe, re[fe], F[fe]);
        } catch (ce) {
          if (ce instanceof TypeError) {
            ie.push(ce.message);
            continue;
          }
          throw ce;
        }
      if (ie.length)
        throw new TypeError(`Property ${z} of ${K.type} expected to have the following:
${ie.join(`
`)}`);
    }
    return R.shapeOf = F, R;
  }
  function j() {
    function F(R) {
      var K;
      let z = R;
      for (; R; ) {
        const {
          type: re
        } = z;
        if (re === "OptionalCallExpression") {
          if (z.optional)
            return;
          z = z.callee;
          continue;
        }
        if (re === "OptionalMemberExpression") {
          if (z.optional)
            return;
          z = z.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${R.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(K = z) == null ? void 0 : K.type}`);
    }
    return F;
  }
  function V(...F) {
    function R(...K) {
      for (const z of F)
        z(...K);
    }
    if (R.chainOf = F, F.length >= 2 && "type" in F[0] && F[0].type === "array" && !("each" in F[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return R;
  }
  const ue = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], ee = ["default", "optional", "deprecated", "validate"], se = {};
  function be(...F) {
    return (R, K = {}) => {
      let z = K.aliases;
      if (!z) {
        var re, ie;
        K.inherits && (z = (re = se[K.inherits].aliases) == null ? void 0 : re.slice()), (ie = z) != null || (z = []), K.aliases = z;
      }
      const fe = F.filter((ce) => !z.includes(ce));
      z.unshift(...fe), ve(R, K);
    };
  }
  function ve(F, R = {}) {
    const K = R.inherits && se[R.inherits] || {};
    let z = R.fields;
    if (!z && (z = {}, K.fields)) {
      const ce = Object.getOwnPropertyNames(K.fields);
      for (const Pe of ce) {
        const Ce = K.fields[Pe], _e = Ce.default;
        if (Array.isArray(_e) ? _e.length > 0 : _e && typeof _e == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        z[Pe] = {
          default: Array.isArray(_e) ? [] : _e,
          optional: Ce.optional,
          deprecated: Ce.deprecated,
          validate: Ce.validate
        };
      }
    }
    const re = R.visitor || K.visitor || [], ie = R.aliases || K.aliases || [], fe = R.builder || K.builder || R.visitor || [];
    for (const ce of Object.keys(R))
      if (ue.indexOf(ce) === -1)
        throw new Error(`Unknown type option "${ce}" on ${F}`);
    R.deprecatedAlias && (f[R.deprecatedAlias] = F);
    for (const ce of re.concat(fe))
      z[ce] = z[ce] || {};
    for (const ce of Object.keys(z)) {
      const Pe = z[ce];
      Pe.default !== void 0 && fe.indexOf(ce) === -1 && (Pe.optional = !0), Pe.default === void 0 ? Pe.default = null : !Pe.validate && Pe.default != null && (Pe.validate = q(g(Pe.default)));
      for (const Ce of Object.keys(Pe))
        if (ee.indexOf(Ce) === -1)
          throw new Error(`Unknown field key "${Ce}" on ${F}.${ce}`);
    }
    s[F] = R.visitor = re, l[F] = R.builder = fe, o[F] = R.fields = z, i[F] = R.aliases = ie, ie.forEach((ce) => {
      a[ce] = a[ce] || [], a[ce].push(F);
    }), R.validate && (y[F] = R.validate), se[F] = R;
  }
  return utils;
}
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore)
    return core;
  hasRequiredCore = 1, Object.defineProperty(core, "__esModule", {
    value: !0
  }), core.patternLikeCommon = core.functionTypeAnnotationCommon = core.functionDeclarationCommon = core.functionCommon = core.classMethodOrPropertyCommon = core.classMethodOrDeclareMethodCommon = void 0, requireIs();
  var e = lib$9, t = constants, s = requireUtils();
  const i = (0, s.defineAliasedType)("Standardized");
  i("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeOrValueType)("null", "Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  }), i("AssignmentExpression", {
    fields: {
      operator: {
        validate: function() {
          return (0, s.assertValueType)("string");
        }()
      },
      left: {
        validate: (0, s.assertNodeType)("LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, s.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  }), i("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, s.assertOneOf)(...t.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          const T = (0, s.assertNodeType)("Expression"), S = (0, s.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(v, $, U) {
            (v.operator === "in" ? S : T)(v, $, U);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, s.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  }), i("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, s.assertValueType)("string")
      }
    }
  }), i("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, s.assertNodeType)("DirectiveLiteral")
      }
    }
  }), i("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, s.assertValueType)("string")
      }
    }
  }), i("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  }), i("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, s.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  }), i("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, s.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      }
    }, {
      optional: {
        validate: (0, s.assertOneOf)(!0, !1),
        optional: !0
      }
    }, {
      typeArguments: {
        validate: (0, s.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, s.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  }), i("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, s.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, s.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  }), i("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, s.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, s.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, s.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  }), i("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, s.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  }), i("DebuggerStatement", {
    aliases: ["Statement"]
  }), i("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: (0, s.assertNodeType)("Expression")
      },
      body: {
        validate: (0, s.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  }), i("EmptyStatement", {
    aliases: ["Statement"]
  }), i("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, s.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  }), i("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, s.assertNodeType)("Program")
      },
      comments: {
        validate: Object.assign(() => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, s.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  }), i("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: (0, s.assertNodeType)("VariableDeclaration", "LVal")
      },
      right: {
        validate: (0, s.assertNodeType)("Expression")
      },
      body: {
        validate: (0, s.assertNodeType)("Statement")
      }
    }
  }), i("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, s.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, s.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, s.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, s.assertNodeType)("Statement")
      }
    }
  });
  const a = () => ({
    params: {
      validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  });
  core.functionCommon = a;
  const o = () => ({
    returnType: {
      validate: (0, s.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, s.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  });
  core.functionTypeAnnotationCommon = o;
  const l = () => Object.assign({}, a(), {
    declare: {
      validate: (0, s.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, s.assertNodeType)("Identifier"),
      optional: !0
    }
  });
  core.functionDeclarationCommon = l, i("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, l(), o(), {
      body: {
        validate: (0, s.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, s.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function() {
      return () => {
      };
    }()
  }), i("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, a(), o(), {
      id: {
        validate: (0, s.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, s.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, s.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  const f = () => ({
    typeAnnotation: {
      validate: (0, s.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, s.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))),
      optional: !0
    }
  });
  core.patternLikeCommon = f, i("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, f(), {
      name: {
        validate: (0, s.chain)((0, s.assertValueType)("string"), Object.assign(function(T, S, b) {
        }, {
          type: "string"
        }))
      }
    }),
    validate(T, S, b) {
    }
  }), i("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, s.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, s.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, s.assertNodeType)("Statement")
      }
    }
  }), i("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, s.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, s.assertNodeType)("Statement")
      }
    }
  }), i("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, s.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), i("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, s.chain)((0, s.assertValueType)("number"), Object.assign(function(T, S, b) {
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), i("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), i("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, s.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), i("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, s.assertValueType)("string")
      },
      flags: {
        validate: (0, s.chain)((0, s.assertValueType)("string"), Object.assign(function(T, S, b) {
        }, {
          type: "string"
        })),
        default: ""
      }
    }
  }), i("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, s.assertOneOf)(...t.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, s.assertNodeType)("Expression")
      },
      right: {
        validate: (0, s.assertNodeType)("Expression")
      }
    }
  }), i("MemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: (0, s.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          const T = (0, s.assertNodeType)("Identifier", "PrivateName"), S = (0, s.assertNodeType)("Expression"), b = function(v, $, U) {
            (v.computed ? S : T)(v, $, U);
          };
          return b.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], b;
        }()
      },
      computed: {
        default: !1
      }
    }, {
      optional: {
        validate: (0, s.assertOneOf)(!0, !1),
        optional: !0
      }
    })
  }), i("NewExpression", {
    inherits: "CallExpression"
  }), i("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceFile: {
        validate: (0, s.assertValueType)("string")
      },
      sourceType: {
        validate: (0, s.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, s.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Directive"))),
        default: []
      },
      body: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  }), i("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement")))
      }
    }
  }), i("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, a(), o(), {
      kind: Object.assign({
        validate: (0, s.assertOneOf)("method", "get", "set")
      }, {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          const T = (0, s.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), S = (0, s.assertNodeType)("Expression"), b = function(v, $, U) {
            (v.computed ? S : T)(v, $, U);
          };
          return b.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], b;
        }()
      },
      decorators: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))),
        optional: !0
      },
      body: {
        validate: (0, s.assertNodeType)("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  }), i("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", "decorators"],
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          const T = (0, s.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), S = (0, s.assertNodeType)("Expression");
          return Object.assign(function(v, $, U) {
            (v.computed ? S : T)(v, $, U);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, s.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: (0, s.chain)((0, s.assertValueType)("boolean"), Object.assign(function(T, S, b) {
        }, {
          type: "boolean"
        }), function(T, S, b) {
        }),
        default: !1
      },
      decorators: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))),
        optional: !0
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function() {
      return (0, s.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), (0, s.assertNodeType)("Expression"), function(T, S, b) {
      };
    }()
  }), i("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, f(), {
      argument: {
        validate: (0, s.assertNodeType)("LVal")
      }
    }),
    validate(T, S) {
    }
  }), i("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, s.assertNodeType)("Expression"),
        optional: !0
      }
    }
  }), i("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Expression")))
      }
    },
    aliases: ["Expression"]
  }), i("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, s.assertNodeType)("Expression")
      }
    }
  }), i("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, s.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Statement")))
      }
    }
  }), i("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, s.assertNodeType)("Expression")
      },
      cases: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("SwitchCase")))
      }
    }
  }), i("ThisExpression", {
    aliases: ["Expression"]
  }), i("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, s.assertNodeType)("Expression")
      }
    }
  }), i("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: (0, s.chain)((0, s.assertNodeType)("BlockStatement"), Object.assign(function(T) {
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: !0,
        validate: (0, s.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, s.assertNodeType)("BlockStatement")
      }
    }
  }), i("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, s.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, s.assertOneOf)(...t.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  }), i("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: (0, s.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, s.assertOneOf)(...t.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  }), i("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, s.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, s.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("VariableDeclarator")))
      }
    },
    validate(T, S, b) {
    }
  }), i("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function() {
          return (0, s.assertNodeType)("LVal");
        }()
      },
      definite: {
        optional: !0,
        validate: (0, s.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, s.assertNodeType)("Expression")
      }
    }
  }), i("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, s.assertNodeType)("Expression")
      },
      body: {
        validate: (0, s.assertNodeType)("Statement")
      }
    }
  }), i("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, s.assertNodeType)("Expression")
      },
      body: {
        validate: (0, s.assertNodeType)("Statement")
      }
    }
  }), i("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, f(), {
      left: {
        validate: (0, s.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, s.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))),
        optional: !0
      }
    })
  }), i("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, f(), {
      elements: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeOrValueType)("null", "PatternLike", "LVal")))
      }
    })
  }), i("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, a(), o(), {
      expression: {
        validate: (0, s.assertValueType)("boolean")
      },
      body: {
        validate: (0, s.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, s.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  }), i("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")))
      }
    }
  }), i("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, s.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, s.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, s.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, s.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, s.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, s.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  }), i("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, s.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, s.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, s.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, s.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, s.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: !0
      },
      decorators: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))),
        optional: !0
      },
      mixins: {
        validate: (0, s.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, s.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, s.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: function() {
      return (0, s.assertNodeType)("Identifier"), function(T, S, b) {
      };
    }()
  }), i("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: (0, s.assertNodeType)("StringLiteral")
      },
      exportKind: (0, s.validateOptional)((0, s.assertOneOf)("type", "value")),
      attributes: {
        optional: !0,
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ImportAttribute")))
      }
    }
  }), i("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: (0, s.assertNodeType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression")
      },
      exportKind: (0, s.validateOptional)((0, s.assertOneOf)("value"))
    }
  }), i("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: !0,
        validate: (0, s.chain)((0, s.assertNodeType)("Declaration"), Object.assign(function(T, S, b) {
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function(T, S, b) {
        })
      },
      attributes: {
        optional: !0,
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ImportAttribute")))
      },
      specifiers: {
        default: [],
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)(function() {
          const T = (0, s.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
          return (0, s.assertNodeType)("ExportSpecifier"), T;
        }()))
      },
      source: {
        validate: (0, s.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, s.validateOptional)((0, s.assertOneOf)("type", "value"))
    }
  }), i("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, s.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, s.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, s.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  }), i("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          return (0, s.assertNodeType)("VariableDeclaration", "LVal");
        }()
      },
      right: {
        validate: (0, s.assertNodeType)("Expression")
      },
      body: {
        validate: (0, s.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  }), i("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: {
      attributes: {
        optional: !0,
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ImportAttribute")))
      },
      assertions: {
        optional: !0,
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ImportAttribute")))
      },
      module: {
        optional: !0,
        validate: (0, s.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, s.assertOneOf)("source", "defer")
      },
      specifiers: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: (0, s.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, s.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  }), i("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, s.assertNodeType)("Identifier")
      }
    }
  }), i("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, s.assertNodeType)("Identifier")
      }
    }
  }), i("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, s.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, s.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, s.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  }), i("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, s.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, s.assertNodeType)("Expression")
      },
      options: {
        validate: (0, s.assertNodeType)("Expression"),
        optional: !0
      }
    }
  }), i("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: (0, s.chain)((0, s.assertNodeType)("Identifier"), Object.assign(function(T, S, b) {
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: (0, s.assertNodeType)("Identifier")
      }
    }
  });
  const y = () => ({
    abstract: {
      validate: (0, s.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, s.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, s.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, s.chain)(function() {
        const T = (0, s.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), S = (0, s.assertNodeType)("Expression");
        return function(b, v, $) {
          (b.computed ? S : T)(b, v, $);
        };
      }(), (0, s.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  });
  core.classMethodOrPropertyCommon = y;
  const g = () => Object.assign({}, a(), y(), {
    params: {
      validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
    },
    kind: {
      validate: (0, s.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, s.chain)((0, s.assertValueType)("string"), (0, s.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))),
      optional: !0
    }
  });
  return core.classMethodOrDeclareMethodCommon = g, i("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, g(), o(), {
      body: {
        validate: (0, s.assertNodeType)("BlockStatement")
      }
    })
  }), i("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, f(), {
      properties: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("RestElement", "ObjectProperty")))
      }
    })
  }), i("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, s.assertNodeType)("Expression")
      }
    }
  }), i("Super", {
    aliases: ["Expression"]
  }), i("TaggedTemplateExpression", {
    visitor: ["tag", "quasi", "typeParameters"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, s.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, s.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, s.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  }), i("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, s.chain)((0, s.assertShape)({
          raw: {
            validate: (0, s.assertValueType)("string")
          },
          cooked: {
            validate: (0, s.assertValueType)("string"),
            optional: !0
          }
        }), function(S) {
          const b = S.value.raw;
          let v = !1;
          const $ = () => {
            throw new Error("Internal @babel/types error.");
          }, {
            str: U,
            firstInvalidLoc: X
          } = (0, e.readStringContents)("template", b, 0, 0, 0, {
            unterminated() {
              v = !0;
            },
            strictNumericEscape: $,
            invalidEscapeSequence: $,
            numericSeparatorInEscapeSequence: $,
            unexpectedNumericSeparator: $,
            invalidDigit: $,
            invalidCodePoint: $
          });
          if (!v)
            throw new Error("Invalid raw");
          S.value.cooked = X ? null : U;
        })
      },
      tail: {
        default: !1
      }
    }
  }), i("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("TemplateElement")))
      },
      expressions: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Expression", "TSType")), function(T, S, b) {
          if (T.quasis.length !== b.length + 1)
            throw new TypeError(`Number of ${T.type} quasis should be exactly one more than the number of expressions.
Expected ${b.length + 1} quasis but got ${T.quasis.length}`);
        })
      }
    }
  }), i("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: (0, s.chain)((0, s.assertValueType)("boolean"), Object.assign(function(T, S, b) {
        }, {
          type: "boolean"
        })),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, s.assertNodeType)("Expression")
      }
    }
  }), i("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, s.assertNodeType)("Expression")
      }
    }
  }), i("Import", {
    aliases: ["Expression"]
  }), i("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, s.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), i("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, s.assertNodeType)("Identifier")
      }
    }
  }), i("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, s.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          const T = (0, s.assertNodeType)("Identifier"), S = (0, s.assertNodeType)("Expression");
          return Object.assign(function(v, $, U) {
            (v.computed ? S : T)(v, $, U);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: (0, s.assertValueType)("boolean")
      }
    }
  }), i("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: (0, s.assertNodeType)("Expression")
      },
      arguments: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      },
      optional: {
        validate: (0, s.assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, s.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      },
      typeParameters: {
        validate: (0, s.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  }), i("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, y(), {
      value: {
        validate: (0, s.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, s.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, s.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, s.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, s.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, s.assertNodeType)("Variance"),
        optional: !0
      }
    })
  }), i("ClassAccessorProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"],
    fields: Object.assign({}, y(), {
      key: {
        validate: (0, s.chain)(function() {
          const T = (0, s.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), S = (0, s.assertNodeType)("Expression");
          return function(b, v, $) {
            (b.computed ? S : T)(b, v, $);
          };
        }(), (0, s.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, s.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, s.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, s.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))),
        optional: !0
      },
      readonly: {
        validate: (0, s.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, s.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, s.assertNodeType)("Variance"),
        optional: !0
      }
    })
  }), i("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators", "typeAnnotation"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, s.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, s.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, s.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Decorator"))),
        optional: !0
      },
      static: {
        validate: (0, s.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, s.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, s.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, s.assertNodeType)("Variance"),
        optional: !0
      }
    }
  }), i("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, g(), o(), {
      kind: {
        validate: (0, s.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, s.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, s.assertNodeType)("BlockStatement")
      }
    })
  }), i("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, s.assertNodeType)("Identifier")
      }
    }
  }), i("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, s.chain)((0, s.assertValueType)("array"), (0, s.assertEach)((0, s.assertNodeType)("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  }), core;
}
var flow$2 = {}, hasRequiredFlow;
function requireFlow() {
  if (hasRequiredFlow)
    return flow$2;
  hasRequiredFlow = 1;
  var e = requireUtils();
  const t = (0, e.defineAliasedType)("Flow"), s = (i) => {
    const a = i === "DeclareClass";
    t(i, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...a ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, e.validateType)("Identifier"),
        typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, e.validateOptional)((0, e.arrayOfType)("InterfaceExtends"))
      }, a ? {
        mixins: (0, e.validateOptional)((0, e.arrayOfType)("InterfaceExtends")),
        implements: (0, e.validateOptional)((0, e.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, e.validateType)("ObjectTypeAnnotation")
      })
    });
  };
  return t("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, e.validateType)("FlowType")
    }
  }), t("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TypeParameterInstantiation")
    }
  }), s("DeclareClass"), t("DeclareFunction", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      predicate: (0, e.validateOptionalType)("DeclaredPredicate")
    }
  }), s("DeclareInterface"), t("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)(["Identifier", "StringLiteral"]),
      body: (0, e.validateType)("BlockStatement"),
      kind: (0, e.validateOptional)((0, e.assertOneOf)("CommonJS", "ES"))
    }
  }), t("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, e.validateType)("TypeAnnotation")
    }
  }), t("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, e.validateType)("FlowType")
    }
  }), t("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, e.validateOptionalType)("FlowType"),
      impltype: (0, e.validateOptionalType)("FlowType")
    }
  }), t("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier")
    }
  }), t("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: (0, e.validateOptionalType)("Flow"),
      specifiers: (0, e.validateOptional)((0, e.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: (0, e.validateOptionalType)("StringLiteral"),
      default: (0, e.validateOptional)((0, e.assertValueType)("boolean"))
    }
  }), t("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: (0, e.validateType)("StringLiteral"),
      exportKind: (0, e.validateOptional)((0, e.assertOneOf)("type", "value"))
    }
  }), t("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, e.validateType)("Flow")
    }
  }), t("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  }), t("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, e.validate)((0, e.arrayOfType)("FunctionTypeParam")),
      rest: (0, e.validateOptionalType)("FunctionTypeParam"),
      this: (0, e.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, e.validateType)("FlowType")
    }
  }), t("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, e.validateOptionalType)("Identifier"),
      typeAnnotation: (0, e.validateType)("FlowType"),
      optional: (0, e.validateOptional)((0, e.assertValueType)("boolean"))
    }
  }), t("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, e.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, e.validateOptionalType)("TypeParameterInstantiation")
    }
  }), t("InferredPredicate", {
    aliases: ["FlowPredicate"]
  }), t("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, e.validateType)(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: (0, e.validateOptionalType)("TypeParameterInstantiation")
    }
  }), s("InterfaceDeclaration"), t("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, e.validateOptional)((0, e.arrayOfType)("InterfaceExtends")),
      body: (0, e.validateType)("ObjectTypeAnnotation")
    }
  }), t("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, e.validate)((0, e.arrayOfType)("FlowType"))
    }
  }), t("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, e.validateType)("FlowType")
    }
  }), t("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, e.validate)((0, e.assertValueType)("number"))
    }
  }), t("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, e.validate)((0, e.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: {
        validate: (0, e.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, e.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, e.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, e.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, e.validateOptional)((0, e.assertValueType)("boolean"))
    }
  }), t("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      value: (0, e.validateType)("FlowType"),
      optional: (0, e.validate)((0, e.assertValueType)("boolean")),
      static: (0, e.validate)((0, e.assertValueType)("boolean")),
      method: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, e.validateType)("FlowType"),
      static: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, e.validateOptionalType)("Identifier"),
      key: (0, e.validateType)("FlowType"),
      value: (0, e.validateType)("FlowType"),
      static: (0, e.validate)((0, e.assertValueType)("boolean")),
      variance: (0, e.validateOptionalType)("Variance")
    }
  }), t("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, e.validateType)(["Identifier", "StringLiteral"]),
      value: (0, e.validateType)("FlowType"),
      kind: (0, e.validate)((0, e.assertOneOf)("init", "get", "set")),
      static: (0, e.validate)((0, e.assertValueType)("boolean")),
      proto: (0, e.validate)((0, e.assertValueType)("boolean")),
      optional: (0, e.validate)((0, e.assertValueType)("boolean")),
      variance: (0, e.validateOptionalType)("Variance"),
      method: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, e.validateType)("FlowType")
    }
  }), t("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, e.validateOptionalType)("FlowType"),
      impltype: (0, e.validateType)("FlowType")
    }
  }), t("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      qualification: (0, e.validateType)(["Identifier", "QualifiedTypeIdentifier"])
    }
  }), t("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, e.validate)((0, e.assertValueType)("string"))
    }
  }), t("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, e.validate)((0, e.arrayOfType)("FlowType"))
    }
  }), t("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, e.validateType)("FlowType")
    }
  }), t("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, e.validateType)("FlowType")
    }
  }), t("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, e.validateType)("FlowType")
    }
  }), t("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, e.validateType)("Expression"),
      typeAnnotation: (0, e.validateType)("TypeAnnotation")
    }
  }), t("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, e.validate)((0, e.assertValueType)("string")),
      bound: (0, e.validateOptionalType)("TypeAnnotation"),
      default: (0, e.validateOptionalType)("FlowType"),
      variance: (0, e.validateOptionalType)("Variance")
    }
  }), t("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, e.validate)((0, e.arrayOfType)("TypeParameter"))
    }
  }), t("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, e.validate)((0, e.arrayOfType)("FlowType"))
    }
  }), t("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, e.validate)((0, e.arrayOfType)("FlowType"))
    }
  }), t("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, e.validate)((0, e.assertOneOf)("minus", "plus"))
    }
  }), t("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  }), t("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      body: (0, e.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  }), t("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, e.validate)((0, e.assertValueType)("boolean")),
      members: (0, e.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, e.validate)((0, e.assertValueType)("boolean")),
      members: (0, e.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, e.validate)((0, e.assertValueType)("boolean")),
      members: (0, e.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, e.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), t("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      init: (0, e.validateType)("BooleanLiteral")
    }
  }), t("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      init: (0, e.validateType)("NumericLiteral")
    }
  }), t("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, e.validateType)("Identifier"),
      init: (0, e.validateType)("StringLiteral")
    }
  }), t("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, e.validateType)("Identifier")
    }
  }), t("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, e.validateType)("FlowType"),
      indexType: (0, e.validateType)("FlowType")
    }
  }), t("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, e.validateType)("FlowType"),
      indexType: (0, e.validateType)("FlowType"),
      optional: (0, e.validate)((0, e.assertValueType)("boolean"))
    }
  }), flow$2;
}
var jsx$2 = {}, hasRequiredJsx;
function requireJsx() {
  if (hasRequiredJsx)
    return jsx$2;
  hasRequiredJsx = 1;
  var e = requireUtils();
  const t = (0, e.defineAliasedType)("JSX");
  return t("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, e.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, e.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  }), t("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, e.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  }), t("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, e.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, e.assertNodeType)("JSXClosingElement")
      },
      children: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }, {
      selfClosing: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      }
    })
  }), t("JSXEmptyExpression", {}), t("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, e.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  }), t("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, e.assertNodeType)("Expression")
      }
    }
  }), t("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, e.assertValueType)("string")
      }
    }
  }), t("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, e.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, e.assertNodeType)("JSXIdentifier")
      }
    }
  }), t("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, e.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, e.assertNodeType)("JSXIdentifier")
      }
    }
  }), t("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, e.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("JSXAttribute", "JSXSpreadAttribute")))
      },
      typeParameters: {
        validate: (0, e.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  }), t("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, e.assertNodeType)("Expression")
      }
    }
  }), t("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, e.assertValueType)("string")
      }
    }
  }), t("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, e.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, e.assertNodeType)("JSXClosingFragment")
      },
      children: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  }), t("JSXOpeningFragment", {
    aliases: ["Immutable"]
  }), t("JSXClosingFragment", {
    aliases: ["Immutable"]
  }), jsx$2;
}
var misc = {}, placeholders$1 = {}, hasRequiredPlaceholders;
function requirePlaceholders() {
  if (hasRequiredPlaceholders)
    return placeholders$1;
  hasRequiredPlaceholders = 1, Object.defineProperty(placeholders$1, "__esModule", {
    value: !0
  }), placeholders$1.PLACEHOLDERS_FLIPPED_ALIAS = placeholders$1.PLACEHOLDERS_ALIAS = placeholders$1.PLACEHOLDERS = void 0;
  var e = requireUtils();
  const t = placeholders$1.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"], s = placeholders$1.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (const a of t) {
    const o = e.ALIAS_KEYS[a];
    o != null && o.length && (s[a] = o);
  }
  const i = placeholders$1.PLACEHOLDERS_FLIPPED_ALIAS = {};
  return Object.keys(s).forEach((a) => {
    s[a].forEach((o) => {
      Object.hasOwnProperty.call(i, o) || (i[o] = []), i[o].push(a);
    });
  }), placeholders$1;
}
var hasRequiredMisc;
function requireMisc() {
  if (hasRequiredMisc)
    return misc;
  hasRequiredMisc = 1;
  var e = requireUtils(), t = requirePlaceholders();
  const s = (0, e.defineAliasedType)("Miscellaneous");
  return s("Noop", {
    visitor: []
  }), s("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: (0, e.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, e.assertOneOf)(...t.PLACEHOLDERS)
      }
    }
  }), s("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, e.assertValueType)("string")
      }
    }
  }), misc;
}
var experimental = {}, hasRequiredExperimental;
function requireExperimental() {
  if (hasRequiredExperimental)
    return experimental;
  hasRequiredExperimental = 1;
  var e = requireUtils();
  return (0, e.default)("ArgumentPlaceholder", {}), (0, e.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  }), (0, e.default)("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, e.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, e.assertNodeType)("StringLiteral")
      }
    }
  }), (0, e.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, e.assertNodeType)("Expression")
      }
    }
  }), (0, e.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, e.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, e.assertValueType)("boolean"),
        default: !1
      }
    }
  }), (0, e.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, e.assertNodeType)("Identifier")
      }
    }
  }), (0, e.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("ObjectProperty", "SpreadElement")))
      }
    }
  }), (0, e.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("Expression", "SpreadElement"))),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  }), (0, e.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, e.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  }), (0, e.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, e.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  }), (0, e.default)("TopicReference", {
    aliases: ["Expression"]
  }), (0, e.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, e.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  }), (0, e.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, e.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  }), (0, e.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  }), experimental;
}
var typescript$3 = {}, hasRequiredTypescript;
function requireTypescript() {
  if (hasRequiredTypescript)
    return typescript$3;
  hasRequiredTypescript = 1;
  var e = requireUtils(), t = requireCore(), s = requireIs();
  const i = (0, e.defineAliasedType)("TypeScript"), a = (0, e.assertValueType)("boolean"), o = () => ({
    returnType: {
      validate: (0, e.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, e.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  });
  i("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, e.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, e.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("Decorator"))),
        optional: !0
      }
    }
  }), i("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, t.functionDeclarationCommon)(), o())
  }), i("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, t.classMethodOrDeclareMethodCommon)(), o())
  }), i("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, e.validateType)("TSEntityName"),
      right: (0, e.validateType)("Identifier")
    }
  });
  const l = () => ({
    typeParameters: (0, e.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, e.validateArrayOfType)(["ArrayPattern", "Identifier", "ObjectPattern", "RestElement"]),
    typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation")
  }), f = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: l()
  };
  i("TSCallSignatureDeclaration", f), i("TSConstructSignatureDeclaration", f);
  const y = () => ({
    key: (0, e.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, e.validateOptional)(a)
  });
  i("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation", "initializer"],
    fields: Object.assign({}, y(), {
      readonly: (0, e.validateOptional)(a),
      typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation"),
      initializer: (0, e.validateOptionalType)("Expression"),
      kind: {
        validate: (0, e.assertOneOf)("get", "set")
      }
    })
  }), i("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, l(), y(), {
      kind: {
        validate: (0, e.assertOneOf)("method", "get", "set")
      }
    })
  }), i("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, e.validateOptional)(a),
      static: (0, e.validateOptional)(a),
      parameters: (0, e.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation")
    }
  });
  const g = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (const v of g)
    i(v, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  i("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  const T = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  i("TSFunctionType", Object.assign({}, T, {
    fields: l()
  })), i("TSConstructorType", Object.assign({}, T, {
    fields: Object.assign({}, l(), {
      abstract: (0, e.validateOptional)(a)
    })
  })), i("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, e.validateType)("TSEntityName"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), i("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, e.validateType)(["Identifier", "TSThisType"]),
      typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, e.validateOptional)(a)
    }
  }), i("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, e.validateType)(["TSEntityName", "TSImportType"]),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), i("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, e.validateArrayOfType)("TSTypeElement")
    }
  }), i("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, e.validateType)("TSType")
    }
  }), i("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, e.validateArrayOfType)(["TSType", "TSNamedTupleMember"])
    }
  }), i("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, e.validateType)("TSType")
    }
  }), i("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, e.validateType)("TSType")
    }
  }), i("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, e.validateType)("Identifier"),
      optional: {
        validate: a,
        default: !1
      },
      elementType: (0, e.validateType)("TSType")
    }
  });
  const S = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, e.validateArrayOfType)("TSType")
    }
  };
  i("TSUnionType", S), i("TSIntersectionType", S), i("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, e.validateType)("TSType"),
      extendsType: (0, e.validateType)("TSType"),
      trueType: (0, e.validateType)("TSType"),
      falseType: (0, e.validateType)("TSType")
    }
  }), i("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, e.validateType)("TSTypeParameter")
    }
  }), i("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, e.validateType)("TSType")
    }
  }), i("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: (0, e.validate)((0, e.assertValueType)("string")),
      typeAnnotation: (0, e.validateType)("TSType")
    }
  }), i("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, e.validateType)("TSType"),
      indexType: (0, e.validateType)("TSType")
    }
  }), i("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: (0, e.validateOptional)((0, e.assertOneOf)(!0, !1, "+", "-")),
      typeParameter: (0, e.validateType)("TSTypeParameter"),
      optional: (0, e.validateOptional)((0, e.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, e.validateOptionalType)("TSType"),
      nameType: (0, e.validateOptionalType)("TSType")
    }
  }), i("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          const v = (0, e.assertNodeType)("NumericLiteral", "BigIntLiteral"), $ = (0, e.assertOneOf)("-"), U = (0, e.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function X(k, D, B) {
            (0, s.default)("UnaryExpression", B) ? ($(B, "operator", B.operator), v(B, "argument", B.argument)) : U(k, D, B);
          }
          return X.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], X;
        }()
      }
    }
  }), i("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, e.validateType)("TSEntityName"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), i("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, e.validateOptional)(a),
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, e.validateOptional)((0, e.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, e.validateType)("TSInterfaceBody")
    }
  }), i("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, e.validateArrayOfType)("TSTypeElement")
    }
  }), i("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, e.validateOptional)(a),
      id: (0, e.validateType)("Identifier"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, e.validateType)("TSType")
    }
  }), i("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, e.validateType)("Expression"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  const b = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, e.validateType)("Expression"),
      typeAnnotation: (0, e.validateType)("TSType")
    }
  };
  return i("TSAsExpression", b), i("TSSatisfiesExpression", b), i("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, e.validateType)("TSType"),
      expression: (0, e.validateType)("Expression")
    }
  }), i("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, e.validateOptional)(a),
      const: (0, e.validateOptional)(a),
      id: (0, e.validateType)("Identifier"),
      members: (0, e.validateArrayOfType)("TSEnumMember"),
      initializer: (0, e.validateOptionalType)("Expression")
    }
  }), i("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, e.validateType)(["Identifier", "StringLiteral"]),
      initializer: (0, e.validateOptionalType)("Expression")
    }
  }), i("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: (0, e.validateOptional)(a),
      global: (0, e.validateOptional)(a),
      id: (0, e.validateType)(["Identifier", "StringLiteral"]),
      body: (0, e.validateType)(["TSModuleBlock", "TSModuleDeclaration"])
    }
  }), i("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, e.validateArrayOfType)("Statement")
    }
  }), i("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: (0, e.validateType)("StringLiteral"),
      qualifier: (0, e.validateOptionalType)("TSEntityName"),
      typeParameters: (0, e.validateOptionalType)("TSTypeParameterInstantiation")
    }
  }), i("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: (0, e.validate)(a),
      id: (0, e.validateType)("Identifier"),
      moduleReference: (0, e.validateType)(["TSEntityName", "TSExternalModuleReference"]),
      importKind: {
        validate: (0, e.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  }), i("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, e.validateType)("StringLiteral")
    }
  }), i("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, e.validateType)("Expression")
    }
  }), i("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, e.validateType)("Expression")
    }
  }), i("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, e.validateType)("Identifier")
    }
  }), i("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, e.assertNodeType)("TSType")
      }
    }
  }), i("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("TSType")))
      }
    }
  }), i("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: (0, e.chain)((0, e.assertValueType)("array"), (0, e.assertEach)((0, e.assertNodeType)("TSTypeParameter")))
      }
    }
  }), i("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, e.assertValueType)("string")
      },
      in: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, e.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, e.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, e.assertNodeType)("TSType"),
        optional: !0
      }
    }
  }), typescript$3;
}
var deprecatedAliases = {};
Object.defineProperty(deprecatedAliases, "__esModule", {
  value: !0
});
deprecatedAliases.DEPRECATED_ALIASES = void 0;
deprecatedAliases.DEPRECATED_ALIASES = {
  ModuleDeclaration: "ImportOrExportDeclaration"
};
var hasRequiredDefinitions;
function requireDefinitions() {
  return hasRequiredDefinitions || (hasRequiredDefinitions = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "ALIAS_KEYS", {
      enumerable: !0,
      get: function() {
        return s.ALIAS_KEYS;
      }
    }), Object.defineProperty(e, "BUILDER_KEYS", {
      enumerable: !0,
      get: function() {
        return s.BUILDER_KEYS;
      }
    }), Object.defineProperty(e, "DEPRECATED_ALIASES", {
      enumerable: !0,
      get: function() {
        return a.DEPRECATED_ALIASES;
      }
    }), Object.defineProperty(e, "DEPRECATED_KEYS", {
      enumerable: !0,
      get: function() {
        return s.DEPRECATED_KEYS;
      }
    }), Object.defineProperty(e, "FLIPPED_ALIAS_KEYS", {
      enumerable: !0,
      get: function() {
        return s.FLIPPED_ALIAS_KEYS;
      }
    }), Object.defineProperty(e, "NODE_FIELDS", {
      enumerable: !0,
      get: function() {
        return s.NODE_FIELDS;
      }
    }), Object.defineProperty(e, "NODE_PARENT_VALIDATIONS", {
      enumerable: !0,
      get: function() {
        return s.NODE_PARENT_VALIDATIONS;
      }
    }), Object.defineProperty(e, "PLACEHOLDERS", {
      enumerable: !0,
      get: function() {
        return i.PLACEHOLDERS;
      }
    }), Object.defineProperty(e, "PLACEHOLDERS_ALIAS", {
      enumerable: !0,
      get: function() {
        return i.PLACEHOLDERS_ALIAS;
      }
    }), Object.defineProperty(e, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: !0,
      get: function() {
        return i.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    }), e.TYPES = void 0, Object.defineProperty(e, "VISITOR_KEYS", {
      enumerable: !0,
      get: function() {
        return s.VISITOR_KEYS;
      }
    });
    var t = toFastProperties;
    requireCore(), requireFlow(), requireJsx(), requireMisc(), requireExperimental(), requireTypescript();
    var s = requireUtils(), i = requirePlaceholders(), a = deprecatedAliases;
    Object.keys(a.DEPRECATED_ALIASES).forEach((o) => {
      s.FLIPPED_ALIAS_KEYS[o] = s.FLIPPED_ALIAS_KEYS[a.DEPRECATED_ALIASES[o]];
    }), t(s.VISITOR_KEYS), t(s.ALIAS_KEYS), t(s.FLIPPED_ALIAS_KEYS), t(s.NODE_FIELDS), t(s.BUILDER_KEYS), t(s.DEPRECATED_KEYS), t(i.PLACEHOLDERS_ALIAS), t(i.PLACEHOLDERS_FLIPPED_ALIAS), e.TYPES = [].concat(Object.keys(s.VISITOR_KEYS), Object.keys(s.FLIPPED_ALIAS_KEYS), Object.keys(s.DEPRECATED_KEYS));
  }(definitions)), definitions;
}
var hasRequiredValidate;
function requireValidate() {
  if (hasRequiredValidate)
    return validate$2;
  hasRequiredValidate = 1, Object.defineProperty(validate$2, "__esModule", {
    value: !0
  }), validate$2.default = t, validate$2.validateChild = i, validate$2.validateField = s;
  var e = requireDefinitions();
  function t(a, o, l) {
    if (!a)
      return;
    const f = e.NODE_FIELDS[a.type];
    if (!f)
      return;
    const y = f[o];
    s(a, o, l, y), i(a, o, l);
  }
  function s(a, o, l, f) {
    f != null && f.validate && (f.optional && l == null || f.validate(a, o, l));
  }
  function i(a, o, l) {
    if (l == null)
      return;
    const f = e.NODE_PARENT_VALIDATIONS[l.type];
    f && f(a, o, l);
  }
  return validate$2;
}
var hasRequiredValidateNode;
function requireValidateNode() {
  if (hasRequiredValidateNode)
    return validateNode;
  hasRequiredValidateNode = 1, Object.defineProperty(validateNode, "__esModule", {
    value: !0
  }), validateNode.default = s;
  var e = requireValidate(), t = requireLib$1();
  function s(i) {
    const a = t.BUILDER_KEYS[i.type];
    for (const o of a)
      (0, e.default)(i, o, i[o]);
    return i;
  }
  return validateNode;
}
var hasRequiredGenerated;
function requireGenerated() {
  if (hasRequiredGenerated)
    return generated$2;
  hasRequiredGenerated = 1, Object.defineProperty(generated$2, "__esModule", {
    value: !0
  }), generated$2.anyTypeAnnotation = it, generated$2.argumentPlaceholder = Dr, generated$2.arrayExpression = s, generated$2.arrayPattern = Se, generated$2.arrayTypeAnnotation = nt, generated$2.arrowFunctionExpression = Ie, generated$2.assignmentExpression = i, generated$2.assignmentPattern = he, generated$2.awaitExpression = We, generated$2.bigIntLiteral = Xe, generated$2.binaryExpression = a, generated$2.bindExpression = Lr, generated$2.blockStatement = y, generated$2.booleanLiteral = be, generated$2.booleanLiteralTypeAnnotation = ot, generated$2.booleanTypeAnnotation = at, generated$2.breakStatement = g, generated$2.callExpression = T, generated$2.catchClause = S, generated$2.classAccessorProperty = Qe, generated$2.classBody = J, generated$2.classDeclaration = N, generated$2.classExpression = A, generated$2.classImplements = ut, generated$2.classMethod = Re, generated$2.classPrivateMethod = et, generated$2.classPrivateProperty = Ze, generated$2.classProperty = ze, generated$2.conditionalExpression = b, generated$2.continueStatement = v, generated$2.debuggerStatement = $, generated$2.decimalLiteral = Vr, generated$2.declareClass = ct, generated$2.declareExportAllDeclaration = St, generated$2.declareExportDeclaration = gt, generated$2.declareFunction = pt, generated$2.declareInterface = ft, generated$2.declareModule = dt, generated$2.declareModuleExports = ht, generated$2.declareOpaqueType = yt, generated$2.declareTypeAlias = mt, generated$2.declareVariable = Tt, generated$2.declaredPredicate = Et, generated$2.decorator = Fr, generated$2.directive = l, generated$2.directiveLiteral = f, generated$2.doExpression = Br, generated$2.doWhileStatement = U, generated$2.emptyStatement = X, generated$2.emptyTypeAnnotation = Nt, generated$2.enumBooleanBody = ar, generated$2.enumBooleanMember = cr, generated$2.enumDeclaration = nr, generated$2.enumDefaultedMember = dr, generated$2.enumNumberBody = or, generated$2.enumNumberMember = pr, generated$2.enumStringBody = lr, generated$2.enumStringMember = fr, generated$2.enumSymbolBody = ur, generated$2.existsTypeAnnotation = bt, generated$2.exportAllDeclaration = Y, generated$2.exportDefaultDeclaration = ne, generated$2.exportDefaultSpecifier = jr, generated$2.exportNamedDeclaration = de, generated$2.exportNamespaceSpecifier = He, generated$2.exportSpecifier = Ae, generated$2.expressionStatement = k, generated$2.file = D, generated$2.forInStatement = B, generated$2.forOfStatement = Ne, generated$2.forStatement = Z, generated$2.functionDeclaration = H, generated$2.functionExpression = q, generated$2.functionTypeAnnotation = xt, generated$2.functionTypeParam = Pt, generated$2.genericTypeAnnotation = At, generated$2.identifier = _, generated$2.ifStatement = j, generated$2.import = Je, generated$2.importAttribute = Mr, generated$2.importDeclaration = ke, generated$2.importDefaultSpecifier = Le, generated$2.importExpression = ae, generated$2.importNamespaceSpecifier = Me, generated$2.importSpecifier = De, generated$2.indexedAccessType = hr, generated$2.inferredPredicate = vt, generated$2.interfaceDeclaration = It, generated$2.interfaceExtends = Ct, generated$2.interfaceTypeAnnotation = wt, generated$2.interpreterDirective = o, generated$2.intersectionTypeAnnotation = $t, generated$2.jSXAttribute = generated$2.jsxAttribute = yr, generated$2.jSXClosingElement = generated$2.jsxClosingElement = Tr, generated$2.jSXClosingFragment = generated$2.jsxClosingFragment = _r, generated$2.jSXElement = generated$2.jsxElement = gr, generated$2.jSXEmptyExpression = generated$2.jsxEmptyExpression = Sr, generated$2.jSXExpressionContainer = generated$2.jsxExpressionContainer = Er, generated$2.jSXFragment = generated$2.jsxFragment = wr, generated$2.jSXIdentifier = generated$2.jsxIdentifier = xr, generated$2.jSXMemberExpression = generated$2.jsxMemberExpression = Pr, generated$2.jSXNamespacedName = generated$2.jsxNamespacedName = Ar, generated$2.jSXOpeningElement = generated$2.jsxOpeningElement = vr, generated$2.jSXOpeningFragment = generated$2.jsxOpeningFragment = $r, generated$2.jSXSpreadAttribute = generated$2.jsxSpreadAttribute = Cr, generated$2.jSXSpreadChild = generated$2.jsxSpreadChild = br, generated$2.jSXText = generated$2.jsxText = Ir, generated$2.labeledStatement = V, generated$2.logicalExpression = F, generated$2.memberExpression = R, generated$2.metaProperty = je, generated$2.mixedTypeAnnotation = Ot, generated$2.moduleExpression = Ur, generated$2.newExpression = K, generated$2.noop = Or, generated$2.nullLiteral = se, generated$2.nullLiteralTypeAnnotation = lt, generated$2.nullableTypeAnnotation = kt, generated$2.numberLiteral = oi, generated$2.numberLiteralTypeAnnotation = Dt, generated$2.numberTypeAnnotation = Lt, generated$2.numericLiteral = ee, generated$2.objectExpression = re, generated$2.objectMethod = ie, generated$2.objectPattern = qe, generated$2.objectProperty = fe, generated$2.objectTypeAnnotation = Mt, generated$2.objectTypeCallProperty = Bt, generated$2.objectTypeIndexer = jt, generated$2.objectTypeInternalSlot = Ft, generated$2.objectTypeProperty = Rt, generated$2.objectTypeSpreadProperty = qt, generated$2.opaqueType = Vt, generated$2.optionalCallExpression = Ge, generated$2.optionalIndexedAccessType = mr, generated$2.optionalMemberExpression = Ye, generated$2.parenthesizedExpression = _e, generated$2.pipelineBareFunction = Jr, generated$2.pipelinePrimaryTopicReference = Xr, generated$2.pipelineTopicExpression = Wr, generated$2.placeholder = Nr, generated$2.privateName = rt, generated$2.program = z, generated$2.qualifiedTypeIdentifier = Ut, generated$2.recordExpression = Rr, generated$2.regExpLiteral = ve, generated$2.regexLiteral = li, generated$2.restElement = ce, generated$2.restProperty = ui, generated$2.returnStatement = Pe, generated$2.sequenceExpression = Ce, generated$2.spreadElement = Ve, generated$2.spreadProperty = ci, generated$2.staticBlock = st, generated$2.stringLiteral = ue, generated$2.stringLiteralTypeAnnotation = Kt, generated$2.stringTypeAnnotation = Wt, generated$2.super = Ue, generated$2.switchCase = ge, generated$2.switchStatement = xe, generated$2.symbolTypeAnnotation = Jt, generated$2.taggedTemplateExpression = C, generated$2.templateElement = Ee, generated$2.templateLiteral = $e, generated$2.thisExpression = we, generated$2.thisTypeAnnotation = Xt, generated$2.throwStatement = G, generated$2.topicReference = Kr, generated$2.tryStatement = W, generated$2.tSAnyKeyword = generated$2.tsAnyKeyword = ss, generated$2.tSArrayType = generated$2.tsArrayType = vs, generated$2.tSAsExpression = generated$2.tsAsExpression = Ks, generated$2.tSBigIntKeyword = generated$2.tsBigIntKeyword = as, generated$2.tSBooleanKeyword = generated$2.tsBooleanKeyword = ns, generated$2.tSCallSignatureDeclaration = generated$2.tsCallSignatureDeclaration = Qr, generated$2.tSConditionalType = generated$2.tsConditionalType = Ns, generated$2.tSConstructSignatureDeclaration = generated$2.tsConstructSignatureDeclaration = Zr, generated$2.tSConstructorType = generated$2.tsConstructorType = Es, generated$2.tSDeclareFunction = generated$2.tsDeclareFunction = Yr, generated$2.tSDeclareMethod = generated$2.tsDeclareMethod = Gr, generated$2.tSEnumDeclaration = generated$2.tsEnumDeclaration = Xs, generated$2.tSEnumMember = generated$2.tsEnumMember = Hs, generated$2.tSExportAssignment = generated$2.tsExportAssignment = ti, generated$2.tSExpressionWithTypeArguments = generated$2.tsExpressionWithTypeArguments = js, generated$2.tSExternalModuleReference = generated$2.tsExternalModuleReference = Zs, generated$2.tSFunctionType = generated$2.tsFunctionType = Ss, generated$2.tSImportEqualsDeclaration = generated$2.tsImportEqualsDeclaration = Qs, generated$2.tSImportType = generated$2.tsImportType = zs, generated$2.tSIndexSignature = generated$2.tsIndexSignature = rs, generated$2.tSIndexedAccessType = generated$2.tsIndexedAccessType = Ms, generated$2.tSInferType = generated$2.tsInferType = ks, generated$2.tSInstantiationExpression = generated$2.tsInstantiationExpression = Us, generated$2.tSInterfaceBody = generated$2.tsInterfaceBody = qs, generated$2.tSInterfaceDeclaration = generated$2.tsInterfaceDeclaration = Rs, generated$2.tSIntersectionType = generated$2.tsIntersectionType = Os, generated$2.tSIntrinsicKeyword = generated$2.tsIntrinsicKeyword = os, generated$2.tSLiteralType = generated$2.tsLiteralType = Bs, generated$2.tSMappedType = generated$2.tsMappedType = Fs, generated$2.tSMethodSignature = generated$2.tsMethodSignature = ts, generated$2.tSModuleBlock = generated$2.tsModuleBlock = Gs, generated$2.tSModuleDeclaration = generated$2.tsModuleDeclaration = Ys, generated$2.tSNamedTupleMember = generated$2.tsNamedTupleMember = $s, generated$2.tSNamespaceExportDeclaration = generated$2.tsNamespaceExportDeclaration = ri, generated$2.tSNeverKeyword = generated$2.tsNeverKeyword = ls, generated$2.tSNonNullExpression = generated$2.tsNonNullExpression = ei, generated$2.tSNullKeyword = generated$2.tsNullKeyword = us, generated$2.tSNumberKeyword = generated$2.tsNumberKeyword = cs, generated$2.tSObjectKeyword = generated$2.tsObjectKeyword = ps, generated$2.tSOptionalType = generated$2.tsOptionalType = Is, generated$2.tSParameterProperty = generated$2.tsParameterProperty = Hr, generated$2.tSParenthesizedType = generated$2.tsParenthesizedType = Ds, generated$2.tSPropertySignature = generated$2.tsPropertySignature = es, generated$2.tSQualifiedName = generated$2.tsQualifiedName = zr, generated$2.tSRestType = generated$2.tsRestType = ws, generated$2.tSSatisfiesExpression = generated$2.tsSatisfiesExpression = Ws, generated$2.tSStringKeyword = generated$2.tsStringKeyword = fs, generated$2.tSSymbolKeyword = generated$2.tsSymbolKeyword = ds, generated$2.tSThisType = generated$2.tsThisType = gs, generated$2.tSTupleType = generated$2.tsTupleType = Cs, generated$2.tSTypeAliasDeclaration = generated$2.tsTypeAliasDeclaration = Vs, generated$2.tSTypeAnnotation = generated$2.tsTypeAnnotation = si, generated$2.tSTypeAssertion = generated$2.tsTypeAssertion = Js, generated$2.tSTypeLiteral = generated$2.tsTypeLiteral = As, generated$2.tSTypeOperator = generated$2.tsTypeOperator = Ls, generated$2.tSTypeParameter = generated$2.tsTypeParameter = ai, generated$2.tSTypeParameterDeclaration = generated$2.tsTypeParameterDeclaration = ni, generated$2.tSTypeParameterInstantiation = generated$2.tsTypeParameterInstantiation = ii, generated$2.tSTypePredicate = generated$2.tsTypePredicate = xs, generated$2.tSTypeQuery = generated$2.tsTypeQuery = Ps, generated$2.tSTypeReference = generated$2.tsTypeReference = bs, generated$2.tSUndefinedKeyword = generated$2.tsUndefinedKeyword = hs, generated$2.tSUnionType = generated$2.tsUnionType = _s, generated$2.tSUnknownKeyword = generated$2.tsUnknownKeyword = ys, generated$2.tSVoidKeyword = generated$2.tsVoidKeyword = Ts, generated$2.tupleExpression = qr, generated$2.tupleTypeAnnotation = Ht, generated$2.typeAlias = Gt, generated$2.typeAnnotation = zt, generated$2.typeCastExpression = Qt, generated$2.typeParameter = Zt, generated$2.typeParameterDeclaration = er, generated$2.typeParameterInstantiation = tr, generated$2.typeofTypeAnnotation = Yt, generated$2.unaryExpression = te, generated$2.unionTypeAnnotation = rr, generated$2.updateExpression = oe, generated$2.v8IntrinsicIdentifier = kr, generated$2.variableDeclaration = me, generated$2.variableDeclarator = pe, generated$2.variance = sr, generated$2.voidTypeAnnotation = ir, generated$2.whileStatement = ye, generated$2.withStatement = le, generated$2.yieldExpression = Fe;
  var e = requireValidateNode(), t = deprecationWarning$2;
  function s(E = []) {
    return (0, e.default)({
      type: "ArrayExpression",
      elements: E
    });
  }
  function i(E, w, Q) {
    return (0, e.default)({
      type: "AssignmentExpression",
      operator: E,
      left: w,
      right: Q
    });
  }
  function a(E, w, Q) {
    return (0, e.default)({
      type: "BinaryExpression",
      operator: E,
      left: w,
      right: Q
    });
  }
  function o(E) {
    return (0, e.default)({
      type: "InterpreterDirective",
      value: E
    });
  }
  function l(E) {
    return (0, e.default)({
      type: "Directive",
      value: E
    });
  }
  function f(E) {
    return (0, e.default)({
      type: "DirectiveLiteral",
      value: E
    });
  }
  function y(E, w = []) {
    return (0, e.default)({
      type: "BlockStatement",
      body: E,
      directives: w
    });
  }
  function g(E = null) {
    return (0, e.default)({
      type: "BreakStatement",
      label: E
    });
  }
  function T(E, w) {
    return (0, e.default)({
      type: "CallExpression",
      callee: E,
      arguments: w
    });
  }
  function S(E = null, w) {
    return (0, e.default)({
      type: "CatchClause",
      param: E,
      body: w
    });
  }
  function b(E, w, Q) {
    return (0, e.default)({
      type: "ConditionalExpression",
      test: E,
      consequent: w,
      alternate: Q
    });
  }
  function v(E = null) {
    return (0, e.default)({
      type: "ContinueStatement",
      label: E
    });
  }
  function $() {
    return {
      type: "DebuggerStatement"
    };
  }
  function U(E, w) {
    return (0, e.default)({
      type: "DoWhileStatement",
      test: E,
      body: w
    });
  }
  function X() {
    return {
      type: "EmptyStatement"
    };
  }
  function k(E) {
    return (0, e.default)({
      type: "ExpressionStatement",
      expression: E
    });
  }
  function D(E, w = null, Q = null) {
    return (0, e.default)({
      type: "File",
      program: E,
      comments: w,
      tokens: Q
    });
  }
  function B(E, w, Q) {
    return (0, e.default)({
      type: "ForInStatement",
      left: E,
      right: w,
      body: Q
    });
  }
  function Z(E = null, w = null, Q = null, Te) {
    return (0, e.default)({
      type: "ForStatement",
      init: E,
      test: w,
      update: Q,
      body: Te
    });
  }
  function H(E = null, w, Q, Te = !1, Oe = !1) {
    return (0, e.default)({
      type: "FunctionDeclaration",
      id: E,
      params: w,
      body: Q,
      generator: Te,
      async: Oe
    });
  }
  function q(E = null, w, Q, Te = !1, Oe = !1) {
    return (0, e.default)({
      type: "FunctionExpression",
      id: E,
      params: w,
      body: Q,
      generator: Te,
      async: Oe
    });
  }
  function _(E) {
    return (0, e.default)({
      type: "Identifier",
      name: E
    });
  }
  function j(E, w, Q = null) {
    return (0, e.default)({
      type: "IfStatement",
      test: E,
      consequent: w,
      alternate: Q
    });
  }
  function V(E, w) {
    return (0, e.default)({
      type: "LabeledStatement",
      label: E,
      body: w
    });
  }
  function ue(E) {
    return (0, e.default)({
      type: "StringLiteral",
      value: E
    });
  }
  function ee(E) {
    return (0, e.default)({
      type: "NumericLiteral",
      value: E
    });
  }
  function se() {
    return {
      type: "NullLiteral"
    };
  }
  function be(E) {
    return (0, e.default)({
      type: "BooleanLiteral",
      value: E
    });
  }
  function ve(E, w = "") {
    return (0, e.default)({
      type: "RegExpLiteral",
      pattern: E,
      flags: w
    });
  }
  function F(E, w, Q) {
    return (0, e.default)({
      type: "LogicalExpression",
      operator: E,
      left: w,
      right: Q
    });
  }
  function R(E, w, Q = !1, Te = null) {
    return (0, e.default)({
      type: "MemberExpression",
      object: E,
      property: w,
      computed: Q,
      optional: Te
    });
  }
  function K(E, w) {
    return (0, e.default)({
      type: "NewExpression",
      callee: E,
      arguments: w
    });
  }
  function z(E, w = [], Q = "script", Te = null) {
    return (0, e.default)({
      type: "Program",
      body: E,
      directives: w,
      sourceType: Q,
      interpreter: Te,
      sourceFile: null
    });
  }
  function re(E) {
    return (0, e.default)({
      type: "ObjectExpression",
      properties: E
    });
  }
  function ie(E = "method", w, Q, Te, Oe = !1, Be = !1, Ke = !1) {
    return (0, e.default)({
      type: "ObjectMethod",
      kind: E,
      key: w,
      params: Q,
      body: Te,
      computed: Oe,
      generator: Be,
      async: Ke
    });
  }
  function fe(E, w, Q = !1, Te = !1, Oe = null) {
    return (0, e.default)({
      type: "ObjectProperty",
      key: E,
      value: w,
      computed: Q,
      shorthand: Te,
      decorators: Oe
    });
  }
  function ce(E) {
    return (0, e.default)({
      type: "RestElement",
      argument: E
    });
  }
  function Pe(E = null) {
    return (0, e.default)({
      type: "ReturnStatement",
      argument: E
    });
  }
  function Ce(E) {
    return (0, e.default)({
      type: "SequenceExpression",
      expressions: E
    });
  }
  function _e(E) {
    return (0, e.default)({
      type: "ParenthesizedExpression",
      expression: E
    });
  }
  function ge(E = null, w) {
    return (0, e.default)({
      type: "SwitchCase",
      test: E,
      consequent: w
    });
  }
  function xe(E, w) {
    return (0, e.default)({
      type: "SwitchStatement",
      discriminant: E,
      cases: w
    });
  }
  function we() {
    return {
      type: "ThisExpression"
    };
  }
  function G(E) {
    return (0, e.default)({
      type: "ThrowStatement",
      argument: E
    });
  }
  function W(E, w = null, Q = null) {
    return (0, e.default)({
      type: "TryStatement",
      block: E,
      handler: w,
      finalizer: Q
    });
  }
  function te(E, w, Q = !0) {
    return (0, e.default)({
      type: "UnaryExpression",
      operator: E,
      argument: w,
      prefix: Q
    });
  }
  function oe(E, w, Q = !1) {
    return (0, e.default)({
      type: "UpdateExpression",
      operator: E,
      argument: w,
      prefix: Q
    });
  }
  function me(E, w) {
    return (0, e.default)({
      type: "VariableDeclaration",
      kind: E,
      declarations: w
    });
  }
  function pe(E, w = null) {
    return (0, e.default)({
      type: "VariableDeclarator",
      id: E,
      init: w
    });
  }
  function ye(E, w) {
    return (0, e.default)({
      type: "WhileStatement",
      test: E,
      body: w
    });
  }
  function le(E, w) {
    return (0, e.default)({
      type: "WithStatement",
      object: E,
      body: w
    });
  }
  function he(E, w) {
    return (0, e.default)({
      type: "AssignmentPattern",
      left: E,
      right: w
    });
  }
  function Se(E) {
    return (0, e.default)({
      type: "ArrayPattern",
      elements: E
    });
  }
  function Ie(E, w, Q = !1) {
    return (0, e.default)({
      type: "ArrowFunctionExpression",
      params: E,
      body: w,
      async: Q,
      expression: null
    });
  }
  function J(E) {
    return (0, e.default)({
      type: "ClassBody",
      body: E
    });
  }
  function A(E = null, w = null, Q, Te = null) {
    return (0, e.default)({
      type: "ClassExpression",
      id: E,
      superClass: w,
      body: Q,
      decorators: Te
    });
  }
  function N(E = null, w = null, Q, Te = null) {
    return (0, e.default)({
      type: "ClassDeclaration",
      id: E,
      superClass: w,
      body: Q,
      decorators: Te
    });
  }
  function Y(E) {
    return (0, e.default)({
      type: "ExportAllDeclaration",
      source: E
    });
  }
  function ne(E) {
    return (0, e.default)({
      type: "ExportDefaultDeclaration",
      declaration: E
    });
  }
  function de(E = null, w = [], Q = null) {
    return (0, e.default)({
      type: "ExportNamedDeclaration",
      declaration: E,
      specifiers: w,
      source: Q
    });
  }
  function Ae(E, w) {
    return (0, e.default)({
      type: "ExportSpecifier",
      local: E,
      exported: w
    });
  }
  function Ne(E, w, Q, Te = !1) {
    return (0, e.default)({
      type: "ForOfStatement",
      left: E,
      right: w,
      body: Q,
      await: Te
    });
  }
  function ke(E, w) {
    return (0, e.default)({
      type: "ImportDeclaration",
      specifiers: E,
      source: w
    });
  }
  function Le(E) {
    return (0, e.default)({
      type: "ImportDefaultSpecifier",
      local: E
    });
  }
  function Me(E) {
    return (0, e.default)({
      type: "ImportNamespaceSpecifier",
      local: E
    });
  }
  function De(E, w) {
    return (0, e.default)({
      type: "ImportSpecifier",
      local: E,
      imported: w
    });
  }
  function ae(E, w = null) {
    return (0, e.default)({
      type: "ImportExpression",
      source: E,
      options: w
    });
  }
  function je(E, w) {
    return (0, e.default)({
      type: "MetaProperty",
      meta: E,
      property: w
    });
  }
  function Re(E = "method", w, Q, Te, Oe = !1, Be = !1, Ke = !1, pi = !1) {
    return (0, e.default)({
      type: "ClassMethod",
      kind: E,
      key: w,
      params: Q,
      body: Te,
      computed: Oe,
      static: Be,
      generator: Ke,
      async: pi
    });
  }
  function qe(E) {
    return (0, e.default)({
      type: "ObjectPattern",
      properties: E
    });
  }
  function Ve(E) {
    return (0, e.default)({
      type: "SpreadElement",
      argument: E
    });
  }
  function Ue() {
    return {
      type: "Super"
    };
  }
  function C(E, w) {
    return (0, e.default)({
      type: "TaggedTemplateExpression",
      tag: E,
      quasi: w
    });
  }
  function Ee(E, w = !1) {
    return (0, e.default)({
      type: "TemplateElement",
      value: E,
      tail: w
    });
  }
  function $e(E, w) {
    return (0, e.default)({
      type: "TemplateLiteral",
      quasis: E,
      expressions: w
    });
  }
  function Fe(E = null, w = !1) {
    return (0, e.default)({
      type: "YieldExpression",
      argument: E,
      delegate: w
    });
  }
  function We(E) {
    return (0, e.default)({
      type: "AwaitExpression",
      argument: E
    });
  }
  function Je() {
    return {
      type: "Import"
    };
  }
  function Xe(E) {
    return (0, e.default)({
      type: "BigIntLiteral",
      value: E
    });
  }
  function He(E) {
    return (0, e.default)({
      type: "ExportNamespaceSpecifier",
      exported: E
    });
  }
  function Ye(E, w, Q = !1, Te) {
    return (0, e.default)({
      type: "OptionalMemberExpression",
      object: E,
      property: w,
      computed: Q,
      optional: Te
    });
  }
  function Ge(E, w, Q) {
    return (0, e.default)({
      type: "OptionalCallExpression",
      callee: E,
      arguments: w,
      optional: Q
    });
  }
  function ze(E, w = null, Q = null, Te = null, Oe = !1, Be = !1) {
    return (0, e.default)({
      type: "ClassProperty",
      key: E,
      value: w,
      typeAnnotation: Q,
      decorators: Te,
      computed: Oe,
      static: Be
    });
  }
  function Qe(E, w = null, Q = null, Te = null, Oe = !1, Be = !1) {
    return (0, e.default)({
      type: "ClassAccessorProperty",
      key: E,
      value: w,
      typeAnnotation: Q,
      decorators: Te,
      computed: Oe,
      static: Be
    });
  }
  function Ze(E, w = null, Q = null, Te = !1) {
    return (0, e.default)({
      type: "ClassPrivateProperty",
      key: E,
      value: w,
      decorators: Q,
      static: Te
    });
  }
  function et(E = "method", w, Q, Te, Oe = !1) {
    return (0, e.default)({
      type: "ClassPrivateMethod",
      kind: E,
      key: w,
      params: Q,
      body: Te,
      static: Oe
    });
  }
  function rt(E) {
    return (0, e.default)({
      type: "PrivateName",
      id: E
    });
  }
  function st(E) {
    return (0, e.default)({
      type: "StaticBlock",
      body: E
    });
  }
  function it() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  function nt(E) {
    return (0, e.default)({
      type: "ArrayTypeAnnotation",
      elementType: E
    });
  }
  function at() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  function ot(E) {
    return (0, e.default)({
      type: "BooleanLiteralTypeAnnotation",
      value: E
    });
  }
  function lt() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  function ut(E, w = null) {
    return (0, e.default)({
      type: "ClassImplements",
      id: E,
      typeParameters: w
    });
  }
  function ct(E, w = null, Q = null, Te) {
    return (0, e.default)({
      type: "DeclareClass",
      id: E,
      typeParameters: w,
      extends: Q,
      body: Te
    });
  }
  function pt(E) {
    return (0, e.default)({
      type: "DeclareFunction",
      id: E
    });
  }
  function ft(E, w = null, Q = null, Te) {
    return (0, e.default)({
      type: "DeclareInterface",
      id: E,
      typeParameters: w,
      extends: Q,
      body: Te
    });
  }
  function dt(E, w, Q = null) {
    return (0, e.default)({
      type: "DeclareModule",
      id: E,
      body: w,
      kind: Q
    });
  }
  function ht(E) {
    return (0, e.default)({
      type: "DeclareModuleExports",
      typeAnnotation: E
    });
  }
  function mt(E, w = null, Q) {
    return (0, e.default)({
      type: "DeclareTypeAlias",
      id: E,
      typeParameters: w,
      right: Q
    });
  }
  function yt(E, w = null, Q = null) {
    return (0, e.default)({
      type: "DeclareOpaqueType",
      id: E,
      typeParameters: w,
      supertype: Q
    });
  }
  function Tt(E) {
    return (0, e.default)({
      type: "DeclareVariable",
      id: E
    });
  }
  function gt(E = null, w = null, Q = null) {
    return (0, e.default)({
      type: "DeclareExportDeclaration",
      declaration: E,
      specifiers: w,
      source: Q
    });
  }
  function St(E) {
    return (0, e.default)({
      type: "DeclareExportAllDeclaration",
      source: E
    });
  }
  function Et(E) {
    return (0, e.default)({
      type: "DeclaredPredicate",
      value: E
    });
  }
  function bt() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  function xt(E = null, w, Q = null, Te) {
    return (0, e.default)({
      type: "FunctionTypeAnnotation",
      typeParameters: E,
      params: w,
      rest: Q,
      returnType: Te
    });
  }
  function Pt(E = null, w) {
    return (0, e.default)({
      type: "FunctionTypeParam",
      name: E,
      typeAnnotation: w
    });
  }
  function At(E, w = null) {
    return (0, e.default)({
      type: "GenericTypeAnnotation",
      id: E,
      typeParameters: w
    });
  }
  function vt() {
    return {
      type: "InferredPredicate"
    };
  }
  function Ct(E, w = null) {
    return (0, e.default)({
      type: "InterfaceExtends",
      id: E,
      typeParameters: w
    });
  }
  function It(E, w = null, Q = null, Te) {
    return (0, e.default)({
      type: "InterfaceDeclaration",
      id: E,
      typeParameters: w,
      extends: Q,
      body: Te
    });
  }
  function wt(E = null, w) {
    return (0, e.default)({
      type: "InterfaceTypeAnnotation",
      extends: E,
      body: w
    });
  }
  function $t(E) {
    return (0, e.default)({
      type: "IntersectionTypeAnnotation",
      types: E
    });
  }
  function Ot() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  function Nt() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  function kt(E) {
    return (0, e.default)({
      type: "NullableTypeAnnotation",
      typeAnnotation: E
    });
  }
  function Dt(E) {
    return (0, e.default)({
      type: "NumberLiteralTypeAnnotation",
      value: E
    });
  }
  function Lt() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  function Mt(E, w = [], Q = [], Te = [], Oe = !1) {
    return (0, e.default)({
      type: "ObjectTypeAnnotation",
      properties: E,
      indexers: w,
      callProperties: Q,
      internalSlots: Te,
      exact: Oe
    });
  }
  function Ft(E, w, Q, Te, Oe) {
    return (0, e.default)({
      type: "ObjectTypeInternalSlot",
      id: E,
      value: w,
      optional: Q,
      static: Te,
      method: Oe
    });
  }
  function Bt(E) {
    return (0, e.default)({
      type: "ObjectTypeCallProperty",
      value: E,
      static: null
    });
  }
  function jt(E = null, w, Q, Te = null) {
    return (0, e.default)({
      type: "ObjectTypeIndexer",
      id: E,
      key: w,
      value: Q,
      variance: Te,
      static: null
    });
  }
  function Rt(E, w, Q = null) {
    return (0, e.default)({
      type: "ObjectTypeProperty",
      key: E,
      value: w,
      variance: Q,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    });
  }
  function qt(E) {
    return (0, e.default)({
      type: "ObjectTypeSpreadProperty",
      argument: E
    });
  }
  function Vt(E, w = null, Q = null, Te) {
    return (0, e.default)({
      type: "OpaqueType",
      id: E,
      typeParameters: w,
      supertype: Q,
      impltype: Te
    });
  }
  function Ut(E, w) {
    return (0, e.default)({
      type: "QualifiedTypeIdentifier",
      id: E,
      qualification: w
    });
  }
  function Kt(E) {
    return (0, e.default)({
      type: "StringLiteralTypeAnnotation",
      value: E
    });
  }
  function Wt() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  function Jt() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  function Xt() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  function Ht(E) {
    return (0, e.default)({
      type: "TupleTypeAnnotation",
      types: E
    });
  }
  function Yt(E) {
    return (0, e.default)({
      type: "TypeofTypeAnnotation",
      argument: E
    });
  }
  function Gt(E, w = null, Q) {
    return (0, e.default)({
      type: "TypeAlias",
      id: E,
      typeParameters: w,
      right: Q
    });
  }
  function zt(E) {
    return (0, e.default)({
      type: "TypeAnnotation",
      typeAnnotation: E
    });
  }
  function Qt(E, w) {
    return (0, e.default)({
      type: "TypeCastExpression",
      expression: E,
      typeAnnotation: w
    });
  }
  function Zt(E = null, w = null, Q = null) {
    return (0, e.default)({
      type: "TypeParameter",
      bound: E,
      default: w,
      variance: Q,
      name: null
    });
  }
  function er(E) {
    return (0, e.default)({
      type: "TypeParameterDeclaration",
      params: E
    });
  }
  function tr(E) {
    return (0, e.default)({
      type: "TypeParameterInstantiation",
      params: E
    });
  }
  function rr(E) {
    return (0, e.default)({
      type: "UnionTypeAnnotation",
      types: E
    });
  }
  function sr(E) {
    return (0, e.default)({
      type: "Variance",
      kind: E
    });
  }
  function ir() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  function nr(E, w) {
    return (0, e.default)({
      type: "EnumDeclaration",
      id: E,
      body: w
    });
  }
  function ar(E) {
    return (0, e.default)({
      type: "EnumBooleanBody",
      members: E,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  function or(E) {
    return (0, e.default)({
      type: "EnumNumberBody",
      members: E,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  function lr(E) {
    return (0, e.default)({
      type: "EnumStringBody",
      members: E,
      explicitType: null,
      hasUnknownMembers: null
    });
  }
  function ur(E) {
    return (0, e.default)({
      type: "EnumSymbolBody",
      members: E,
      hasUnknownMembers: null
    });
  }
  function cr(E) {
    return (0, e.default)({
      type: "EnumBooleanMember",
      id: E,
      init: null
    });
  }
  function pr(E, w) {
    return (0, e.default)({
      type: "EnumNumberMember",
      id: E,
      init: w
    });
  }
  function fr(E, w) {
    return (0, e.default)({
      type: "EnumStringMember",
      id: E,
      init: w
    });
  }
  function dr(E) {
    return (0, e.default)({
      type: "EnumDefaultedMember",
      id: E
    });
  }
  function hr(E, w) {
    return (0, e.default)({
      type: "IndexedAccessType",
      objectType: E,
      indexType: w
    });
  }
  function mr(E, w) {
    return (0, e.default)({
      type: "OptionalIndexedAccessType",
      objectType: E,
      indexType: w,
      optional: null
    });
  }
  function yr(E, w = null) {
    return (0, e.default)({
      type: "JSXAttribute",
      name: E,
      value: w
    });
  }
  function Tr(E) {
    return (0, e.default)({
      type: "JSXClosingElement",
      name: E
    });
  }
  function gr(E, w = null, Q, Te = null) {
    return (0, e.default)({
      type: "JSXElement",
      openingElement: E,
      closingElement: w,
      children: Q,
      selfClosing: Te
    });
  }
  function Sr() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  function Er(E) {
    return (0, e.default)({
      type: "JSXExpressionContainer",
      expression: E
    });
  }
  function br(E) {
    return (0, e.default)({
      type: "JSXSpreadChild",
      expression: E
    });
  }
  function xr(E) {
    return (0, e.default)({
      type: "JSXIdentifier",
      name: E
    });
  }
  function Pr(E, w) {
    return (0, e.default)({
      type: "JSXMemberExpression",
      object: E,
      property: w
    });
  }
  function Ar(E, w) {
    return (0, e.default)({
      type: "JSXNamespacedName",
      namespace: E,
      name: w
    });
  }
  function vr(E, w, Q = !1) {
    return (0, e.default)({
      type: "JSXOpeningElement",
      name: E,
      attributes: w,
      selfClosing: Q
    });
  }
  function Cr(E) {
    return (0, e.default)({
      type: "JSXSpreadAttribute",
      argument: E
    });
  }
  function Ir(E) {
    return (0, e.default)({
      type: "JSXText",
      value: E
    });
  }
  function wr(E, w, Q) {
    return (0, e.default)({
      type: "JSXFragment",
      openingFragment: E,
      closingFragment: w,
      children: Q
    });
  }
  function $r() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  function _r() {
    return {
      type: "JSXClosingFragment"
    };
  }
  function Or() {
    return {
      type: "Noop"
    };
  }
  function Nr(E, w) {
    return (0, e.default)({
      type: "Placeholder",
      expectedNode: E,
      name: w
    });
  }
  function kr(E) {
    return (0, e.default)({
      type: "V8IntrinsicIdentifier",
      name: E
    });
  }
  function Dr() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  function Lr(E, w) {
    return (0, e.default)({
      type: "BindExpression",
      object: E,
      callee: w
    });
  }
  function Mr(E, w) {
    return (0, e.default)({
      type: "ImportAttribute",
      key: E,
      value: w
    });
  }
  function Fr(E) {
    return (0, e.default)({
      type: "Decorator",
      expression: E
    });
  }
  function Br(E, w = !1) {
    return (0, e.default)({
      type: "DoExpression",
      body: E,
      async: w
    });
  }
  function jr(E) {
    return (0, e.default)({
      type: "ExportDefaultSpecifier",
      exported: E
    });
  }
  function Rr(E) {
    return (0, e.default)({
      type: "RecordExpression",
      properties: E
    });
  }
  function qr(E = []) {
    return (0, e.default)({
      type: "TupleExpression",
      elements: E
    });
  }
  function Vr(E) {
    return (0, e.default)({
      type: "DecimalLiteral",
      value: E
    });
  }
  function Ur(E) {
    return (0, e.default)({
      type: "ModuleExpression",
      body: E
    });
  }
  function Kr() {
    return {
      type: "TopicReference"
    };
  }
  function Wr(E) {
    return (0, e.default)({
      type: "PipelineTopicExpression",
      expression: E
    });
  }
  function Jr(E) {
    return (0, e.default)({
      type: "PipelineBareFunction",
      callee: E
    });
  }
  function Xr() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  function Hr(E) {
    return (0, e.default)({
      type: "TSParameterProperty",
      parameter: E
    });
  }
  function Yr(E = null, w = null, Q, Te = null) {
    return (0, e.default)({
      type: "TSDeclareFunction",
      id: E,
      typeParameters: w,
      params: Q,
      returnType: Te
    });
  }
  function Gr(E = null, w, Q = null, Te, Oe = null) {
    return (0, e.default)({
      type: "TSDeclareMethod",
      decorators: E,
      key: w,
      typeParameters: Q,
      params: Te,
      returnType: Oe
    });
  }
  function zr(E, w) {
    return (0, e.default)({
      type: "TSQualifiedName",
      left: E,
      right: w
    });
  }
  function Qr(E = null, w, Q = null) {
    return (0, e.default)({
      type: "TSCallSignatureDeclaration",
      typeParameters: E,
      parameters: w,
      typeAnnotation: Q
    });
  }
  function Zr(E = null, w, Q = null) {
    return (0, e.default)({
      type: "TSConstructSignatureDeclaration",
      typeParameters: E,
      parameters: w,
      typeAnnotation: Q
    });
  }
  function es(E, w = null, Q = null) {
    return (0, e.default)({
      type: "TSPropertySignature",
      key: E,
      typeAnnotation: w,
      initializer: Q,
      kind: null
    });
  }
  function ts(E, w = null, Q, Te = null) {
    return (0, e.default)({
      type: "TSMethodSignature",
      key: E,
      typeParameters: w,
      parameters: Q,
      typeAnnotation: Te,
      kind: null
    });
  }
  function rs(E, w = null) {
    return (0, e.default)({
      type: "TSIndexSignature",
      parameters: E,
      typeAnnotation: w
    });
  }
  function ss() {
    return {
      type: "TSAnyKeyword"
    };
  }
  function ns() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  function as() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  function os() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  function ls() {
    return {
      type: "TSNeverKeyword"
    };
  }
  function us() {
    return {
      type: "TSNullKeyword"
    };
  }
  function cs() {
    return {
      type: "TSNumberKeyword"
    };
  }
  function ps() {
    return {
      type: "TSObjectKeyword"
    };
  }
  function fs() {
    return {
      type: "TSStringKeyword"
    };
  }
  function ds() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  function hs() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  function ys() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  function Ts() {
    return {
      type: "TSVoidKeyword"
    };
  }
  function gs() {
    return {
      type: "TSThisType"
    };
  }
  function Ss(E = null, w, Q = null) {
    return (0, e.default)({
      type: "TSFunctionType",
      typeParameters: E,
      parameters: w,
      typeAnnotation: Q
    });
  }
  function Es(E = null, w, Q = null) {
    return (0, e.default)({
      type: "TSConstructorType",
      typeParameters: E,
      parameters: w,
      typeAnnotation: Q
    });
  }
  function bs(E, w = null) {
    return (0, e.default)({
      type: "TSTypeReference",
      typeName: E,
      typeParameters: w
    });
  }
  function xs(E, w = null, Q = null) {
    return (0, e.default)({
      type: "TSTypePredicate",
      parameterName: E,
      typeAnnotation: w,
      asserts: Q
    });
  }
  function Ps(E, w = null) {
    return (0, e.default)({
      type: "TSTypeQuery",
      exprName: E,
      typeParameters: w
    });
  }
  function As(E) {
    return (0, e.default)({
      type: "TSTypeLiteral",
      members: E
    });
  }
  function vs(E) {
    return (0, e.default)({
      type: "TSArrayType",
      elementType: E
    });
  }
  function Cs(E) {
    return (0, e.default)({
      type: "TSTupleType",
      elementTypes: E
    });
  }
  function Is(E) {
    return (0, e.default)({
      type: "TSOptionalType",
      typeAnnotation: E
    });
  }
  function ws(E) {
    return (0, e.default)({
      type: "TSRestType",
      typeAnnotation: E
    });
  }
  function $s(E, w, Q = !1) {
    return (0, e.default)({
      type: "TSNamedTupleMember",
      label: E,
      elementType: w,
      optional: Q
    });
  }
  function _s(E) {
    return (0, e.default)({
      type: "TSUnionType",
      types: E
    });
  }
  function Os(E) {
    return (0, e.default)({
      type: "TSIntersectionType",
      types: E
    });
  }
  function Ns(E, w, Q, Te) {
    return (0, e.default)({
      type: "TSConditionalType",
      checkType: E,
      extendsType: w,
      trueType: Q,
      falseType: Te
    });
  }
  function ks(E) {
    return (0, e.default)({
      type: "TSInferType",
      typeParameter: E
    });
  }
  function Ds(E) {
    return (0, e.default)({
      type: "TSParenthesizedType",
      typeAnnotation: E
    });
  }
  function Ls(E) {
    return (0, e.default)({
      type: "TSTypeOperator",
      typeAnnotation: E,
      operator: null
    });
  }
  function Ms(E, w) {
    return (0, e.default)({
      type: "TSIndexedAccessType",
      objectType: E,
      indexType: w
    });
  }
  function Fs(E, w = null, Q = null) {
    return (0, e.default)({
      type: "TSMappedType",
      typeParameter: E,
      typeAnnotation: w,
      nameType: Q
    });
  }
  function Bs(E) {
    return (0, e.default)({
      type: "TSLiteralType",
      literal: E
    });
  }
  function js(E, w = null) {
    return (0, e.default)({
      type: "TSExpressionWithTypeArguments",
      expression: E,
      typeParameters: w
    });
  }
  function Rs(E, w = null, Q = null, Te) {
    return (0, e.default)({
      type: "TSInterfaceDeclaration",
      id: E,
      typeParameters: w,
      extends: Q,
      body: Te
    });
  }
  function qs(E) {
    return (0, e.default)({
      type: "TSInterfaceBody",
      body: E
    });
  }
  function Vs(E, w = null, Q) {
    return (0, e.default)({
      type: "TSTypeAliasDeclaration",
      id: E,
      typeParameters: w,
      typeAnnotation: Q
    });
  }
  function Us(E, w = null) {
    return (0, e.default)({
      type: "TSInstantiationExpression",
      expression: E,
      typeParameters: w
    });
  }
  function Ks(E, w) {
    return (0, e.default)({
      type: "TSAsExpression",
      expression: E,
      typeAnnotation: w
    });
  }
  function Ws(E, w) {
    return (0, e.default)({
      type: "TSSatisfiesExpression",
      expression: E,
      typeAnnotation: w
    });
  }
  function Js(E, w) {
    return (0, e.default)({
      type: "TSTypeAssertion",
      typeAnnotation: E,
      expression: w
    });
  }
  function Xs(E, w) {
    return (0, e.default)({
      type: "TSEnumDeclaration",
      id: E,
      members: w
    });
  }
  function Hs(E, w = null) {
    return (0, e.default)({
      type: "TSEnumMember",
      id: E,
      initializer: w
    });
  }
  function Ys(E, w) {
    return (0, e.default)({
      type: "TSModuleDeclaration",
      id: E,
      body: w
    });
  }
  function Gs(E) {
    return (0, e.default)({
      type: "TSModuleBlock",
      body: E
    });
  }
  function zs(E, w = null, Q = null) {
    return (0, e.default)({
      type: "TSImportType",
      argument: E,
      qualifier: w,
      typeParameters: Q
    });
  }
  function Qs(E, w) {
    return (0, e.default)({
      type: "TSImportEqualsDeclaration",
      id: E,
      moduleReference: w,
      isExport: null
    });
  }
  function Zs(E) {
    return (0, e.default)({
      type: "TSExternalModuleReference",
      expression: E
    });
  }
  function ei(E) {
    return (0, e.default)({
      type: "TSNonNullExpression",
      expression: E
    });
  }
  function ti(E) {
    return (0, e.default)({
      type: "TSExportAssignment",
      expression: E
    });
  }
  function ri(E) {
    return (0, e.default)({
      type: "TSNamespaceExportDeclaration",
      id: E
    });
  }
  function si(E) {
    return (0, e.default)({
      type: "TSTypeAnnotation",
      typeAnnotation: E
    });
  }
  function ii(E) {
    return (0, e.default)({
      type: "TSTypeParameterInstantiation",
      params: E
    });
  }
  function ni(E) {
    return (0, e.default)({
      type: "TSTypeParameterDeclaration",
      params: E
    });
  }
  function ai(E = null, w = null, Q) {
    return (0, e.default)({
      type: "TSTypeParameter",
      constraint: E,
      default: w,
      name: Q
    });
  }
  function oi(E) {
    return (0, t.default)("NumberLiteral", "NumericLiteral", "The node type "), ee(E);
  }
  function li(E, w = "") {
    return (0, t.default)("RegexLiteral", "RegExpLiteral", "The node type "), ve(E, w);
  }
  function ui(E) {
    return (0, t.default)("RestProperty", "RestElement", "The node type "), ce(E);
  }
  function ci(E) {
    return (0, t.default)("SpreadProperty", "SpreadElement", "The node type "), Ve(E);
  }
  return generated$2;
}
var hasRequiredCleanJSXElementLiteralChild;
function requireCleanJSXElementLiteralChild() {
  if (hasRequiredCleanJSXElementLiteralChild)
    return cleanJSXElementLiteralChild;
  hasRequiredCleanJSXElementLiteralChild = 1, Object.defineProperty(cleanJSXElementLiteralChild, "__esModule", {
    value: !0
  }), cleanJSXElementLiteralChild.default = s;
  var e = requireGenerated(), t = requireLib$1();
  function s(i, a) {
    const o = i.value.split(/\r\n|\n|\r/);
    let l = 0;
    for (let y = 0; y < o.length; y++)
      o[y].match(/[^ \t]/) && (l = y);
    let f = "";
    for (let y = 0; y < o.length; y++) {
      const g = o[y], T = y === 0, S = y === o.length - 1, b = y === l;
      let v = g.replace(/\t/g, " ");
      T || (v = v.replace(/^[ ]+/, "")), S || (v = v.replace(/[ ]+$/, "")), v && (b || (v += " "), f += v);
    }
    f && a.push((0, t.inherits)((0, e.stringLiteral)(f), i));
  }
  return cleanJSXElementLiteralChild;
}
var hasRequiredBuildChildren;
function requireBuildChildren() {
  if (hasRequiredBuildChildren)
    return buildChildren;
  hasRequiredBuildChildren = 1, Object.defineProperty(buildChildren, "__esModule", {
    value: !0
  }), buildChildren.default = s;
  var e = generated$3, t = requireCleanJSXElementLiteralChild();
  function s(i) {
    const a = [];
    for (let o = 0; o < i.children.length; o++) {
      let l = i.children[o];
      if ((0, e.isJSXText)(l)) {
        (0, t.default)(l, a);
        continue;
      }
      (0, e.isJSXExpressionContainer)(l) && (l = l.expression), !(0, e.isJSXEmptyExpression)(l) && a.push(l);
    }
    return a;
  }
  return buildChildren;
}
var assertNode$1 = {}, isNode$1 = {};
Object.defineProperty(isNode$1, "__esModule", {
  value: !0
});
isNode$1.default = isNode;
var _index$j = requireDefinitions();
function isNode(e) {
  return !!(e && _index$j.VISITOR_KEYS[e.type]);
}
Object.defineProperty(assertNode$1, "__esModule", {
  value: !0
});
assertNode$1.default = assertNode;
var _isNode = isNode$1;
function assertNode(e) {
  if (!(0, _isNode.default)(e)) {
    var t;
    const s = (t = e == null ? void 0 : e.type) != null ? t : JSON.stringify(e);
    throw new TypeError(`Not a valid node of type "${s}"`);
  }
}
var generated$1 = {};
Object.defineProperty(generated$1, "__esModule", {
  value: !0
});
generated$1.assertAccessor = assertAccessor;
generated$1.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
generated$1.assertArgumentPlaceholder = assertArgumentPlaceholder;
generated$1.assertArrayExpression = assertArrayExpression;
generated$1.assertArrayPattern = assertArrayPattern;
generated$1.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
generated$1.assertArrowFunctionExpression = assertArrowFunctionExpression;
generated$1.assertAssignmentExpression = assertAssignmentExpression;
generated$1.assertAssignmentPattern = assertAssignmentPattern;
generated$1.assertAwaitExpression = assertAwaitExpression;
generated$1.assertBigIntLiteral = assertBigIntLiteral;
generated$1.assertBinary = assertBinary;
generated$1.assertBinaryExpression = assertBinaryExpression;
generated$1.assertBindExpression = assertBindExpression;
generated$1.assertBlock = assertBlock;
generated$1.assertBlockParent = assertBlockParent;
generated$1.assertBlockStatement = assertBlockStatement;
generated$1.assertBooleanLiteral = assertBooleanLiteral;
generated$1.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
generated$1.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
generated$1.assertBreakStatement = assertBreakStatement;
generated$1.assertCallExpression = assertCallExpression;
generated$1.assertCatchClause = assertCatchClause;
generated$1.assertClass = assertClass;
generated$1.assertClassAccessorProperty = assertClassAccessorProperty;
generated$1.assertClassBody = assertClassBody;
generated$1.assertClassDeclaration = assertClassDeclaration;
generated$1.assertClassExpression = assertClassExpression;
generated$1.assertClassImplements = assertClassImplements;
generated$1.assertClassMethod = assertClassMethod;
generated$1.assertClassPrivateMethod = assertClassPrivateMethod;
generated$1.assertClassPrivateProperty = assertClassPrivateProperty;
generated$1.assertClassProperty = assertClassProperty;
generated$1.assertCompletionStatement = assertCompletionStatement;
generated$1.assertConditional = assertConditional;
generated$1.assertConditionalExpression = assertConditionalExpression;
generated$1.assertContinueStatement = assertContinueStatement;
generated$1.assertDebuggerStatement = assertDebuggerStatement;
generated$1.assertDecimalLiteral = assertDecimalLiteral;
generated$1.assertDeclaration = assertDeclaration;
generated$1.assertDeclareClass = assertDeclareClass;
generated$1.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
generated$1.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
generated$1.assertDeclareFunction = assertDeclareFunction;
generated$1.assertDeclareInterface = assertDeclareInterface;
generated$1.assertDeclareModule = assertDeclareModule;
generated$1.assertDeclareModuleExports = assertDeclareModuleExports;
generated$1.assertDeclareOpaqueType = assertDeclareOpaqueType;
generated$1.assertDeclareTypeAlias = assertDeclareTypeAlias;
generated$1.assertDeclareVariable = assertDeclareVariable;
generated$1.assertDeclaredPredicate = assertDeclaredPredicate;
generated$1.assertDecorator = assertDecorator;
generated$1.assertDirective = assertDirective;
generated$1.assertDirectiveLiteral = assertDirectiveLiteral;
generated$1.assertDoExpression = assertDoExpression;
generated$1.assertDoWhileStatement = assertDoWhileStatement;
generated$1.assertEmptyStatement = assertEmptyStatement;
generated$1.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
generated$1.assertEnumBody = assertEnumBody;
generated$1.assertEnumBooleanBody = assertEnumBooleanBody;
generated$1.assertEnumBooleanMember = assertEnumBooleanMember;
generated$1.assertEnumDeclaration = assertEnumDeclaration;
generated$1.assertEnumDefaultedMember = assertEnumDefaultedMember;
generated$1.assertEnumMember = assertEnumMember;
generated$1.assertEnumNumberBody = assertEnumNumberBody;
generated$1.assertEnumNumberMember = assertEnumNumberMember;
generated$1.assertEnumStringBody = assertEnumStringBody;
generated$1.assertEnumStringMember = assertEnumStringMember;
generated$1.assertEnumSymbolBody = assertEnumSymbolBody;
generated$1.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
generated$1.assertExportAllDeclaration = assertExportAllDeclaration;
generated$1.assertExportDeclaration = assertExportDeclaration;
generated$1.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
generated$1.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
generated$1.assertExportNamedDeclaration = assertExportNamedDeclaration;
generated$1.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
generated$1.assertExportSpecifier = assertExportSpecifier;
generated$1.assertExpression = assertExpression;
generated$1.assertExpressionStatement = assertExpressionStatement$1;
generated$1.assertExpressionWrapper = assertExpressionWrapper;
generated$1.assertFile = assertFile;
generated$1.assertFlow = assertFlow;
generated$1.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
generated$1.assertFlowDeclaration = assertFlowDeclaration;
generated$1.assertFlowPredicate = assertFlowPredicate;
generated$1.assertFlowType = assertFlowType;
generated$1.assertFor = assertFor;
generated$1.assertForInStatement = assertForInStatement;
generated$1.assertForOfStatement = assertForOfStatement;
generated$1.assertForStatement = assertForStatement;
generated$1.assertForXStatement = assertForXStatement;
generated$1.assertFunction = assertFunction;
generated$1.assertFunctionDeclaration = assertFunctionDeclaration;
generated$1.assertFunctionExpression = assertFunctionExpression;
generated$1.assertFunctionParent = assertFunctionParent;
generated$1.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
generated$1.assertFunctionTypeParam = assertFunctionTypeParam;
generated$1.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
generated$1.assertIdentifier = assertIdentifier;
generated$1.assertIfStatement = assertIfStatement;
generated$1.assertImmutable = assertImmutable;
generated$1.assertImport = assertImport;
generated$1.assertImportAttribute = assertImportAttribute;
generated$1.assertImportDeclaration = assertImportDeclaration;
generated$1.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
generated$1.assertImportExpression = assertImportExpression;
generated$1.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
generated$1.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
generated$1.assertImportSpecifier = assertImportSpecifier;
generated$1.assertIndexedAccessType = assertIndexedAccessType;
generated$1.assertInferredPredicate = assertInferredPredicate;
generated$1.assertInterfaceDeclaration = assertInterfaceDeclaration;
generated$1.assertInterfaceExtends = assertInterfaceExtends;
generated$1.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
generated$1.assertInterpreterDirective = assertInterpreterDirective;
generated$1.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
generated$1.assertJSX = assertJSX;
generated$1.assertJSXAttribute = assertJSXAttribute;
generated$1.assertJSXClosingElement = assertJSXClosingElement;
generated$1.assertJSXClosingFragment = assertJSXClosingFragment;
generated$1.assertJSXElement = assertJSXElement;
generated$1.assertJSXEmptyExpression = assertJSXEmptyExpression;
generated$1.assertJSXExpressionContainer = assertJSXExpressionContainer;
generated$1.assertJSXFragment = assertJSXFragment;
generated$1.assertJSXIdentifier = assertJSXIdentifier;
generated$1.assertJSXMemberExpression = assertJSXMemberExpression;
generated$1.assertJSXNamespacedName = assertJSXNamespacedName;
generated$1.assertJSXOpeningElement = assertJSXOpeningElement;
generated$1.assertJSXOpeningFragment = assertJSXOpeningFragment;
generated$1.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
generated$1.assertJSXSpreadChild = assertJSXSpreadChild;
generated$1.assertJSXText = assertJSXText;
generated$1.assertLVal = assertLVal;
generated$1.assertLabeledStatement = assertLabeledStatement;
generated$1.assertLiteral = assertLiteral;
generated$1.assertLogicalExpression = assertLogicalExpression;
generated$1.assertLoop = assertLoop;
generated$1.assertMemberExpression = assertMemberExpression;
generated$1.assertMetaProperty = assertMetaProperty;
generated$1.assertMethod = assertMethod;
generated$1.assertMiscellaneous = assertMiscellaneous;
generated$1.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
generated$1.assertModuleDeclaration = assertModuleDeclaration;
generated$1.assertModuleExpression = assertModuleExpression;
generated$1.assertModuleSpecifier = assertModuleSpecifier;
generated$1.assertNewExpression = assertNewExpression;
generated$1.assertNoop = assertNoop;
generated$1.assertNullLiteral = assertNullLiteral;
generated$1.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
generated$1.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
generated$1.assertNumberLiteral = assertNumberLiteral;
generated$1.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
generated$1.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
generated$1.assertNumericLiteral = assertNumericLiteral;
generated$1.assertObjectExpression = assertObjectExpression;
generated$1.assertObjectMember = assertObjectMember;
generated$1.assertObjectMethod = assertObjectMethod;
generated$1.assertObjectPattern = assertObjectPattern;
generated$1.assertObjectProperty = assertObjectProperty;
generated$1.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
generated$1.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
generated$1.assertObjectTypeIndexer = assertObjectTypeIndexer;
generated$1.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
generated$1.assertObjectTypeProperty = assertObjectTypeProperty;
generated$1.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
generated$1.assertOpaqueType = assertOpaqueType;
generated$1.assertOptionalCallExpression = assertOptionalCallExpression;
generated$1.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
generated$1.assertOptionalMemberExpression = assertOptionalMemberExpression;
generated$1.assertParenthesizedExpression = assertParenthesizedExpression;
generated$1.assertPattern = assertPattern;
generated$1.assertPatternLike = assertPatternLike;
generated$1.assertPipelineBareFunction = assertPipelineBareFunction;
generated$1.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
generated$1.assertPipelineTopicExpression = assertPipelineTopicExpression;
generated$1.assertPlaceholder = assertPlaceholder;
generated$1.assertPrivate = assertPrivate;
generated$1.assertPrivateName = assertPrivateName;
generated$1.assertProgram = assertProgram;
generated$1.assertProperty = assertProperty;
generated$1.assertPureish = assertPureish;
generated$1.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
generated$1.assertRecordExpression = assertRecordExpression;
generated$1.assertRegExpLiteral = assertRegExpLiteral;
generated$1.assertRegexLiteral = assertRegexLiteral;
generated$1.assertRestElement = assertRestElement;
generated$1.assertRestProperty = assertRestProperty;
generated$1.assertReturnStatement = assertReturnStatement;
generated$1.assertScopable = assertScopable;
generated$1.assertSequenceExpression = assertSequenceExpression;
generated$1.assertSpreadElement = assertSpreadElement;
generated$1.assertSpreadProperty = assertSpreadProperty;
generated$1.assertStandardized = assertStandardized;
generated$1.assertStatement = assertStatement;
generated$1.assertStaticBlock = assertStaticBlock;
generated$1.assertStringLiteral = assertStringLiteral;
generated$1.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
generated$1.assertStringTypeAnnotation = assertStringTypeAnnotation;
generated$1.assertSuper = assertSuper;
generated$1.assertSwitchCase = assertSwitchCase;
generated$1.assertSwitchStatement = assertSwitchStatement;
generated$1.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
generated$1.assertTSAnyKeyword = assertTSAnyKeyword;
generated$1.assertTSArrayType = assertTSArrayType;
generated$1.assertTSAsExpression = assertTSAsExpression;
generated$1.assertTSBaseType = assertTSBaseType;
generated$1.assertTSBigIntKeyword = assertTSBigIntKeyword;
generated$1.assertTSBooleanKeyword = assertTSBooleanKeyword;
generated$1.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
generated$1.assertTSConditionalType = assertTSConditionalType;
generated$1.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
generated$1.assertTSConstructorType = assertTSConstructorType;
generated$1.assertTSDeclareFunction = assertTSDeclareFunction;
generated$1.assertTSDeclareMethod = assertTSDeclareMethod;
generated$1.assertTSEntityName = assertTSEntityName;
generated$1.assertTSEnumDeclaration = assertTSEnumDeclaration;
generated$1.assertTSEnumMember = assertTSEnumMember;
generated$1.assertTSExportAssignment = assertTSExportAssignment;
generated$1.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
generated$1.assertTSExternalModuleReference = assertTSExternalModuleReference;
generated$1.assertTSFunctionType = assertTSFunctionType;
generated$1.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
generated$1.assertTSImportType = assertTSImportType;
generated$1.assertTSIndexSignature = assertTSIndexSignature;
generated$1.assertTSIndexedAccessType = assertTSIndexedAccessType;
generated$1.assertTSInferType = assertTSInferType;
generated$1.assertTSInstantiationExpression = assertTSInstantiationExpression;
generated$1.assertTSInterfaceBody = assertTSInterfaceBody;
generated$1.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
generated$1.assertTSIntersectionType = assertTSIntersectionType;
generated$1.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
generated$1.assertTSLiteralType = assertTSLiteralType;
generated$1.assertTSMappedType = assertTSMappedType;
generated$1.assertTSMethodSignature = assertTSMethodSignature;
generated$1.assertTSModuleBlock = assertTSModuleBlock;
generated$1.assertTSModuleDeclaration = assertTSModuleDeclaration;
generated$1.assertTSNamedTupleMember = assertTSNamedTupleMember;
generated$1.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
generated$1.assertTSNeverKeyword = assertTSNeverKeyword;
generated$1.assertTSNonNullExpression = assertTSNonNullExpression;
generated$1.assertTSNullKeyword = assertTSNullKeyword;
generated$1.assertTSNumberKeyword = assertTSNumberKeyword;
generated$1.assertTSObjectKeyword = assertTSObjectKeyword;
generated$1.assertTSOptionalType = assertTSOptionalType;
generated$1.assertTSParameterProperty = assertTSParameterProperty;
generated$1.assertTSParenthesizedType = assertTSParenthesizedType;
generated$1.assertTSPropertySignature = assertTSPropertySignature;
generated$1.assertTSQualifiedName = assertTSQualifiedName;
generated$1.assertTSRestType = assertTSRestType;
generated$1.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
generated$1.assertTSStringKeyword = assertTSStringKeyword;
generated$1.assertTSSymbolKeyword = assertTSSymbolKeyword;
generated$1.assertTSThisType = assertTSThisType;
generated$1.assertTSTupleType = assertTSTupleType;
generated$1.assertTSType = assertTSType;
generated$1.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
generated$1.assertTSTypeAnnotation = assertTSTypeAnnotation;
generated$1.assertTSTypeAssertion = assertTSTypeAssertion;
generated$1.assertTSTypeElement = assertTSTypeElement;
generated$1.assertTSTypeLiteral = assertTSTypeLiteral;
generated$1.assertTSTypeOperator = assertTSTypeOperator;
generated$1.assertTSTypeParameter = assertTSTypeParameter;
generated$1.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
generated$1.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
generated$1.assertTSTypePredicate = assertTSTypePredicate;
generated$1.assertTSTypeQuery = assertTSTypeQuery;
generated$1.assertTSTypeReference = assertTSTypeReference;
generated$1.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
generated$1.assertTSUnionType = assertTSUnionType;
generated$1.assertTSUnknownKeyword = assertTSUnknownKeyword;
generated$1.assertTSVoidKeyword = assertTSVoidKeyword;
generated$1.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
generated$1.assertTemplateElement = assertTemplateElement;
generated$1.assertTemplateLiteral = assertTemplateLiteral;
generated$1.assertTerminatorless = assertTerminatorless;
generated$1.assertThisExpression = assertThisExpression;
generated$1.assertThisTypeAnnotation = assertThisTypeAnnotation;
generated$1.assertThrowStatement = assertThrowStatement;
generated$1.assertTopicReference = assertTopicReference;
generated$1.assertTryStatement = assertTryStatement;
generated$1.assertTupleExpression = assertTupleExpression;
generated$1.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
generated$1.assertTypeAlias = assertTypeAlias;
generated$1.assertTypeAnnotation = assertTypeAnnotation;
generated$1.assertTypeCastExpression = assertTypeCastExpression;
generated$1.assertTypeParameter = assertTypeParameter;
generated$1.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
generated$1.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
generated$1.assertTypeScript = assertTypeScript;
generated$1.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
generated$1.assertUnaryExpression = assertUnaryExpression;
generated$1.assertUnaryLike = assertUnaryLike;
generated$1.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
generated$1.assertUpdateExpression = assertUpdateExpression;
generated$1.assertUserWhitespacable = assertUserWhitespacable;
generated$1.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
generated$1.assertVariableDeclaration = assertVariableDeclaration;
generated$1.assertVariableDeclarator = assertVariableDeclarator;
generated$1.assertVariance = assertVariance;
generated$1.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
generated$1.assertWhile = assertWhile;
generated$1.assertWhileStatement = assertWhileStatement;
generated$1.assertWithStatement = assertWithStatement;
generated$1.assertYieldExpression = assertYieldExpression;
var _is = requireIs(), _deprecationWarning = deprecationWarning$2;
function assert$1(e, t, s) {
  if (!(0, _is.default)(e, t, s))
    throw new Error(`Expected type "${e}" with option ${JSON.stringify(s)}, but instead got "${t.type}".`);
}
function assertArrayExpression(e, t) {
  assert$1("ArrayExpression", e, t);
}
function assertAssignmentExpression(e, t) {
  assert$1("AssignmentExpression", e, t);
}
function assertBinaryExpression(e, t) {
  assert$1("BinaryExpression", e, t);
}
function assertInterpreterDirective(e, t) {
  assert$1("InterpreterDirective", e, t);
}
function assertDirective(e, t) {
  assert$1("Directive", e, t);
}
function assertDirectiveLiteral(e, t) {
  assert$1("DirectiveLiteral", e, t);
}
function assertBlockStatement(e, t) {
  assert$1("BlockStatement", e, t);
}
function assertBreakStatement(e, t) {
  assert$1("BreakStatement", e, t);
}
function assertCallExpression(e, t) {
  assert$1("CallExpression", e, t);
}
function assertCatchClause(e, t) {
  assert$1("CatchClause", e, t);
}
function assertConditionalExpression(e, t) {
  assert$1("ConditionalExpression", e, t);
}
function assertContinueStatement(e, t) {
  assert$1("ContinueStatement", e, t);
}
function assertDebuggerStatement(e, t) {
  assert$1("DebuggerStatement", e, t);
}
function assertDoWhileStatement(e, t) {
  assert$1("DoWhileStatement", e, t);
}
function assertEmptyStatement(e, t) {
  assert$1("EmptyStatement", e, t);
}
function assertExpressionStatement$1(e, t) {
  assert$1("ExpressionStatement", e, t);
}
function assertFile(e, t) {
  assert$1("File", e, t);
}
function assertForInStatement(e, t) {
  assert$1("ForInStatement", e, t);
}
function assertForStatement(e, t) {
  assert$1("ForStatement", e, t);
}
function assertFunctionDeclaration(e, t) {
  assert$1("FunctionDeclaration", e, t);
}
function assertFunctionExpression(e, t) {
  assert$1("FunctionExpression", e, t);
}
function assertIdentifier(e, t) {
  assert$1("Identifier", e, t);
}
function assertIfStatement(e, t) {
  assert$1("IfStatement", e, t);
}
function assertLabeledStatement(e, t) {
  assert$1("LabeledStatement", e, t);
}
function assertStringLiteral(e, t) {
  assert$1("StringLiteral", e, t);
}
function assertNumericLiteral(e, t) {
  assert$1("NumericLiteral", e, t);
}
function assertNullLiteral(e, t) {
  assert$1("NullLiteral", e, t);
}
function assertBooleanLiteral(e, t) {
  assert$1("BooleanLiteral", e, t);
}
function assertRegExpLiteral(e, t) {
  assert$1("RegExpLiteral", e, t);
}
function assertLogicalExpression(e, t) {
  assert$1("LogicalExpression", e, t);
}
function assertMemberExpression(e, t) {
  assert$1("MemberExpression", e, t);
}
function assertNewExpression(e, t) {
  assert$1("NewExpression", e, t);
}
function assertProgram(e, t) {
  assert$1("Program", e, t);
}
function assertObjectExpression(e, t) {
  assert$1("ObjectExpression", e, t);
}
function assertObjectMethod(e, t) {
  assert$1("ObjectMethod", e, t);
}
function assertObjectProperty(e, t) {
  assert$1("ObjectProperty", e, t);
}
function assertRestElement(e, t) {
  assert$1("RestElement", e, t);
}
function assertReturnStatement(e, t) {
  assert$1("ReturnStatement", e, t);
}
function assertSequenceExpression(e, t) {
  assert$1("SequenceExpression", e, t);
}
function assertParenthesizedExpression(e, t) {
  assert$1("ParenthesizedExpression", e, t);
}
function assertSwitchCase(e, t) {
  assert$1("SwitchCase", e, t);
}
function assertSwitchStatement(e, t) {
  assert$1("SwitchStatement", e, t);
}
function assertThisExpression(e, t) {
  assert$1("ThisExpression", e, t);
}
function assertThrowStatement(e, t) {
  assert$1("ThrowStatement", e, t);
}
function assertTryStatement(e, t) {
  assert$1("TryStatement", e, t);
}
function assertUnaryExpression(e, t) {
  assert$1("UnaryExpression", e, t);
}
function assertUpdateExpression(e, t) {
  assert$1("UpdateExpression", e, t);
}
function assertVariableDeclaration(e, t) {
  assert$1("VariableDeclaration", e, t);
}
function assertVariableDeclarator(e, t) {
  assert$1("VariableDeclarator", e, t);
}
function assertWhileStatement(e, t) {
  assert$1("WhileStatement", e, t);
}
function assertWithStatement(e, t) {
  assert$1("WithStatement", e, t);
}
function assertAssignmentPattern(e, t) {
  assert$1("AssignmentPattern", e, t);
}
function assertArrayPattern(e, t) {
  assert$1("ArrayPattern", e, t);
}
function assertArrowFunctionExpression(e, t) {
  assert$1("ArrowFunctionExpression", e, t);
}
function assertClassBody(e, t) {
  assert$1("ClassBody", e, t);
}
function assertClassExpression(e, t) {
  assert$1("ClassExpression", e, t);
}
function assertClassDeclaration(e, t) {
  assert$1("ClassDeclaration", e, t);
}
function assertExportAllDeclaration(e, t) {
  assert$1("ExportAllDeclaration", e, t);
}
function assertExportDefaultDeclaration(e, t) {
  assert$1("ExportDefaultDeclaration", e, t);
}
function assertExportNamedDeclaration(e, t) {
  assert$1("ExportNamedDeclaration", e, t);
}
function assertExportSpecifier(e, t) {
  assert$1("ExportSpecifier", e, t);
}
function assertForOfStatement(e, t) {
  assert$1("ForOfStatement", e, t);
}
function assertImportDeclaration(e, t) {
  assert$1("ImportDeclaration", e, t);
}
function assertImportDefaultSpecifier(e, t) {
  assert$1("ImportDefaultSpecifier", e, t);
}
function assertImportNamespaceSpecifier(e, t) {
  assert$1("ImportNamespaceSpecifier", e, t);
}
function assertImportSpecifier(e, t) {
  assert$1("ImportSpecifier", e, t);
}
function assertImportExpression(e, t) {
  assert$1("ImportExpression", e, t);
}
function assertMetaProperty(e, t) {
  assert$1("MetaProperty", e, t);
}
function assertClassMethod(e, t) {
  assert$1("ClassMethod", e, t);
}
function assertObjectPattern(e, t) {
  assert$1("ObjectPattern", e, t);
}
function assertSpreadElement(e, t) {
  assert$1("SpreadElement", e, t);
}
function assertSuper(e, t) {
  assert$1("Super", e, t);
}
function assertTaggedTemplateExpression(e, t) {
  assert$1("TaggedTemplateExpression", e, t);
}
function assertTemplateElement(e, t) {
  assert$1("TemplateElement", e, t);
}
function assertTemplateLiteral(e, t) {
  assert$1("TemplateLiteral", e, t);
}
function assertYieldExpression(e, t) {
  assert$1("YieldExpression", e, t);
}
function assertAwaitExpression(e, t) {
  assert$1("AwaitExpression", e, t);
}
function assertImport(e, t) {
  assert$1("Import", e, t);
}
function assertBigIntLiteral(e, t) {
  assert$1("BigIntLiteral", e, t);
}
function assertExportNamespaceSpecifier(e, t) {
  assert$1("ExportNamespaceSpecifier", e, t);
}
function assertOptionalMemberExpression(e, t) {
  assert$1("OptionalMemberExpression", e, t);
}
function assertOptionalCallExpression(e, t) {
  assert$1("OptionalCallExpression", e, t);
}
function assertClassProperty(e, t) {
  assert$1("ClassProperty", e, t);
}
function assertClassAccessorProperty(e, t) {
  assert$1("ClassAccessorProperty", e, t);
}
function assertClassPrivateProperty(e, t) {
  assert$1("ClassPrivateProperty", e, t);
}
function assertClassPrivateMethod(e, t) {
  assert$1("ClassPrivateMethod", e, t);
}
function assertPrivateName(e, t) {
  assert$1("PrivateName", e, t);
}
function assertStaticBlock(e, t) {
  assert$1("StaticBlock", e, t);
}
function assertAnyTypeAnnotation(e, t) {
  assert$1("AnyTypeAnnotation", e, t);
}
function assertArrayTypeAnnotation(e, t) {
  assert$1("ArrayTypeAnnotation", e, t);
}
function assertBooleanTypeAnnotation(e, t) {
  assert$1("BooleanTypeAnnotation", e, t);
}
function assertBooleanLiteralTypeAnnotation(e, t) {
  assert$1("BooleanLiteralTypeAnnotation", e, t);
}
function assertNullLiteralTypeAnnotation(e, t) {
  assert$1("NullLiteralTypeAnnotation", e, t);
}
function assertClassImplements(e, t) {
  assert$1("ClassImplements", e, t);
}
function assertDeclareClass(e, t) {
  assert$1("DeclareClass", e, t);
}
function assertDeclareFunction(e, t) {
  assert$1("DeclareFunction", e, t);
}
function assertDeclareInterface(e, t) {
  assert$1("DeclareInterface", e, t);
}
function assertDeclareModule(e, t) {
  assert$1("DeclareModule", e, t);
}
function assertDeclareModuleExports(e, t) {
  assert$1("DeclareModuleExports", e, t);
}
function assertDeclareTypeAlias(e, t) {
  assert$1("DeclareTypeAlias", e, t);
}
function assertDeclareOpaqueType(e, t) {
  assert$1("DeclareOpaqueType", e, t);
}
function assertDeclareVariable(e, t) {
  assert$1("DeclareVariable", e, t);
}
function assertDeclareExportDeclaration(e, t) {
  assert$1("DeclareExportDeclaration", e, t);
}
function assertDeclareExportAllDeclaration(e, t) {
  assert$1("DeclareExportAllDeclaration", e, t);
}
function assertDeclaredPredicate(e, t) {
  assert$1("DeclaredPredicate", e, t);
}
function assertExistsTypeAnnotation(e, t) {
  assert$1("ExistsTypeAnnotation", e, t);
}
function assertFunctionTypeAnnotation(e, t) {
  assert$1("FunctionTypeAnnotation", e, t);
}
function assertFunctionTypeParam(e, t) {
  assert$1("FunctionTypeParam", e, t);
}
function assertGenericTypeAnnotation(e, t) {
  assert$1("GenericTypeAnnotation", e, t);
}
function assertInferredPredicate(e, t) {
  assert$1("InferredPredicate", e, t);
}
function assertInterfaceExtends(e, t) {
  assert$1("InterfaceExtends", e, t);
}
function assertInterfaceDeclaration(e, t) {
  assert$1("InterfaceDeclaration", e, t);
}
function assertInterfaceTypeAnnotation(e, t) {
  assert$1("InterfaceTypeAnnotation", e, t);
}
function assertIntersectionTypeAnnotation(e, t) {
  assert$1("IntersectionTypeAnnotation", e, t);
}
function assertMixedTypeAnnotation(e, t) {
  assert$1("MixedTypeAnnotation", e, t);
}
function assertEmptyTypeAnnotation(e, t) {
  assert$1("EmptyTypeAnnotation", e, t);
}
function assertNullableTypeAnnotation(e, t) {
  assert$1("NullableTypeAnnotation", e, t);
}
function assertNumberLiteralTypeAnnotation(e, t) {
  assert$1("NumberLiteralTypeAnnotation", e, t);
}
function assertNumberTypeAnnotation(e, t) {
  assert$1("NumberTypeAnnotation", e, t);
}
function assertObjectTypeAnnotation(e, t) {
  assert$1("ObjectTypeAnnotation", e, t);
}
function assertObjectTypeInternalSlot(e, t) {
  assert$1("ObjectTypeInternalSlot", e, t);
}
function assertObjectTypeCallProperty(e, t) {
  assert$1("ObjectTypeCallProperty", e, t);
}
function assertObjectTypeIndexer(e, t) {
  assert$1("ObjectTypeIndexer", e, t);
}
function assertObjectTypeProperty(e, t) {
  assert$1("ObjectTypeProperty", e, t);
}
function assertObjectTypeSpreadProperty(e, t) {
  assert$1("ObjectTypeSpreadProperty", e, t);
}
function assertOpaqueType(e, t) {
  assert$1("OpaqueType", e, t);
}
function assertQualifiedTypeIdentifier(e, t) {
  assert$1("QualifiedTypeIdentifier", e, t);
}
function assertStringLiteralTypeAnnotation(e, t) {
  assert$1("StringLiteralTypeAnnotation", e, t);
}
function assertStringTypeAnnotation(e, t) {
  assert$1("StringTypeAnnotation", e, t);
}
function assertSymbolTypeAnnotation(e, t) {
  assert$1("SymbolTypeAnnotation", e, t);
}
function assertThisTypeAnnotation(e, t) {
  assert$1("ThisTypeAnnotation", e, t);
}
function assertTupleTypeAnnotation(e, t) {
  assert$1("TupleTypeAnnotation", e, t);
}
function assertTypeofTypeAnnotation(e, t) {
  assert$1("TypeofTypeAnnotation", e, t);
}
function assertTypeAlias(e, t) {
  assert$1("TypeAlias", e, t);
}
function assertTypeAnnotation(e, t) {
  assert$1("TypeAnnotation", e, t);
}
function assertTypeCastExpression(e, t) {
  assert$1("TypeCastExpression", e, t);
}
function assertTypeParameter(e, t) {
  assert$1("TypeParameter", e, t);
}
function assertTypeParameterDeclaration(e, t) {
  assert$1("TypeParameterDeclaration", e, t);
}
function assertTypeParameterInstantiation(e, t) {
  assert$1("TypeParameterInstantiation", e, t);
}
function assertUnionTypeAnnotation(e, t) {
  assert$1("UnionTypeAnnotation", e, t);
}
function assertVariance(e, t) {
  assert$1("Variance", e, t);
}
function assertVoidTypeAnnotation(e, t) {
  assert$1("VoidTypeAnnotation", e, t);
}
function assertEnumDeclaration(e, t) {
  assert$1("EnumDeclaration", e, t);
}
function assertEnumBooleanBody(e, t) {
  assert$1("EnumBooleanBody", e, t);
}
function assertEnumNumberBody(e, t) {
  assert$1("EnumNumberBody", e, t);
}
function assertEnumStringBody(e, t) {
  assert$1("EnumStringBody", e, t);
}
function assertEnumSymbolBody(e, t) {
  assert$1("EnumSymbolBody", e, t);
}
function assertEnumBooleanMember(e, t) {
  assert$1("EnumBooleanMember", e, t);
}
function assertEnumNumberMember(e, t) {
  assert$1("EnumNumberMember", e, t);
}
function assertEnumStringMember(e, t) {
  assert$1("EnumStringMember", e, t);
}
function assertEnumDefaultedMember(e, t) {
  assert$1("EnumDefaultedMember", e, t);
}
function assertIndexedAccessType(e, t) {
  assert$1("IndexedAccessType", e, t);
}
function assertOptionalIndexedAccessType(e, t) {
  assert$1("OptionalIndexedAccessType", e, t);
}
function assertJSXAttribute(e, t) {
  assert$1("JSXAttribute", e, t);
}
function assertJSXClosingElement(e, t) {
  assert$1("JSXClosingElement", e, t);
}
function assertJSXElement(e, t) {
  assert$1("JSXElement", e, t);
}
function assertJSXEmptyExpression(e, t) {
  assert$1("JSXEmptyExpression", e, t);
}
function assertJSXExpressionContainer(e, t) {
  assert$1("JSXExpressionContainer", e, t);
}
function assertJSXSpreadChild(e, t) {
  assert$1("JSXSpreadChild", e, t);
}
function assertJSXIdentifier(e, t) {
  assert$1("JSXIdentifier", e, t);
}
function assertJSXMemberExpression(e, t) {
  assert$1("JSXMemberExpression", e, t);
}
function assertJSXNamespacedName(e, t) {
  assert$1("JSXNamespacedName", e, t);
}
function assertJSXOpeningElement(e, t) {
  assert$1("JSXOpeningElement", e, t);
}
function assertJSXSpreadAttribute(e, t) {
  assert$1("JSXSpreadAttribute", e, t);
}
function assertJSXText(e, t) {
  assert$1("JSXText", e, t);
}
function assertJSXFragment(e, t) {
  assert$1("JSXFragment", e, t);
}
function assertJSXOpeningFragment(e, t) {
  assert$1("JSXOpeningFragment", e, t);
}
function assertJSXClosingFragment(e, t) {
  assert$1("JSXClosingFragment", e, t);
}
function assertNoop(e, t) {
  assert$1("Noop", e, t);
}
function assertPlaceholder(e, t) {
  assert$1("Placeholder", e, t);
}
function assertV8IntrinsicIdentifier(e, t) {
  assert$1("V8IntrinsicIdentifier", e, t);
}
function assertArgumentPlaceholder(e, t) {
  assert$1("ArgumentPlaceholder", e, t);
}
function assertBindExpression(e, t) {
  assert$1("BindExpression", e, t);
}
function assertImportAttribute(e, t) {
  assert$1("ImportAttribute", e, t);
}
function assertDecorator(e, t) {
  assert$1("Decorator", e, t);
}
function assertDoExpression(e, t) {
  assert$1("DoExpression", e, t);
}
function assertExportDefaultSpecifier(e, t) {
  assert$1("ExportDefaultSpecifier", e, t);
}
function assertRecordExpression(e, t) {
  assert$1("RecordExpression", e, t);
}
function assertTupleExpression(e, t) {
  assert$1("TupleExpression", e, t);
}
function assertDecimalLiteral(e, t) {
  assert$1("DecimalLiteral", e, t);
}
function assertModuleExpression(e, t) {
  assert$1("ModuleExpression", e, t);
}
function assertTopicReference(e, t) {
  assert$1("TopicReference", e, t);
}
function assertPipelineTopicExpression(e, t) {
  assert$1("PipelineTopicExpression", e, t);
}
function assertPipelineBareFunction(e, t) {
  assert$1("PipelineBareFunction", e, t);
}
function assertPipelinePrimaryTopicReference(e, t) {
  assert$1("PipelinePrimaryTopicReference", e, t);
}
function assertTSParameterProperty(e, t) {
  assert$1("TSParameterProperty", e, t);
}
function assertTSDeclareFunction(e, t) {
  assert$1("TSDeclareFunction", e, t);
}
function assertTSDeclareMethod(e, t) {
  assert$1("TSDeclareMethod", e, t);
}
function assertTSQualifiedName(e, t) {
  assert$1("TSQualifiedName", e, t);
}
function assertTSCallSignatureDeclaration(e, t) {
  assert$1("TSCallSignatureDeclaration", e, t);
}
function assertTSConstructSignatureDeclaration(e, t) {
  assert$1("TSConstructSignatureDeclaration", e, t);
}
function assertTSPropertySignature(e, t) {
  assert$1("TSPropertySignature", e, t);
}
function assertTSMethodSignature(e, t) {
  assert$1("TSMethodSignature", e, t);
}
function assertTSIndexSignature(e, t) {
  assert$1("TSIndexSignature", e, t);
}
function assertTSAnyKeyword(e, t) {
  assert$1("TSAnyKeyword", e, t);
}
function assertTSBooleanKeyword(e, t) {
  assert$1("TSBooleanKeyword", e, t);
}
function assertTSBigIntKeyword(e, t) {
  assert$1("TSBigIntKeyword", e, t);
}
function assertTSIntrinsicKeyword(e, t) {
  assert$1("TSIntrinsicKeyword", e, t);
}
function assertTSNeverKeyword(e, t) {
  assert$1("TSNeverKeyword", e, t);
}
function assertTSNullKeyword(e, t) {
  assert$1("TSNullKeyword", e, t);
}
function assertTSNumberKeyword(e, t) {
  assert$1("TSNumberKeyword", e, t);
}
function assertTSObjectKeyword(e, t) {
  assert$1("TSObjectKeyword", e, t);
}
function assertTSStringKeyword(e, t) {
  assert$1("TSStringKeyword", e, t);
}
function assertTSSymbolKeyword(e, t) {
  assert$1("TSSymbolKeyword", e, t);
}
function assertTSUndefinedKeyword(e, t) {
  assert$1("TSUndefinedKeyword", e, t);
}
function assertTSUnknownKeyword(e, t) {
  assert$1("TSUnknownKeyword", e, t);
}
function assertTSVoidKeyword(e, t) {
  assert$1("TSVoidKeyword", e, t);
}
function assertTSThisType(e, t) {
  assert$1("TSThisType", e, t);
}
function assertTSFunctionType(e, t) {
  assert$1("TSFunctionType", e, t);
}
function assertTSConstructorType(e, t) {
  assert$1("TSConstructorType", e, t);
}
function assertTSTypeReference(e, t) {
  assert$1("TSTypeReference", e, t);
}
function assertTSTypePredicate(e, t) {
  assert$1("TSTypePredicate", e, t);
}
function assertTSTypeQuery(e, t) {
  assert$1("TSTypeQuery", e, t);
}
function assertTSTypeLiteral(e, t) {
  assert$1("TSTypeLiteral", e, t);
}
function assertTSArrayType(e, t) {
  assert$1("TSArrayType", e, t);
}
function assertTSTupleType(e, t) {
  assert$1("TSTupleType", e, t);
}
function assertTSOptionalType(e, t) {
  assert$1("TSOptionalType", e, t);
}
function assertTSRestType(e, t) {
  assert$1("TSRestType", e, t);
}
function assertTSNamedTupleMember(e, t) {
  assert$1("TSNamedTupleMember", e, t);
}
function assertTSUnionType(e, t) {
  assert$1("TSUnionType", e, t);
}
function assertTSIntersectionType(e, t) {
  assert$1("TSIntersectionType", e, t);
}
function assertTSConditionalType(e, t) {
  assert$1("TSConditionalType", e, t);
}
function assertTSInferType(e, t) {
  assert$1("TSInferType", e, t);
}
function assertTSParenthesizedType(e, t) {
  assert$1("TSParenthesizedType", e, t);
}
function assertTSTypeOperator(e, t) {
  assert$1("TSTypeOperator", e, t);
}
function assertTSIndexedAccessType(e, t) {
  assert$1("TSIndexedAccessType", e, t);
}
function assertTSMappedType(e, t) {
  assert$1("TSMappedType", e, t);
}
function assertTSLiteralType(e, t) {
  assert$1("TSLiteralType", e, t);
}
function assertTSExpressionWithTypeArguments(e, t) {
  assert$1("TSExpressionWithTypeArguments", e, t);
}
function assertTSInterfaceDeclaration(e, t) {
  assert$1("TSInterfaceDeclaration", e, t);
}
function assertTSInterfaceBody(e, t) {
  assert$1("TSInterfaceBody", e, t);
}
function assertTSTypeAliasDeclaration(e, t) {
  assert$1("TSTypeAliasDeclaration", e, t);
}
function assertTSInstantiationExpression(e, t) {
  assert$1("TSInstantiationExpression", e, t);
}
function assertTSAsExpression(e, t) {
  assert$1("TSAsExpression", e, t);
}
function assertTSSatisfiesExpression(e, t) {
  assert$1("TSSatisfiesExpression", e, t);
}
function assertTSTypeAssertion(e, t) {
  assert$1("TSTypeAssertion", e, t);
}
function assertTSEnumDeclaration(e, t) {
  assert$1("TSEnumDeclaration", e, t);
}
function assertTSEnumMember(e, t) {
  assert$1("TSEnumMember", e, t);
}
function assertTSModuleDeclaration(e, t) {
  assert$1("TSModuleDeclaration", e, t);
}
function assertTSModuleBlock(e, t) {
  assert$1("TSModuleBlock", e, t);
}
function assertTSImportType(e, t) {
  assert$1("TSImportType", e, t);
}
function assertTSImportEqualsDeclaration(e, t) {
  assert$1("TSImportEqualsDeclaration", e, t);
}
function assertTSExternalModuleReference(e, t) {
  assert$1("TSExternalModuleReference", e, t);
}
function assertTSNonNullExpression(e, t) {
  assert$1("TSNonNullExpression", e, t);
}
function assertTSExportAssignment(e, t) {
  assert$1("TSExportAssignment", e, t);
}
function assertTSNamespaceExportDeclaration(e, t) {
  assert$1("TSNamespaceExportDeclaration", e, t);
}
function assertTSTypeAnnotation(e, t) {
  assert$1("TSTypeAnnotation", e, t);
}
function assertTSTypeParameterInstantiation(e, t) {
  assert$1("TSTypeParameterInstantiation", e, t);
}
function assertTSTypeParameterDeclaration(e, t) {
  assert$1("TSTypeParameterDeclaration", e, t);
}
function assertTSTypeParameter(e, t) {
  assert$1("TSTypeParameter", e, t);
}
function assertStandardized(e, t) {
  assert$1("Standardized", e, t);
}
function assertExpression(e, t) {
  assert$1("Expression", e, t);
}
function assertBinary(e, t) {
  assert$1("Binary", e, t);
}
function assertScopable(e, t) {
  assert$1("Scopable", e, t);
}
function assertBlockParent(e, t) {
  assert$1("BlockParent", e, t);
}
function assertBlock(e, t) {
  assert$1("Block", e, t);
}
function assertStatement(e, t) {
  assert$1("Statement", e, t);
}
function assertTerminatorless(e, t) {
  assert$1("Terminatorless", e, t);
}
function assertCompletionStatement(e, t) {
  assert$1("CompletionStatement", e, t);
}
function assertConditional(e, t) {
  assert$1("Conditional", e, t);
}
function assertLoop(e, t) {
  assert$1("Loop", e, t);
}
function assertWhile(e, t) {
  assert$1("While", e, t);
}
function assertExpressionWrapper(e, t) {
  assert$1("ExpressionWrapper", e, t);
}
function assertFor(e, t) {
  assert$1("For", e, t);
}
function assertForXStatement(e, t) {
  assert$1("ForXStatement", e, t);
}
function assertFunction(e, t) {
  assert$1("Function", e, t);
}
function assertFunctionParent(e, t) {
  assert$1("FunctionParent", e, t);
}
function assertPureish(e, t) {
  assert$1("Pureish", e, t);
}
function assertDeclaration(e, t) {
  assert$1("Declaration", e, t);
}
function assertPatternLike(e, t) {
  assert$1("PatternLike", e, t);
}
function assertLVal(e, t) {
  assert$1("LVal", e, t);
}
function assertTSEntityName(e, t) {
  assert$1("TSEntityName", e, t);
}
function assertLiteral(e, t) {
  assert$1("Literal", e, t);
}
function assertImmutable(e, t) {
  assert$1("Immutable", e, t);
}
function assertUserWhitespacable(e, t) {
  assert$1("UserWhitespacable", e, t);
}
function assertMethod(e, t) {
  assert$1("Method", e, t);
}
function assertObjectMember(e, t) {
  assert$1("ObjectMember", e, t);
}
function assertProperty(e, t) {
  assert$1("Property", e, t);
}
function assertUnaryLike(e, t) {
  assert$1("UnaryLike", e, t);
}
function assertPattern(e, t) {
  assert$1("Pattern", e, t);
}
function assertClass(e, t) {
  assert$1("Class", e, t);
}
function assertImportOrExportDeclaration(e, t) {
  assert$1("ImportOrExportDeclaration", e, t);
}
function assertExportDeclaration(e, t) {
  assert$1("ExportDeclaration", e, t);
}
function assertModuleSpecifier(e, t) {
  assert$1("ModuleSpecifier", e, t);
}
function assertAccessor(e, t) {
  assert$1("Accessor", e, t);
}
function assertPrivate(e, t) {
  assert$1("Private", e, t);
}
function assertFlow(e, t) {
  assert$1("Flow", e, t);
}
function assertFlowType(e, t) {
  assert$1("FlowType", e, t);
}
function assertFlowBaseAnnotation(e, t) {
  assert$1("FlowBaseAnnotation", e, t);
}
function assertFlowDeclaration(e, t) {
  assert$1("FlowDeclaration", e, t);
}
function assertFlowPredicate(e, t) {
  assert$1("FlowPredicate", e, t);
}
function assertEnumBody(e, t) {
  assert$1("EnumBody", e, t);
}
function assertEnumMember(e, t) {
  assert$1("EnumMember", e, t);
}
function assertJSX(e, t) {
  assert$1("JSX", e, t);
}
function assertMiscellaneous(e, t) {
  assert$1("Miscellaneous", e, t);
}
function assertTypeScript(e, t) {
  assert$1("TypeScript", e, t);
}
function assertTSTypeElement(e, t) {
  assert$1("TSTypeElement", e, t);
}
function assertTSType(e, t) {
  assert$1("TSType", e, t);
}
function assertTSBaseType(e, t) {
  assert$1("TSBaseType", e, t);
}
function assertNumberLiteral(e, t) {
  (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral"), assert$1("NumberLiteral", e, t);
}
function assertRegexLiteral(e, t) {
  (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral"), assert$1("RegexLiteral", e, t);
}
function assertRestProperty(e, t) {
  (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement"), assert$1("RestProperty", e, t);
}
function assertSpreadProperty(e, t) {
  (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement"), assert$1("SpreadProperty", e, t);
}
function assertModuleDeclaration(e, t) {
  (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), assert$1("ModuleDeclaration", e, t);
}
var createTypeAnnotationBasedOnTypeof$1 = {}, hasRequiredCreateTypeAnnotationBasedOnTypeof;
function requireCreateTypeAnnotationBasedOnTypeof() {
  if (hasRequiredCreateTypeAnnotationBasedOnTypeof)
    return createTypeAnnotationBasedOnTypeof$1;
  hasRequiredCreateTypeAnnotationBasedOnTypeof = 1, Object.defineProperty(createTypeAnnotationBasedOnTypeof$1, "__esModule", {
    value: !0
  }), createTypeAnnotationBasedOnTypeof$1.default = void 0;
  var e = requireGenerated();
  createTypeAnnotationBasedOnTypeof$1.default = t;
  function t(s) {
    switch (s) {
      case "string":
        return (0, e.stringTypeAnnotation)();
      case "number":
        return (0, e.numberTypeAnnotation)();
      case "undefined":
        return (0, e.voidTypeAnnotation)();
      case "boolean":
        return (0, e.booleanTypeAnnotation)();
      case "function":
        return (0, e.genericTypeAnnotation)((0, e.identifier)("Function"));
      case "object":
        return (0, e.genericTypeAnnotation)((0, e.identifier)("Object"));
      case "symbol":
        return (0, e.genericTypeAnnotation)((0, e.identifier)("Symbol"));
      case "bigint":
        return (0, e.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + s);
  }
  return createTypeAnnotationBasedOnTypeof$1;
}
var createFlowUnionType$1 = {}, removeTypeDuplicates$3 = {};
Object.defineProperty(removeTypeDuplicates$3, "__esModule", {
  value: !0
});
removeTypeDuplicates$3.default = removeTypeDuplicates$2;
var _index$i = generated$3;
function getQualifiedName$1(e) {
  return (0, _index$i.isIdentifier)(e) ? e.name : `${e.id.name}.${getQualifiedName$1(e.qualification)}`;
}
function removeTypeDuplicates$2(e) {
  const t = Array.from(e), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Set(), o = [];
  for (let l = 0; l < t.length; l++) {
    const f = t[l];
    if (f && !(o.indexOf(f) >= 0)) {
      if ((0, _index$i.isAnyTypeAnnotation)(f))
        return [f];
      if ((0, _index$i.isFlowBaseAnnotation)(f)) {
        i.set(f.type, f);
        continue;
      }
      if ((0, _index$i.isUnionTypeAnnotation)(f)) {
        a.has(f.types) || (t.push(...f.types), a.add(f.types));
        continue;
      }
      if ((0, _index$i.isGenericTypeAnnotation)(f)) {
        const y = getQualifiedName$1(f.id);
        if (s.has(y)) {
          let g = s.get(y);
          g.typeParameters ? f.typeParameters && (g.typeParameters.params.push(...f.typeParameters.params), g.typeParameters.params = removeTypeDuplicates$2(g.typeParameters.params)) : g = f.typeParameters;
        } else
          s.set(y, f);
        continue;
      }
      o.push(f);
    }
  }
  for (const [, l] of i)
    o.push(l);
  for (const [, l] of s)
    o.push(l);
  return o;
}
var hasRequiredCreateFlowUnionType;
function requireCreateFlowUnionType() {
  if (hasRequiredCreateFlowUnionType)
    return createFlowUnionType$1;
  hasRequiredCreateFlowUnionType = 1, Object.defineProperty(createFlowUnionType$1, "__esModule", {
    value: !0
  }), createFlowUnionType$1.default = s;
  var e = requireGenerated(), t = removeTypeDuplicates$3;
  function s(i) {
    const a = (0, t.default)(i);
    return a.length === 1 ? a[0] : (0, e.unionTypeAnnotation)(a);
  }
  return createFlowUnionType$1;
}
var createTSUnionType$1 = {}, removeTypeDuplicates$1 = {};
Object.defineProperty(removeTypeDuplicates$1, "__esModule", {
  value: !0
});
removeTypeDuplicates$1.default = removeTypeDuplicates;
var _index$h = generated$3;
function getQualifiedName(e) {
  return (0, _index$h.isIdentifier)(e) ? e.name : `${e.right.name}.${getQualifiedName(e.left)}`;
}
function removeTypeDuplicates(e) {
  const t = Array.from(e), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Set(), o = [];
  for (let l = 0; l < t.length; l++) {
    const f = t[l];
    if (f && !(o.indexOf(f) >= 0)) {
      if ((0, _index$h.isTSAnyKeyword)(f))
        return [f];
      if ((0, _index$h.isTSBaseType)(f)) {
        i.set(f.type, f);
        continue;
      }
      if ((0, _index$h.isTSUnionType)(f)) {
        a.has(f.types) || (t.push(...f.types), a.add(f.types));
        continue;
      }
      if ((0, _index$h.isTSTypeReference)(f) && f.typeParameters) {
        const y = getQualifiedName(f.typeName);
        if (s.has(y)) {
          let g = s.get(y);
          g.typeParameters ? f.typeParameters && (g.typeParameters.params.push(...f.typeParameters.params), g.typeParameters.params = removeTypeDuplicates(g.typeParameters.params)) : g = f.typeParameters;
        } else
          s.set(y, f);
        continue;
      }
      o.push(f);
    }
  }
  for (const [, l] of i)
    o.push(l);
  for (const [, l] of s)
    o.push(l);
  return o;
}
var hasRequiredCreateTSUnionType;
function requireCreateTSUnionType() {
  if (hasRequiredCreateTSUnionType)
    return createTSUnionType$1;
  hasRequiredCreateTSUnionType = 1, Object.defineProperty(createTSUnionType$1, "__esModule", {
    value: !0
  }), createTSUnionType$1.default = i;
  var e = requireGenerated(), t = removeTypeDuplicates$1, s = generated$3;
  function i(a) {
    const o = a.map((f) => (0, s.isTSTypeAnnotation)(f) ? f.typeAnnotation : f), l = (0, t.default)(o);
    return l.length === 1 ? l[0] : (0, e.tsUnionType)(l);
  }
  return createTSUnionType$1;
}
var uppercase = {}, hasRequiredUppercase;
function requireUppercase() {
  return hasRequiredUppercase || (hasRequiredUppercase = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "AnyTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.anyTypeAnnotation;
      }
    }), Object.defineProperty(e, "ArgumentPlaceholder", {
      enumerable: !0,
      get: function() {
        return t.argumentPlaceholder;
      }
    }), Object.defineProperty(e, "ArrayExpression", {
      enumerable: !0,
      get: function() {
        return t.arrayExpression;
      }
    }), Object.defineProperty(e, "ArrayPattern", {
      enumerable: !0,
      get: function() {
        return t.arrayPattern;
      }
    }), Object.defineProperty(e, "ArrayTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.arrayTypeAnnotation;
      }
    }), Object.defineProperty(e, "ArrowFunctionExpression", {
      enumerable: !0,
      get: function() {
        return t.arrowFunctionExpression;
      }
    }), Object.defineProperty(e, "AssignmentExpression", {
      enumerable: !0,
      get: function() {
        return t.assignmentExpression;
      }
    }), Object.defineProperty(e, "AssignmentPattern", {
      enumerable: !0,
      get: function() {
        return t.assignmentPattern;
      }
    }), Object.defineProperty(e, "AwaitExpression", {
      enumerable: !0,
      get: function() {
        return t.awaitExpression;
      }
    }), Object.defineProperty(e, "BigIntLiteral", {
      enumerable: !0,
      get: function() {
        return t.bigIntLiteral;
      }
    }), Object.defineProperty(e, "BinaryExpression", {
      enumerable: !0,
      get: function() {
        return t.binaryExpression;
      }
    }), Object.defineProperty(e, "BindExpression", {
      enumerable: !0,
      get: function() {
        return t.bindExpression;
      }
    }), Object.defineProperty(e, "BlockStatement", {
      enumerable: !0,
      get: function() {
        return t.blockStatement;
      }
    }), Object.defineProperty(e, "BooleanLiteral", {
      enumerable: !0,
      get: function() {
        return t.booleanLiteral;
      }
    }), Object.defineProperty(e, "BooleanLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.booleanLiteralTypeAnnotation;
      }
    }), Object.defineProperty(e, "BooleanTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.booleanTypeAnnotation;
      }
    }), Object.defineProperty(e, "BreakStatement", {
      enumerable: !0,
      get: function() {
        return t.breakStatement;
      }
    }), Object.defineProperty(e, "CallExpression", {
      enumerable: !0,
      get: function() {
        return t.callExpression;
      }
    }), Object.defineProperty(e, "CatchClause", {
      enumerable: !0,
      get: function() {
        return t.catchClause;
      }
    }), Object.defineProperty(e, "ClassAccessorProperty", {
      enumerable: !0,
      get: function() {
        return t.classAccessorProperty;
      }
    }), Object.defineProperty(e, "ClassBody", {
      enumerable: !0,
      get: function() {
        return t.classBody;
      }
    }), Object.defineProperty(e, "ClassDeclaration", {
      enumerable: !0,
      get: function() {
        return t.classDeclaration;
      }
    }), Object.defineProperty(e, "ClassExpression", {
      enumerable: !0,
      get: function() {
        return t.classExpression;
      }
    }), Object.defineProperty(e, "ClassImplements", {
      enumerable: !0,
      get: function() {
        return t.classImplements;
      }
    }), Object.defineProperty(e, "ClassMethod", {
      enumerable: !0,
      get: function() {
        return t.classMethod;
      }
    }), Object.defineProperty(e, "ClassPrivateMethod", {
      enumerable: !0,
      get: function() {
        return t.classPrivateMethod;
      }
    }), Object.defineProperty(e, "ClassPrivateProperty", {
      enumerable: !0,
      get: function() {
        return t.classPrivateProperty;
      }
    }), Object.defineProperty(e, "ClassProperty", {
      enumerable: !0,
      get: function() {
        return t.classProperty;
      }
    }), Object.defineProperty(e, "ConditionalExpression", {
      enumerable: !0,
      get: function() {
        return t.conditionalExpression;
      }
    }), Object.defineProperty(e, "ContinueStatement", {
      enumerable: !0,
      get: function() {
        return t.continueStatement;
      }
    }), Object.defineProperty(e, "DebuggerStatement", {
      enumerable: !0,
      get: function() {
        return t.debuggerStatement;
      }
    }), Object.defineProperty(e, "DecimalLiteral", {
      enumerable: !0,
      get: function() {
        return t.decimalLiteral;
      }
    }), Object.defineProperty(e, "DeclareClass", {
      enumerable: !0,
      get: function() {
        return t.declareClass;
      }
    }), Object.defineProperty(e, "DeclareExportAllDeclaration", {
      enumerable: !0,
      get: function() {
        return t.declareExportAllDeclaration;
      }
    }), Object.defineProperty(e, "DeclareExportDeclaration", {
      enumerable: !0,
      get: function() {
        return t.declareExportDeclaration;
      }
    }), Object.defineProperty(e, "DeclareFunction", {
      enumerable: !0,
      get: function() {
        return t.declareFunction;
      }
    }), Object.defineProperty(e, "DeclareInterface", {
      enumerable: !0,
      get: function() {
        return t.declareInterface;
      }
    }), Object.defineProperty(e, "DeclareModule", {
      enumerable: !0,
      get: function() {
        return t.declareModule;
      }
    }), Object.defineProperty(e, "DeclareModuleExports", {
      enumerable: !0,
      get: function() {
        return t.declareModuleExports;
      }
    }), Object.defineProperty(e, "DeclareOpaqueType", {
      enumerable: !0,
      get: function() {
        return t.declareOpaqueType;
      }
    }), Object.defineProperty(e, "DeclareTypeAlias", {
      enumerable: !0,
      get: function() {
        return t.declareTypeAlias;
      }
    }), Object.defineProperty(e, "DeclareVariable", {
      enumerable: !0,
      get: function() {
        return t.declareVariable;
      }
    }), Object.defineProperty(e, "DeclaredPredicate", {
      enumerable: !0,
      get: function() {
        return t.declaredPredicate;
      }
    }), Object.defineProperty(e, "Decorator", {
      enumerable: !0,
      get: function() {
        return t.decorator;
      }
    }), Object.defineProperty(e, "Directive", {
      enumerable: !0,
      get: function() {
        return t.directive;
      }
    }), Object.defineProperty(e, "DirectiveLiteral", {
      enumerable: !0,
      get: function() {
        return t.directiveLiteral;
      }
    }), Object.defineProperty(e, "DoExpression", {
      enumerable: !0,
      get: function() {
        return t.doExpression;
      }
    }), Object.defineProperty(e, "DoWhileStatement", {
      enumerable: !0,
      get: function() {
        return t.doWhileStatement;
      }
    }), Object.defineProperty(e, "EmptyStatement", {
      enumerable: !0,
      get: function() {
        return t.emptyStatement;
      }
    }), Object.defineProperty(e, "EmptyTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.emptyTypeAnnotation;
      }
    }), Object.defineProperty(e, "EnumBooleanBody", {
      enumerable: !0,
      get: function() {
        return t.enumBooleanBody;
      }
    }), Object.defineProperty(e, "EnumBooleanMember", {
      enumerable: !0,
      get: function() {
        return t.enumBooleanMember;
      }
    }), Object.defineProperty(e, "EnumDeclaration", {
      enumerable: !0,
      get: function() {
        return t.enumDeclaration;
      }
    }), Object.defineProperty(e, "EnumDefaultedMember", {
      enumerable: !0,
      get: function() {
        return t.enumDefaultedMember;
      }
    }), Object.defineProperty(e, "EnumNumberBody", {
      enumerable: !0,
      get: function() {
        return t.enumNumberBody;
      }
    }), Object.defineProperty(e, "EnumNumberMember", {
      enumerable: !0,
      get: function() {
        return t.enumNumberMember;
      }
    }), Object.defineProperty(e, "EnumStringBody", {
      enumerable: !0,
      get: function() {
        return t.enumStringBody;
      }
    }), Object.defineProperty(e, "EnumStringMember", {
      enumerable: !0,
      get: function() {
        return t.enumStringMember;
      }
    }), Object.defineProperty(e, "EnumSymbolBody", {
      enumerable: !0,
      get: function() {
        return t.enumSymbolBody;
      }
    }), Object.defineProperty(e, "ExistsTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.existsTypeAnnotation;
      }
    }), Object.defineProperty(e, "ExportAllDeclaration", {
      enumerable: !0,
      get: function() {
        return t.exportAllDeclaration;
      }
    }), Object.defineProperty(e, "ExportDefaultDeclaration", {
      enumerable: !0,
      get: function() {
        return t.exportDefaultDeclaration;
      }
    }), Object.defineProperty(e, "ExportDefaultSpecifier", {
      enumerable: !0,
      get: function() {
        return t.exportDefaultSpecifier;
      }
    }), Object.defineProperty(e, "ExportNamedDeclaration", {
      enumerable: !0,
      get: function() {
        return t.exportNamedDeclaration;
      }
    }), Object.defineProperty(e, "ExportNamespaceSpecifier", {
      enumerable: !0,
      get: function() {
        return t.exportNamespaceSpecifier;
      }
    }), Object.defineProperty(e, "ExportSpecifier", {
      enumerable: !0,
      get: function() {
        return t.exportSpecifier;
      }
    }), Object.defineProperty(e, "ExpressionStatement", {
      enumerable: !0,
      get: function() {
        return t.expressionStatement;
      }
    }), Object.defineProperty(e, "File", {
      enumerable: !0,
      get: function() {
        return t.file;
      }
    }), Object.defineProperty(e, "ForInStatement", {
      enumerable: !0,
      get: function() {
        return t.forInStatement;
      }
    }), Object.defineProperty(e, "ForOfStatement", {
      enumerable: !0,
      get: function() {
        return t.forOfStatement;
      }
    }), Object.defineProperty(e, "ForStatement", {
      enumerable: !0,
      get: function() {
        return t.forStatement;
      }
    }), Object.defineProperty(e, "FunctionDeclaration", {
      enumerable: !0,
      get: function() {
        return t.functionDeclaration;
      }
    }), Object.defineProperty(e, "FunctionExpression", {
      enumerable: !0,
      get: function() {
        return t.functionExpression;
      }
    }), Object.defineProperty(e, "FunctionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.functionTypeAnnotation;
      }
    }), Object.defineProperty(e, "FunctionTypeParam", {
      enumerable: !0,
      get: function() {
        return t.functionTypeParam;
      }
    }), Object.defineProperty(e, "GenericTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.genericTypeAnnotation;
      }
    }), Object.defineProperty(e, "Identifier", {
      enumerable: !0,
      get: function() {
        return t.identifier;
      }
    }), Object.defineProperty(e, "IfStatement", {
      enumerable: !0,
      get: function() {
        return t.ifStatement;
      }
    }), Object.defineProperty(e, "Import", {
      enumerable: !0,
      get: function() {
        return t.import;
      }
    }), Object.defineProperty(e, "ImportAttribute", {
      enumerable: !0,
      get: function() {
        return t.importAttribute;
      }
    }), Object.defineProperty(e, "ImportDeclaration", {
      enumerable: !0,
      get: function() {
        return t.importDeclaration;
      }
    }), Object.defineProperty(e, "ImportDefaultSpecifier", {
      enumerable: !0,
      get: function() {
        return t.importDefaultSpecifier;
      }
    }), Object.defineProperty(e, "ImportExpression", {
      enumerable: !0,
      get: function() {
        return t.importExpression;
      }
    }), Object.defineProperty(e, "ImportNamespaceSpecifier", {
      enumerable: !0,
      get: function() {
        return t.importNamespaceSpecifier;
      }
    }), Object.defineProperty(e, "ImportSpecifier", {
      enumerable: !0,
      get: function() {
        return t.importSpecifier;
      }
    }), Object.defineProperty(e, "IndexedAccessType", {
      enumerable: !0,
      get: function() {
        return t.indexedAccessType;
      }
    }), Object.defineProperty(e, "InferredPredicate", {
      enumerable: !0,
      get: function() {
        return t.inferredPredicate;
      }
    }), Object.defineProperty(e, "InterfaceDeclaration", {
      enumerable: !0,
      get: function() {
        return t.interfaceDeclaration;
      }
    }), Object.defineProperty(e, "InterfaceExtends", {
      enumerable: !0,
      get: function() {
        return t.interfaceExtends;
      }
    }), Object.defineProperty(e, "InterfaceTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.interfaceTypeAnnotation;
      }
    }), Object.defineProperty(e, "InterpreterDirective", {
      enumerable: !0,
      get: function() {
        return t.interpreterDirective;
      }
    }), Object.defineProperty(e, "IntersectionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.intersectionTypeAnnotation;
      }
    }), Object.defineProperty(e, "JSXAttribute", {
      enumerable: !0,
      get: function() {
        return t.jsxAttribute;
      }
    }), Object.defineProperty(e, "JSXClosingElement", {
      enumerable: !0,
      get: function() {
        return t.jsxClosingElement;
      }
    }), Object.defineProperty(e, "JSXClosingFragment", {
      enumerable: !0,
      get: function() {
        return t.jsxClosingFragment;
      }
    }), Object.defineProperty(e, "JSXElement", {
      enumerable: !0,
      get: function() {
        return t.jsxElement;
      }
    }), Object.defineProperty(e, "JSXEmptyExpression", {
      enumerable: !0,
      get: function() {
        return t.jsxEmptyExpression;
      }
    }), Object.defineProperty(e, "JSXExpressionContainer", {
      enumerable: !0,
      get: function() {
        return t.jsxExpressionContainer;
      }
    }), Object.defineProperty(e, "JSXFragment", {
      enumerable: !0,
      get: function() {
        return t.jsxFragment;
      }
    }), Object.defineProperty(e, "JSXIdentifier", {
      enumerable: !0,
      get: function() {
        return t.jsxIdentifier;
      }
    }), Object.defineProperty(e, "JSXMemberExpression", {
      enumerable: !0,
      get: function() {
        return t.jsxMemberExpression;
      }
    }), Object.defineProperty(e, "JSXNamespacedName", {
      enumerable: !0,
      get: function() {
        return t.jsxNamespacedName;
      }
    }), Object.defineProperty(e, "JSXOpeningElement", {
      enumerable: !0,
      get: function() {
        return t.jsxOpeningElement;
      }
    }), Object.defineProperty(e, "JSXOpeningFragment", {
      enumerable: !0,
      get: function() {
        return t.jsxOpeningFragment;
      }
    }), Object.defineProperty(e, "JSXSpreadAttribute", {
      enumerable: !0,
      get: function() {
        return t.jsxSpreadAttribute;
      }
    }), Object.defineProperty(e, "JSXSpreadChild", {
      enumerable: !0,
      get: function() {
        return t.jsxSpreadChild;
      }
    }), Object.defineProperty(e, "JSXText", {
      enumerable: !0,
      get: function() {
        return t.jsxText;
      }
    }), Object.defineProperty(e, "LabeledStatement", {
      enumerable: !0,
      get: function() {
        return t.labeledStatement;
      }
    }), Object.defineProperty(e, "LogicalExpression", {
      enumerable: !0,
      get: function() {
        return t.logicalExpression;
      }
    }), Object.defineProperty(e, "MemberExpression", {
      enumerable: !0,
      get: function() {
        return t.memberExpression;
      }
    }), Object.defineProperty(e, "MetaProperty", {
      enumerable: !0,
      get: function() {
        return t.metaProperty;
      }
    }), Object.defineProperty(e, "MixedTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.mixedTypeAnnotation;
      }
    }), Object.defineProperty(e, "ModuleExpression", {
      enumerable: !0,
      get: function() {
        return t.moduleExpression;
      }
    }), Object.defineProperty(e, "NewExpression", {
      enumerable: !0,
      get: function() {
        return t.newExpression;
      }
    }), Object.defineProperty(e, "Noop", {
      enumerable: !0,
      get: function() {
        return t.noop;
      }
    }), Object.defineProperty(e, "NullLiteral", {
      enumerable: !0,
      get: function() {
        return t.nullLiteral;
      }
    }), Object.defineProperty(e, "NullLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.nullLiteralTypeAnnotation;
      }
    }), Object.defineProperty(e, "NullableTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.nullableTypeAnnotation;
      }
    }), Object.defineProperty(e, "NumberLiteral", {
      enumerable: !0,
      get: function() {
        return t.numberLiteral;
      }
    }), Object.defineProperty(e, "NumberLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.numberLiteralTypeAnnotation;
      }
    }), Object.defineProperty(e, "NumberTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.numberTypeAnnotation;
      }
    }), Object.defineProperty(e, "NumericLiteral", {
      enumerable: !0,
      get: function() {
        return t.numericLiteral;
      }
    }), Object.defineProperty(e, "ObjectExpression", {
      enumerable: !0,
      get: function() {
        return t.objectExpression;
      }
    }), Object.defineProperty(e, "ObjectMethod", {
      enumerable: !0,
      get: function() {
        return t.objectMethod;
      }
    }), Object.defineProperty(e, "ObjectPattern", {
      enumerable: !0,
      get: function() {
        return t.objectPattern;
      }
    }), Object.defineProperty(e, "ObjectProperty", {
      enumerable: !0,
      get: function() {
        return t.objectProperty;
      }
    }), Object.defineProperty(e, "ObjectTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.objectTypeAnnotation;
      }
    }), Object.defineProperty(e, "ObjectTypeCallProperty", {
      enumerable: !0,
      get: function() {
        return t.objectTypeCallProperty;
      }
    }), Object.defineProperty(e, "ObjectTypeIndexer", {
      enumerable: !0,
      get: function() {
        return t.objectTypeIndexer;
      }
    }), Object.defineProperty(e, "ObjectTypeInternalSlot", {
      enumerable: !0,
      get: function() {
        return t.objectTypeInternalSlot;
      }
    }), Object.defineProperty(e, "ObjectTypeProperty", {
      enumerable: !0,
      get: function() {
        return t.objectTypeProperty;
      }
    }), Object.defineProperty(e, "ObjectTypeSpreadProperty", {
      enumerable: !0,
      get: function() {
        return t.objectTypeSpreadProperty;
      }
    }), Object.defineProperty(e, "OpaqueType", {
      enumerable: !0,
      get: function() {
        return t.opaqueType;
      }
    }), Object.defineProperty(e, "OptionalCallExpression", {
      enumerable: !0,
      get: function() {
        return t.optionalCallExpression;
      }
    }), Object.defineProperty(e, "OptionalIndexedAccessType", {
      enumerable: !0,
      get: function() {
        return t.optionalIndexedAccessType;
      }
    }), Object.defineProperty(e, "OptionalMemberExpression", {
      enumerable: !0,
      get: function() {
        return t.optionalMemberExpression;
      }
    }), Object.defineProperty(e, "ParenthesizedExpression", {
      enumerable: !0,
      get: function() {
        return t.parenthesizedExpression;
      }
    }), Object.defineProperty(e, "PipelineBareFunction", {
      enumerable: !0,
      get: function() {
        return t.pipelineBareFunction;
      }
    }), Object.defineProperty(e, "PipelinePrimaryTopicReference", {
      enumerable: !0,
      get: function() {
        return t.pipelinePrimaryTopicReference;
      }
    }), Object.defineProperty(e, "PipelineTopicExpression", {
      enumerable: !0,
      get: function() {
        return t.pipelineTopicExpression;
      }
    }), Object.defineProperty(e, "Placeholder", {
      enumerable: !0,
      get: function() {
        return t.placeholder;
      }
    }), Object.defineProperty(e, "PrivateName", {
      enumerable: !0,
      get: function() {
        return t.privateName;
      }
    }), Object.defineProperty(e, "Program", {
      enumerable: !0,
      get: function() {
        return t.program;
      }
    }), Object.defineProperty(e, "QualifiedTypeIdentifier", {
      enumerable: !0,
      get: function() {
        return t.qualifiedTypeIdentifier;
      }
    }), Object.defineProperty(e, "RecordExpression", {
      enumerable: !0,
      get: function() {
        return t.recordExpression;
      }
    }), Object.defineProperty(e, "RegExpLiteral", {
      enumerable: !0,
      get: function() {
        return t.regExpLiteral;
      }
    }), Object.defineProperty(e, "RegexLiteral", {
      enumerable: !0,
      get: function() {
        return t.regexLiteral;
      }
    }), Object.defineProperty(e, "RestElement", {
      enumerable: !0,
      get: function() {
        return t.restElement;
      }
    }), Object.defineProperty(e, "RestProperty", {
      enumerable: !0,
      get: function() {
        return t.restProperty;
      }
    }), Object.defineProperty(e, "ReturnStatement", {
      enumerable: !0,
      get: function() {
        return t.returnStatement;
      }
    }), Object.defineProperty(e, "SequenceExpression", {
      enumerable: !0,
      get: function() {
        return t.sequenceExpression;
      }
    }), Object.defineProperty(e, "SpreadElement", {
      enumerable: !0,
      get: function() {
        return t.spreadElement;
      }
    }), Object.defineProperty(e, "SpreadProperty", {
      enumerable: !0,
      get: function() {
        return t.spreadProperty;
      }
    }), Object.defineProperty(e, "StaticBlock", {
      enumerable: !0,
      get: function() {
        return t.staticBlock;
      }
    }), Object.defineProperty(e, "StringLiteral", {
      enumerable: !0,
      get: function() {
        return t.stringLiteral;
      }
    }), Object.defineProperty(e, "StringLiteralTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.stringLiteralTypeAnnotation;
      }
    }), Object.defineProperty(e, "StringTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.stringTypeAnnotation;
      }
    }), Object.defineProperty(e, "Super", {
      enumerable: !0,
      get: function() {
        return t.super;
      }
    }), Object.defineProperty(e, "SwitchCase", {
      enumerable: !0,
      get: function() {
        return t.switchCase;
      }
    }), Object.defineProperty(e, "SwitchStatement", {
      enumerable: !0,
      get: function() {
        return t.switchStatement;
      }
    }), Object.defineProperty(e, "SymbolTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.symbolTypeAnnotation;
      }
    }), Object.defineProperty(e, "TSAnyKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsAnyKeyword;
      }
    }), Object.defineProperty(e, "TSArrayType", {
      enumerable: !0,
      get: function() {
        return t.tsArrayType;
      }
    }), Object.defineProperty(e, "TSAsExpression", {
      enumerable: !0,
      get: function() {
        return t.tsAsExpression;
      }
    }), Object.defineProperty(e, "TSBigIntKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsBigIntKeyword;
      }
    }), Object.defineProperty(e, "TSBooleanKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsBooleanKeyword;
      }
    }), Object.defineProperty(e, "TSCallSignatureDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsCallSignatureDeclaration;
      }
    }), Object.defineProperty(e, "TSConditionalType", {
      enumerable: !0,
      get: function() {
        return t.tsConditionalType;
      }
    }), Object.defineProperty(e, "TSConstructSignatureDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsConstructSignatureDeclaration;
      }
    }), Object.defineProperty(e, "TSConstructorType", {
      enumerable: !0,
      get: function() {
        return t.tsConstructorType;
      }
    }), Object.defineProperty(e, "TSDeclareFunction", {
      enumerable: !0,
      get: function() {
        return t.tsDeclareFunction;
      }
    }), Object.defineProperty(e, "TSDeclareMethod", {
      enumerable: !0,
      get: function() {
        return t.tsDeclareMethod;
      }
    }), Object.defineProperty(e, "TSEnumDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsEnumDeclaration;
      }
    }), Object.defineProperty(e, "TSEnumMember", {
      enumerable: !0,
      get: function() {
        return t.tsEnumMember;
      }
    }), Object.defineProperty(e, "TSExportAssignment", {
      enumerable: !0,
      get: function() {
        return t.tsExportAssignment;
      }
    }), Object.defineProperty(e, "TSExpressionWithTypeArguments", {
      enumerable: !0,
      get: function() {
        return t.tsExpressionWithTypeArguments;
      }
    }), Object.defineProperty(e, "TSExternalModuleReference", {
      enumerable: !0,
      get: function() {
        return t.tsExternalModuleReference;
      }
    }), Object.defineProperty(e, "TSFunctionType", {
      enumerable: !0,
      get: function() {
        return t.tsFunctionType;
      }
    }), Object.defineProperty(e, "TSImportEqualsDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsImportEqualsDeclaration;
      }
    }), Object.defineProperty(e, "TSImportType", {
      enumerable: !0,
      get: function() {
        return t.tsImportType;
      }
    }), Object.defineProperty(e, "TSIndexSignature", {
      enumerable: !0,
      get: function() {
        return t.tsIndexSignature;
      }
    }), Object.defineProperty(e, "TSIndexedAccessType", {
      enumerable: !0,
      get: function() {
        return t.tsIndexedAccessType;
      }
    }), Object.defineProperty(e, "TSInferType", {
      enumerable: !0,
      get: function() {
        return t.tsInferType;
      }
    }), Object.defineProperty(e, "TSInstantiationExpression", {
      enumerable: !0,
      get: function() {
        return t.tsInstantiationExpression;
      }
    }), Object.defineProperty(e, "TSInterfaceBody", {
      enumerable: !0,
      get: function() {
        return t.tsInterfaceBody;
      }
    }), Object.defineProperty(e, "TSInterfaceDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsInterfaceDeclaration;
      }
    }), Object.defineProperty(e, "TSIntersectionType", {
      enumerable: !0,
      get: function() {
        return t.tsIntersectionType;
      }
    }), Object.defineProperty(e, "TSIntrinsicKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsIntrinsicKeyword;
      }
    }), Object.defineProperty(e, "TSLiteralType", {
      enumerable: !0,
      get: function() {
        return t.tsLiteralType;
      }
    }), Object.defineProperty(e, "TSMappedType", {
      enumerable: !0,
      get: function() {
        return t.tsMappedType;
      }
    }), Object.defineProperty(e, "TSMethodSignature", {
      enumerable: !0,
      get: function() {
        return t.tsMethodSignature;
      }
    }), Object.defineProperty(e, "TSModuleBlock", {
      enumerable: !0,
      get: function() {
        return t.tsModuleBlock;
      }
    }), Object.defineProperty(e, "TSModuleDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsModuleDeclaration;
      }
    }), Object.defineProperty(e, "TSNamedTupleMember", {
      enumerable: !0,
      get: function() {
        return t.tsNamedTupleMember;
      }
    }), Object.defineProperty(e, "TSNamespaceExportDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsNamespaceExportDeclaration;
      }
    }), Object.defineProperty(e, "TSNeverKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsNeverKeyword;
      }
    }), Object.defineProperty(e, "TSNonNullExpression", {
      enumerable: !0,
      get: function() {
        return t.tsNonNullExpression;
      }
    }), Object.defineProperty(e, "TSNullKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsNullKeyword;
      }
    }), Object.defineProperty(e, "TSNumberKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsNumberKeyword;
      }
    }), Object.defineProperty(e, "TSObjectKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsObjectKeyword;
      }
    }), Object.defineProperty(e, "TSOptionalType", {
      enumerable: !0,
      get: function() {
        return t.tsOptionalType;
      }
    }), Object.defineProperty(e, "TSParameterProperty", {
      enumerable: !0,
      get: function() {
        return t.tsParameterProperty;
      }
    }), Object.defineProperty(e, "TSParenthesizedType", {
      enumerable: !0,
      get: function() {
        return t.tsParenthesizedType;
      }
    }), Object.defineProperty(e, "TSPropertySignature", {
      enumerable: !0,
      get: function() {
        return t.tsPropertySignature;
      }
    }), Object.defineProperty(e, "TSQualifiedName", {
      enumerable: !0,
      get: function() {
        return t.tsQualifiedName;
      }
    }), Object.defineProperty(e, "TSRestType", {
      enumerable: !0,
      get: function() {
        return t.tsRestType;
      }
    }), Object.defineProperty(e, "TSSatisfiesExpression", {
      enumerable: !0,
      get: function() {
        return t.tsSatisfiesExpression;
      }
    }), Object.defineProperty(e, "TSStringKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsStringKeyword;
      }
    }), Object.defineProperty(e, "TSSymbolKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsSymbolKeyword;
      }
    }), Object.defineProperty(e, "TSThisType", {
      enumerable: !0,
      get: function() {
        return t.tsThisType;
      }
    }), Object.defineProperty(e, "TSTupleType", {
      enumerable: !0,
      get: function() {
        return t.tsTupleType;
      }
    }), Object.defineProperty(e, "TSTypeAliasDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsTypeAliasDeclaration;
      }
    }), Object.defineProperty(e, "TSTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.tsTypeAnnotation;
      }
    }), Object.defineProperty(e, "TSTypeAssertion", {
      enumerable: !0,
      get: function() {
        return t.tsTypeAssertion;
      }
    }), Object.defineProperty(e, "TSTypeLiteral", {
      enumerable: !0,
      get: function() {
        return t.tsTypeLiteral;
      }
    }), Object.defineProperty(e, "TSTypeOperator", {
      enumerable: !0,
      get: function() {
        return t.tsTypeOperator;
      }
    }), Object.defineProperty(e, "TSTypeParameter", {
      enumerable: !0,
      get: function() {
        return t.tsTypeParameter;
      }
    }), Object.defineProperty(e, "TSTypeParameterDeclaration", {
      enumerable: !0,
      get: function() {
        return t.tsTypeParameterDeclaration;
      }
    }), Object.defineProperty(e, "TSTypeParameterInstantiation", {
      enumerable: !0,
      get: function() {
        return t.tsTypeParameterInstantiation;
      }
    }), Object.defineProperty(e, "TSTypePredicate", {
      enumerable: !0,
      get: function() {
        return t.tsTypePredicate;
      }
    }), Object.defineProperty(e, "TSTypeQuery", {
      enumerable: !0,
      get: function() {
        return t.tsTypeQuery;
      }
    }), Object.defineProperty(e, "TSTypeReference", {
      enumerable: !0,
      get: function() {
        return t.tsTypeReference;
      }
    }), Object.defineProperty(e, "TSUndefinedKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsUndefinedKeyword;
      }
    }), Object.defineProperty(e, "TSUnionType", {
      enumerable: !0,
      get: function() {
        return t.tsUnionType;
      }
    }), Object.defineProperty(e, "TSUnknownKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsUnknownKeyword;
      }
    }), Object.defineProperty(e, "TSVoidKeyword", {
      enumerable: !0,
      get: function() {
        return t.tsVoidKeyword;
      }
    }), Object.defineProperty(e, "TaggedTemplateExpression", {
      enumerable: !0,
      get: function() {
        return t.taggedTemplateExpression;
      }
    }), Object.defineProperty(e, "TemplateElement", {
      enumerable: !0,
      get: function() {
        return t.templateElement;
      }
    }), Object.defineProperty(e, "TemplateLiteral", {
      enumerable: !0,
      get: function() {
        return t.templateLiteral;
      }
    }), Object.defineProperty(e, "ThisExpression", {
      enumerable: !0,
      get: function() {
        return t.thisExpression;
      }
    }), Object.defineProperty(e, "ThisTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.thisTypeAnnotation;
      }
    }), Object.defineProperty(e, "ThrowStatement", {
      enumerable: !0,
      get: function() {
        return t.throwStatement;
      }
    }), Object.defineProperty(e, "TopicReference", {
      enumerable: !0,
      get: function() {
        return t.topicReference;
      }
    }), Object.defineProperty(e, "TryStatement", {
      enumerable: !0,
      get: function() {
        return t.tryStatement;
      }
    }), Object.defineProperty(e, "TupleExpression", {
      enumerable: !0,
      get: function() {
        return t.tupleExpression;
      }
    }), Object.defineProperty(e, "TupleTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.tupleTypeAnnotation;
      }
    }), Object.defineProperty(e, "TypeAlias", {
      enumerable: !0,
      get: function() {
        return t.typeAlias;
      }
    }), Object.defineProperty(e, "TypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.typeAnnotation;
      }
    }), Object.defineProperty(e, "TypeCastExpression", {
      enumerable: !0,
      get: function() {
        return t.typeCastExpression;
      }
    }), Object.defineProperty(e, "TypeParameter", {
      enumerable: !0,
      get: function() {
        return t.typeParameter;
      }
    }), Object.defineProperty(e, "TypeParameterDeclaration", {
      enumerable: !0,
      get: function() {
        return t.typeParameterDeclaration;
      }
    }), Object.defineProperty(e, "TypeParameterInstantiation", {
      enumerable: !0,
      get: function() {
        return t.typeParameterInstantiation;
      }
    }), Object.defineProperty(e, "TypeofTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.typeofTypeAnnotation;
      }
    }), Object.defineProperty(e, "UnaryExpression", {
      enumerable: !0,
      get: function() {
        return t.unaryExpression;
      }
    }), Object.defineProperty(e, "UnionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.unionTypeAnnotation;
      }
    }), Object.defineProperty(e, "UpdateExpression", {
      enumerable: !0,
      get: function() {
        return t.updateExpression;
      }
    }), Object.defineProperty(e, "V8IntrinsicIdentifier", {
      enumerable: !0,
      get: function() {
        return t.v8IntrinsicIdentifier;
      }
    }), Object.defineProperty(e, "VariableDeclaration", {
      enumerable: !0,
      get: function() {
        return t.variableDeclaration;
      }
    }), Object.defineProperty(e, "VariableDeclarator", {
      enumerable: !0,
      get: function() {
        return t.variableDeclarator;
      }
    }), Object.defineProperty(e, "Variance", {
      enumerable: !0,
      get: function() {
        return t.variance;
      }
    }), Object.defineProperty(e, "VoidTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return t.voidTypeAnnotation;
      }
    }), Object.defineProperty(e, "WhileStatement", {
      enumerable: !0,
      get: function() {
        return t.whileStatement;
      }
    }), Object.defineProperty(e, "WithStatement", {
      enumerable: !0,
      get: function() {
        return t.withStatement;
      }
    }), Object.defineProperty(e, "YieldExpression", {
      enumerable: !0,
      get: function() {
        return t.yieldExpression;
      }
    });
    var t = requireGenerated();
  }(uppercase)), uppercase;
}
var productions = {}, hasRequiredProductions;
function requireProductions() {
  if (hasRequiredProductions)
    return productions;
  hasRequiredProductions = 1, Object.defineProperty(productions, "__esModule", {
    value: !0
  }), productions.buildUndefinedNode = t;
  var e = requireGenerated();
  function t() {
    return (0, e.unaryExpression)("void", (0, e.numericLiteral)(0), !0);
  }
  return productions;
}
var cloneNode$5 = {};
Object.defineProperty(cloneNode$5, "__esModule", {
  value: !0
});
cloneNode$5.default = cloneNode$4;
var _index$g = requireDefinitions(), _index2$2 = generated$3;
const has$1 = Function.call.bind(Object.prototype.hasOwnProperty);
function cloneIfNode(e, t, s, i) {
  return e && typeof e.type == "string" ? cloneNodeInternal(e, t, s, i) : e;
}
function cloneIfNodeOrArray(e, t, s, i) {
  return Array.isArray(e) ? e.map((a) => cloneIfNode(a, t, s, i)) : cloneIfNode(e, t, s, i);
}
function cloneNode$4(e, t = !0, s = !1) {
  return cloneNodeInternal(e, t, s, /* @__PURE__ */ new Map());
}
function cloneNodeInternal(e, t = !0, s = !1, i) {
  if (!e)
    return e;
  const {
    type: a
  } = e, o = {
    type: e.type
  };
  if ((0, _index2$2.isIdentifier)(e))
    o.name = e.name, has$1(e, "optional") && typeof e.optional == "boolean" && (o.optional = e.optional), has$1(e, "typeAnnotation") && (o.typeAnnotation = t ? cloneIfNodeOrArray(e.typeAnnotation, !0, s, i) : e.typeAnnotation);
  else if (has$1(_index$g.NODE_FIELDS, a))
    for (const l of Object.keys(_index$g.NODE_FIELDS[a]))
      has$1(e, l) && (t ? o[l] = (0, _index2$2.isFile)(e) && l === "comments" ? maybeCloneComments(e.comments, t, s, i) : cloneIfNodeOrArray(e[l], !0, s, i) : o[l] = e[l]);
  else
    throw new Error(`Unknown node type: "${a}"`);
  return has$1(e, "loc") && (s ? o.loc = null : o.loc = e.loc), has$1(e, "leadingComments") && (o.leadingComments = maybeCloneComments(e.leadingComments, t, s, i)), has$1(e, "innerComments") && (o.innerComments = maybeCloneComments(e.innerComments, t, s, i)), has$1(e, "trailingComments") && (o.trailingComments = maybeCloneComments(e.trailingComments, t, s, i)), has$1(e, "extra") && (o.extra = Object.assign({}, e.extra)), o;
}
function maybeCloneComments(e, t, s, i) {
  return !e || !t ? e : e.map((a) => {
    const o = i.get(a);
    if (o)
      return o;
    const {
      type: l,
      value: f,
      loc: y
    } = a, g = {
      type: l,
      value: f,
      loc: y
    };
    return s && (g.loc = null), i.set(a, g), g;
  });
}
var clone$1 = {};
Object.defineProperty(clone$1, "__esModule", {
  value: !0
});
clone$1.default = clone;
var _cloneNode$4 = cloneNode$5;
function clone(e) {
  return (0, _cloneNode$4.default)(e, !1);
}
var cloneDeep$1 = {};
Object.defineProperty(cloneDeep$1, "__esModule", {
  value: !0
});
cloneDeep$1.default = cloneDeep;
var _cloneNode$3 = cloneNode$5;
function cloneDeep(e) {
  return (0, _cloneNode$3.default)(e);
}
var cloneDeepWithoutLoc$1 = {};
Object.defineProperty(cloneDeepWithoutLoc$1, "__esModule", {
  value: !0
});
cloneDeepWithoutLoc$1.default = cloneDeepWithoutLoc;
var _cloneNode$2 = cloneNode$5;
function cloneDeepWithoutLoc(e) {
  return (0, _cloneNode$2.default)(e, !0, !0);
}
var cloneWithoutLoc$1 = {};
Object.defineProperty(cloneWithoutLoc$1, "__esModule", {
  value: !0
});
cloneWithoutLoc$1.default = cloneWithoutLoc;
var _cloneNode$1 = cloneNode$5;
function cloneWithoutLoc(e) {
  return (0, _cloneNode$1.default)(e, !1, !0);
}
var addComment$2 = {}, addComments$2 = {};
Object.defineProperty(addComments$2, "__esModule", {
  value: !0
});
addComments$2.default = addComments$1;
function addComments$1(e, t, s) {
  if (!s || !e)
    return e;
  const i = `${t}Comments`;
  return e[i] ? t === "leading" ? e[i] = s.concat(e[i]) : e[i].push(...s) : e[i] = s, e;
}
Object.defineProperty(addComment$2, "__esModule", {
  value: !0
});
addComment$2.default = addComment$1;
var _addComments$1 = addComments$2;
function addComment$1(e, t, s, i) {
  return (0, _addComments$1.default)(e, t, [{
    type: i ? "CommentLine" : "CommentBlock",
    value: s
  }]);
}
var inheritInnerComments$1 = {}, inherit$1 = {};
Object.defineProperty(inherit$1, "__esModule", {
  value: !0
});
inherit$1.default = inherit;
function inherit(e, t, s) {
  t && s && (t[e] = Array.from(new Set([].concat(t[e], s[e]).filter(Boolean))));
}
Object.defineProperty(inheritInnerComments$1, "__esModule", {
  value: !0
});
inheritInnerComments$1.default = inheritInnerComments;
var _inherit$2 = inherit$1;
function inheritInnerComments(e, t) {
  (0, _inherit$2.default)("innerComments", e, t);
}
var inheritLeadingComments$1 = {};
Object.defineProperty(inheritLeadingComments$1, "__esModule", {
  value: !0
});
inheritLeadingComments$1.default = inheritLeadingComments;
var _inherit$1 = inherit$1;
function inheritLeadingComments(e, t) {
  (0, _inherit$1.default)("leadingComments", e, t);
}
var inheritsComments$1 = {}, inheritTrailingComments$1 = {};
Object.defineProperty(inheritTrailingComments$1, "__esModule", {
  value: !0
});
inheritTrailingComments$1.default = inheritTrailingComments;
var _inherit = inherit$1;
function inheritTrailingComments(e, t) {
  (0, _inherit.default)("trailingComments", e, t);
}
Object.defineProperty(inheritsComments$1, "__esModule", {
  value: !0
});
inheritsComments$1.default = inheritsComments;
var _inheritTrailingComments = inheritTrailingComments$1, _inheritLeadingComments = inheritLeadingComments$1, _inheritInnerComments = inheritInnerComments$1;
function inheritsComments(e, t) {
  return (0, _inheritTrailingComments.default)(e, t), (0, _inheritLeadingComments.default)(e, t), (0, _inheritInnerComments.default)(e, t), e;
}
var removeComments$1 = {};
Object.defineProperty(removeComments$1, "__esModule", {
  value: !0
});
removeComments$1.default = removeComments;
var _index$f = constants;
function removeComments(e) {
  return _index$f.COMMENT_KEYS.forEach((t) => {
    e[t] = null;
  }), e;
}
var generated = {};
Object.defineProperty(generated, "__esModule", {
  value: !0
});
generated.WHILE_TYPES = generated.USERWHITESPACABLE_TYPES = generated.UNARYLIKE_TYPES = generated.TYPESCRIPT_TYPES = generated.TSTYPE_TYPES = generated.TSTYPEELEMENT_TYPES = generated.TSENTITYNAME_TYPES = generated.TSBASETYPE_TYPES = generated.TERMINATORLESS_TYPES = generated.STATEMENT_TYPES = generated.STANDARDIZED_TYPES = generated.SCOPABLE_TYPES = generated.PUREISH_TYPES = generated.PROPERTY_TYPES = generated.PRIVATE_TYPES = generated.PATTERN_TYPES = generated.PATTERNLIKE_TYPES = generated.OBJECTMEMBER_TYPES = generated.MODULESPECIFIER_TYPES = generated.MODULEDECLARATION_TYPES = generated.MISCELLANEOUS_TYPES = generated.METHOD_TYPES = generated.LVAL_TYPES = generated.LOOP_TYPES = generated.LITERAL_TYPES = generated.JSX_TYPES = generated.IMPORTOREXPORTDECLARATION_TYPES = generated.IMMUTABLE_TYPES = generated.FUNCTION_TYPES = generated.FUNCTIONPARENT_TYPES = generated.FOR_TYPES = generated.FORXSTATEMENT_TYPES = generated.FLOW_TYPES = generated.FLOWTYPE_TYPES = generated.FLOWPREDICATE_TYPES = generated.FLOWDECLARATION_TYPES = generated.FLOWBASEANNOTATION_TYPES = generated.EXPRESSION_TYPES = generated.EXPRESSIONWRAPPER_TYPES = generated.EXPORTDECLARATION_TYPES = generated.ENUMMEMBER_TYPES = generated.ENUMBODY_TYPES = generated.DECLARATION_TYPES = generated.CONDITIONAL_TYPES = generated.COMPLETIONSTATEMENT_TYPES = generated.CLASS_TYPES = generated.BLOCK_TYPES = generated.BLOCKPARENT_TYPES = generated.BINARY_TYPES = generated.ACCESSOR_TYPES = void 0;
var _index$e = requireDefinitions();
generated.STANDARDIZED_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Standardized;
generated.EXPRESSION_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Expression;
generated.BINARY_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Binary;
generated.SCOPABLE_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Scopable;
generated.BLOCKPARENT_TYPES = _index$e.FLIPPED_ALIAS_KEYS.BlockParent;
generated.BLOCK_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Block;
generated.STATEMENT_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Statement;
generated.TERMINATORLESS_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Terminatorless;
generated.COMPLETIONSTATEMENT_TYPES = _index$e.FLIPPED_ALIAS_KEYS.CompletionStatement;
generated.CONDITIONAL_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Conditional;
generated.LOOP_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Loop;
generated.WHILE_TYPES = _index$e.FLIPPED_ALIAS_KEYS.While;
generated.EXPRESSIONWRAPPER_TYPES = _index$e.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
generated.FOR_TYPES = _index$e.FLIPPED_ALIAS_KEYS.For;
generated.FORXSTATEMENT_TYPES = _index$e.FLIPPED_ALIAS_KEYS.ForXStatement;
generated.FUNCTION_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Function;
generated.FUNCTIONPARENT_TYPES = _index$e.FLIPPED_ALIAS_KEYS.FunctionParent;
generated.PUREISH_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Pureish;
generated.DECLARATION_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Declaration;
generated.PATTERNLIKE_TYPES = _index$e.FLIPPED_ALIAS_KEYS.PatternLike;
generated.LVAL_TYPES = _index$e.FLIPPED_ALIAS_KEYS.LVal;
generated.TSENTITYNAME_TYPES = _index$e.FLIPPED_ALIAS_KEYS.TSEntityName;
generated.LITERAL_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Literal;
generated.IMMUTABLE_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Immutable;
generated.USERWHITESPACABLE_TYPES = _index$e.FLIPPED_ALIAS_KEYS.UserWhitespacable;
generated.METHOD_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Method;
generated.OBJECTMEMBER_TYPES = _index$e.FLIPPED_ALIAS_KEYS.ObjectMember;
generated.PROPERTY_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Property;
generated.UNARYLIKE_TYPES = _index$e.FLIPPED_ALIAS_KEYS.UnaryLike;
generated.PATTERN_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Pattern;
generated.CLASS_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Class;
const IMPORTOREXPORTDECLARATION_TYPES = generated.IMPORTOREXPORTDECLARATION_TYPES = _index$e.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;
generated.EXPORTDECLARATION_TYPES = _index$e.FLIPPED_ALIAS_KEYS.ExportDeclaration;
generated.MODULESPECIFIER_TYPES = _index$e.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
generated.ACCESSOR_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Accessor;
generated.PRIVATE_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Private;
generated.FLOW_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Flow;
generated.FLOWTYPE_TYPES = _index$e.FLIPPED_ALIAS_KEYS.FlowType;
generated.FLOWBASEANNOTATION_TYPES = _index$e.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
generated.FLOWDECLARATION_TYPES = _index$e.FLIPPED_ALIAS_KEYS.FlowDeclaration;
generated.FLOWPREDICATE_TYPES = _index$e.FLIPPED_ALIAS_KEYS.FlowPredicate;
generated.ENUMBODY_TYPES = _index$e.FLIPPED_ALIAS_KEYS.EnumBody;
generated.ENUMMEMBER_TYPES = _index$e.FLIPPED_ALIAS_KEYS.EnumMember;
generated.JSX_TYPES = _index$e.FLIPPED_ALIAS_KEYS.JSX;
generated.MISCELLANEOUS_TYPES = _index$e.FLIPPED_ALIAS_KEYS.Miscellaneous;
generated.TYPESCRIPT_TYPES = _index$e.FLIPPED_ALIAS_KEYS.TypeScript;
generated.TSTYPEELEMENT_TYPES = _index$e.FLIPPED_ALIAS_KEYS.TSTypeElement;
generated.TSTYPE_TYPES = _index$e.FLIPPED_ALIAS_KEYS.TSType;
generated.TSBASETYPE_TYPES = _index$e.FLIPPED_ALIAS_KEYS.TSBaseType;
generated.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
var ensureBlock$1 = {}, toBlock = {}, hasRequiredToBlock;
function requireToBlock() {
  if (hasRequiredToBlock)
    return toBlock;
  hasRequiredToBlock = 1, Object.defineProperty(toBlock, "__esModule", {
    value: !0
  }), toBlock.default = s;
  var e = generated$3, t = requireGenerated();
  function s(i, a) {
    if ((0, e.isBlockStatement)(i))
      return i;
    let o = [];
    return (0, e.isEmptyStatement)(i) ? o = [] : ((0, e.isStatement)(i) || ((0, e.isFunction)(a) ? i = (0, t.returnStatement)(i) : i = (0, t.expressionStatement)(i)), o = [i]), (0, t.blockStatement)(o);
  }
  return toBlock;
}
var hasRequiredEnsureBlock;
function requireEnsureBlock() {
  if (hasRequiredEnsureBlock)
    return ensureBlock$1;
  hasRequiredEnsureBlock = 1, Object.defineProperty(ensureBlock$1, "__esModule", {
    value: !0
  }), ensureBlock$1.default = t;
  var e = requireToBlock();
  function t(s, i = "body") {
    const a = (0, e.default)(s[i], s);
    return s[i] = a, a;
  }
  return ensureBlock$1;
}
var toBindingIdentifierName$2 = {}, toIdentifier$1 = {};
Object.defineProperty(toIdentifier$1, "__esModule", {
  value: !0
});
toIdentifier$1.default = toIdentifier;
var _isValidIdentifier$1 = isValidIdentifier$1, _helperValidatorIdentifier$1 = lib$a;
function toIdentifier(e) {
  e = e + "";
  let t = "";
  for (const s of e)
    t += (0, _helperValidatorIdentifier$1.isIdentifierChar)(s.codePointAt(0)) ? s : "-";
  return t = t.replace(/^[-0-9]+/, ""), t = t.replace(/[-\s]+(.)?/g, function(s, i) {
    return i ? i.toUpperCase() : "";
  }), (0, _isValidIdentifier$1.default)(t) || (t = `_${t}`), t || "_";
}
Object.defineProperty(toBindingIdentifierName$2, "__esModule", {
  value: !0
});
toBindingIdentifierName$2.default = toBindingIdentifierName$1;
var _toIdentifier = toIdentifier$1;
function toBindingIdentifierName$1(e) {
  return e = (0, _toIdentifier.default)(e), (e === "eval" || e === "arguments") && (e = "_" + e), e;
}
var toComputedKey$1 = {}, hasRequiredToComputedKey;
function requireToComputedKey() {
  if (hasRequiredToComputedKey)
    return toComputedKey$1;
  hasRequiredToComputedKey = 1, Object.defineProperty(toComputedKey$1, "__esModule", {
    value: !0
  }), toComputedKey$1.default = s;
  var e = generated$3, t = requireGenerated();
  function s(i, a = i.key || i.property) {
    return !i.computed && (0, e.isIdentifier)(a) && (a = (0, t.stringLiteral)(a.name)), a;
  }
  return toComputedKey$1;
}
var toExpression$2 = {};
Object.defineProperty(toExpression$2, "__esModule", {
  value: !0
});
toExpression$2.default = void 0;
var _index$d = generated$3;
toExpression$2.default = toExpression$1;
function toExpression$1(e) {
  if ((0, _index$d.isExpressionStatement)(e) && (e = e.expression), (0, _index$d.isExpression)(e))
    return e;
  if ((0, _index$d.isClass)(e) ? e.type = "ClassExpression" : (0, _index$d.isFunction)(e) && (e.type = "FunctionExpression"), !(0, _index$d.isExpression)(e))
    throw new Error(`cannot turn ${e.type} to an expression`);
  return e;
}
var toKeyAlias$1 = {}, removePropertiesDeep$2 = {}, traverseFast$1 = {};
Object.defineProperty(traverseFast$1, "__esModule", {
  value: !0
});
traverseFast$1.default = traverseFast;
var _index$c = requireDefinitions();
function traverseFast(e, t, s) {
  if (!e)
    return;
  const i = _index$c.VISITOR_KEYS[e.type];
  if (i) {
    s = s || {}, t(e, s);
    for (const a of i) {
      const o = e[a];
      if (Array.isArray(o))
        for (const l of o)
          traverseFast(l, t, s);
      else
        traverseFast(o, t, s);
    }
  }
}
var removeProperties$1 = {};
Object.defineProperty(removeProperties$1, "__esModule", {
  value: !0
});
removeProperties$1.default = removeProperties;
var _index$b = constants;
const CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"], CLEAR_KEYS_PLUS_COMMENTS = [..._index$b.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
function removeProperties(e, t = {}) {
  const s = t.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
  for (const a of s)
    e[a] != null && (e[a] = void 0);
  for (const a of Object.keys(e))
    a[0] === "_" && e[a] != null && (e[a] = void 0);
  const i = Object.getOwnPropertySymbols(e);
  for (const a of i)
    e[a] = null;
}
Object.defineProperty(removePropertiesDeep$2, "__esModule", {
  value: !0
});
removePropertiesDeep$2.default = removePropertiesDeep$1;
var _traverseFast = traverseFast$1, _removeProperties = removeProperties$1;
function removePropertiesDeep$1(e, t) {
  return (0, _traverseFast.default)(e, _removeProperties.default, t), e;
}
Object.defineProperty(toKeyAlias$1, "__esModule", {
  value: !0
});
toKeyAlias$1.default = toKeyAlias;
var _index$a = generated$3, _cloneNode = cloneNode$5, _removePropertiesDeep = removePropertiesDeep$2;
function toKeyAlias(e, t = e.key) {
  let s;
  return e.kind === "method" ? toKeyAlias.increment() + "" : ((0, _index$a.isIdentifier)(t) ? s = t.name : (0, _index$a.isStringLiteral)(t) ? s = JSON.stringify(t.value) : s = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(t))), e.computed && (s = `[${s}]`), e.static && (s = `static:${s}`), s);
}
toKeyAlias.uid = 0;
toKeyAlias.increment = function() {
  return toKeyAlias.uid >= Number.MAX_SAFE_INTEGER ? toKeyAlias.uid = 0 : toKeyAlias.uid++;
};
var toStatement = {}, hasRequiredToStatement;
function requireToStatement() {
  if (hasRequiredToStatement)
    return toStatement;
  hasRequiredToStatement = 1, Object.defineProperty(toStatement, "__esModule", {
    value: !0
  }), toStatement.default = void 0;
  var e = generated$3, t = requireGenerated();
  toStatement.default = s;
  function s(i, a) {
    if ((0, e.isStatement)(i))
      return i;
    let o = !1, l;
    if ((0, e.isClass)(i))
      o = !0, l = "ClassDeclaration";
    else if ((0, e.isFunction)(i))
      o = !0, l = "FunctionDeclaration";
    else if ((0, e.isAssignmentExpression)(i))
      return (0, t.expressionStatement)(i);
    if (o && !i.id && (l = !1), !l) {
      if (a)
        return !1;
      throw new Error(`cannot turn ${i.type} to a statement`);
    }
    return i.type = l, i;
  }
  return toStatement;
}
var valueToNode = {}, hasRequiredValueToNode;
function requireValueToNode() {
  if (hasRequiredValueToNode)
    return valueToNode;
  hasRequiredValueToNode = 1, Object.defineProperty(valueToNode, "__esModule", {
    value: !0
  }), valueToNode.default = void 0;
  var e = isValidIdentifier$1, t = requireGenerated();
  valueToNode.default = o;
  const s = Function.call.bind(Object.prototype.toString);
  function i(l) {
    return s(l) === "[object RegExp]";
  }
  function a(l) {
    if (typeof l != "object" || l === null || Object.prototype.toString.call(l) !== "[object Object]")
      return !1;
    const f = Object.getPrototypeOf(l);
    return f === null || Object.getPrototypeOf(f) === null;
  }
  function o(l) {
    if (l === void 0)
      return (0, t.identifier)("undefined");
    if (l === !0 || l === !1)
      return (0, t.booleanLiteral)(l);
    if (l === null)
      return (0, t.nullLiteral)();
    if (typeof l == "string")
      return (0, t.stringLiteral)(l);
    if (typeof l == "number") {
      let f;
      if (Number.isFinite(l))
        f = (0, t.numericLiteral)(Math.abs(l));
      else {
        let y;
        Number.isNaN(l) ? y = (0, t.numericLiteral)(0) : y = (0, t.numericLiteral)(1), f = (0, t.binaryExpression)("/", y, (0, t.numericLiteral)(0));
      }
      return (l < 0 || Object.is(l, -0)) && (f = (0, t.unaryExpression)("-", f)), f;
    }
    if (i(l)) {
      const f = l.source, y = l.toString().match(/\/([a-z]+|)$/)[1];
      return (0, t.regExpLiteral)(f, y);
    }
    if (Array.isArray(l))
      return (0, t.arrayExpression)(l.map(o));
    if (a(l)) {
      const f = [];
      for (const y of Object.keys(l)) {
        let g;
        (0, e.default)(y) ? g = (0, t.identifier)(y) : g = (0, t.stringLiteral)(y), f.push((0, t.objectProperty)(g, o(l[y])));
      }
      return (0, t.objectExpression)(f);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  return valueToNode;
}
var appendToMemberExpression = {}, hasRequiredAppendToMemberExpression;
function requireAppendToMemberExpression() {
  if (hasRequiredAppendToMemberExpression)
    return appendToMemberExpression;
  hasRequiredAppendToMemberExpression = 1, Object.defineProperty(appendToMemberExpression, "__esModule", {
    value: !0
  }), appendToMemberExpression.default = t;
  var e = requireGenerated();
  function t(s, i, a = !1) {
    return s.object = (0, e.memberExpression)(s.object, s.property, s.computed), s.property = i, s.computed = !!a, s;
  }
  return appendToMemberExpression;
}
var inherits$1 = {};
Object.defineProperty(inherits$1, "__esModule", {
  value: !0
});
inherits$1.default = inherits;
var _index$9 = constants, _inheritsComments = inheritsComments$1;
function inherits(e, t) {
  if (!e || !t)
    return e;
  for (const s of _index$9.INHERIT_KEYS.optional)
    e[s] == null && (e[s] = t[s]);
  for (const s of Object.keys(t))
    s[0] === "_" && s !== "__clone" && (e[s] = t[s]);
  for (const s of _index$9.INHERIT_KEYS.force)
    e[s] = t[s];
  return (0, _inheritsComments.default)(e, t), e;
}
var prependToMemberExpression = {}, hasRequiredPrependToMemberExpression;
function requirePrependToMemberExpression() {
  if (hasRequiredPrependToMemberExpression)
    return prependToMemberExpression;
  hasRequiredPrependToMemberExpression = 1, Object.defineProperty(prependToMemberExpression, "__esModule", {
    value: !0
  }), prependToMemberExpression.default = s;
  var e = requireGenerated(), t = requireLib$1();
  function s(i, a) {
    if ((0, t.isSuper)(i.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return i.object = (0, e.memberExpression)(a, i.object), i;
  }
  return prependToMemberExpression;
}
var getBindingIdentifiers$1 = {};
Object.defineProperty(getBindingIdentifiers$1, "__esModule", {
  value: !0
});
getBindingIdentifiers$1.default = getBindingIdentifiers;
var _index$8 = generated$3;
function getBindingIdentifiers(e, t, s, i) {
  const a = [].concat(e), o = /* @__PURE__ */ Object.create(null);
  for (; a.length; ) {
    const l = a.shift();
    if (!l || i && ((0, _index$8.isAssignmentExpression)(l) || (0, _index$8.isUnaryExpression)(l)))
      continue;
    const f = getBindingIdentifiers.keys[l.type];
    if ((0, _index$8.isIdentifier)(l)) {
      t ? (o[l.name] = o[l.name] || []).push(l) : o[l.name] = l;
      continue;
    }
    if ((0, _index$8.isExportDeclaration)(l) && !(0, _index$8.isExportAllDeclaration)(l)) {
      (0, _index$8.isDeclaration)(l.declaration) && a.push(l.declaration);
      continue;
    }
    if (s) {
      if ((0, _index$8.isFunctionDeclaration)(l)) {
        a.push(l.id);
        continue;
      }
      if ((0, _index$8.isFunctionExpression)(l))
        continue;
    }
    if (f)
      for (let y = 0; y < f.length; y++) {
        const g = f[y], T = l[g];
        T && (Array.isArray(T) ? a.push(...T) : a.push(T));
      }
  }
  return o;
}
getBindingIdentifiers.keys = {
  DeclareClass: ["id"],
  DeclareFunction: ["id"],
  DeclareModule: ["id"],
  DeclareVariable: ["id"],
  DeclareInterface: ["id"],
  DeclareTypeAlias: ["id"],
  DeclareOpaqueType: ["id"],
  InterfaceDeclaration: ["id"],
  TypeAlias: ["id"],
  OpaqueType: ["id"],
  CatchClause: ["param"],
  LabeledStatement: ["label"],
  UnaryExpression: ["argument"],
  AssignmentExpression: ["left"],
  ImportSpecifier: ["local"],
  ImportNamespaceSpecifier: ["local"],
  ImportDefaultSpecifier: ["local"],
  ImportDeclaration: ["specifiers"],
  ExportSpecifier: ["exported"],
  ExportNamespaceSpecifier: ["exported"],
  ExportDefaultSpecifier: ["exported"],
  FunctionDeclaration: ["id", "params"],
  FunctionExpression: ["id", "params"],
  ArrowFunctionExpression: ["params"],
  ObjectMethod: ["params"],
  ClassMethod: ["params"],
  ClassPrivateMethod: ["params"],
  ForInStatement: ["left"],
  ForOfStatement: ["left"],
  ClassDeclaration: ["id"],
  ClassExpression: ["id"],
  RestElement: ["argument"],
  UpdateExpression: ["argument"],
  ObjectProperty: ["value"],
  AssignmentPattern: ["left"],
  ArrayPattern: ["elements"],
  ObjectPattern: ["properties"],
  VariableDeclaration: ["declarations"],
  VariableDeclarator: ["id"]
};
var getOuterBindingIdentifiers$1 = {};
Object.defineProperty(getOuterBindingIdentifiers$1, "__esModule", {
  value: !0
});
getOuterBindingIdentifiers$1.default = void 0;
var _getBindingIdentifiers$1 = getBindingIdentifiers$1;
getOuterBindingIdentifiers$1.default = getOuterBindingIdentifiers;
function getOuterBindingIdentifiers(e, t) {
  return (0, _getBindingIdentifiers$1.default)(e, t, !0);
}
var traverse$3 = {};
Object.defineProperty(traverse$3, "__esModule", {
  value: !0
});
traverse$3.default = traverse$2;
var _index$7 = requireDefinitions();
function traverse$2(e, t, s) {
  typeof t == "function" && (t = {
    enter: t
  });
  const {
    enter: i,
    exit: a
  } = t;
  traverseSimpleImpl(e, i, a, s, []);
}
function traverseSimpleImpl(e, t, s, i, a) {
  const o = _index$7.VISITOR_KEYS[e.type];
  if (o) {
    t && t(e, a, i);
    for (const l of o) {
      const f = e[l];
      if (Array.isArray(f))
        for (let y = 0; y < f.length; y++) {
          const g = f[y];
          g && (a.push({
            node: e,
            key: l,
            index: y
          }), traverseSimpleImpl(g, t, s, i, a), a.pop());
        }
      else
        f && (a.push({
          node: e,
          key: l
        }), traverseSimpleImpl(f, t, s, i, a), a.pop());
    }
    s && s(e, a, i);
  }
}
var isBinding$2 = {};
Object.defineProperty(isBinding$2, "__esModule", {
  value: !0
});
isBinding$2.default = isBinding$1;
var _getBindingIdentifiers = getBindingIdentifiers$1;
function isBinding$1(e, t, s) {
  if (s && e.type === "Identifier" && t.type === "ObjectProperty" && s.type === "ObjectExpression")
    return !1;
  const i = _getBindingIdentifiers.default.keys[t.type];
  if (i)
    for (let a = 0; a < i.length; a++) {
      const o = i[a], l = t[o];
      if (Array.isArray(l)) {
        if (l.indexOf(e) >= 0)
          return !0;
      } else if (l === e)
        return !0;
    }
  return !1;
}
var isBlockScoped$2 = {}, isLet$1 = {};
Object.defineProperty(isLet$1, "__esModule", {
  value: !0
});
isLet$1.default = isLet;
var _index$6 = generated$3, _index2$1 = constants;
function isLet(e) {
  return (0, _index$6.isVariableDeclaration)(e) && (e.kind !== "var" || e[_index2$1.BLOCK_SCOPED_SYMBOL]);
}
Object.defineProperty(isBlockScoped$2, "__esModule", {
  value: !0
});
isBlockScoped$2.default = isBlockScoped$1;
var _index$5 = generated$3, _isLet = isLet$1;
function isBlockScoped$1(e) {
  return (0, _index$5.isFunctionDeclaration)(e) || (0, _index$5.isClassDeclaration)(e) || (0, _isLet.default)(e);
}
var isImmutable$1 = {};
Object.defineProperty(isImmutable$1, "__esModule", {
  value: !0
});
isImmutable$1.default = isImmutable;
var _isType = requireIsType(), _index$4 = generated$3;
function isImmutable(e) {
  return (0, _isType.default)(e.type, "Immutable") ? !0 : (0, _index$4.isIdentifier)(e) ? e.name === "undefined" : !1;
}
var isNodesEquivalent$1 = {};
Object.defineProperty(isNodesEquivalent$1, "__esModule", {
  value: !0
});
isNodesEquivalent$1.default = isNodesEquivalent;
var _index$3 = requireDefinitions();
function isNodesEquivalent(e, t) {
  if (typeof e != "object" || typeof t != "object" || e == null || t == null)
    return e === t;
  if (e.type !== t.type)
    return !1;
  const s = Object.keys(_index$3.NODE_FIELDS[e.type] || e.type), i = _index$3.VISITOR_KEYS[e.type];
  for (const a of s) {
    const o = e[a], l = t[a];
    if (typeof o != typeof l)
      return !1;
    if (!(o == null && l == null)) {
      if (o == null || l == null)
        return !1;
      if (Array.isArray(o)) {
        if (!Array.isArray(l) || o.length !== l.length)
          return !1;
        for (let f = 0; f < o.length; f++)
          if (!isNodesEquivalent(o[f], l[f]))
            return !1;
        continue;
      }
      if (typeof o == "object" && !(i != null && i.includes(a))) {
        for (const f of Object.keys(o))
          if (o[f] !== l[f])
            return !1;
        continue;
      }
      if (!isNodesEquivalent(o, l))
        return !1;
    }
  }
  return !0;
}
var isReferenced$2 = {};
Object.defineProperty(isReferenced$2, "__esModule", {
  value: !0
});
isReferenced$2.default = isReferenced$1;
function isReferenced$1(e, t, s) {
  switch (t.type) {
    case "MemberExpression":
    case "OptionalMemberExpression":
      return t.property === e ? !!t.computed : t.object === e;
    case "JSXMemberExpression":
      return t.object === e;
    case "VariableDeclarator":
      return t.init === e;
    case "ArrowFunctionExpression":
      return t.body === e;
    case "PrivateName":
      return !1;
    case "ClassMethod":
    case "ClassPrivateMethod":
    case "ObjectMethod":
      return t.key === e ? !!t.computed : !1;
    case "ObjectProperty":
      return t.key === e ? !!t.computed : !s || s.type !== "ObjectPattern";
    case "ClassProperty":
    case "ClassAccessorProperty":
      return t.key === e ? !!t.computed : !0;
    case "ClassPrivateProperty":
      return t.key !== e;
    case "ClassDeclaration":
    case "ClassExpression":
      return t.superClass === e;
    case "AssignmentExpression":
      return t.right === e;
    case "AssignmentPattern":
      return t.right === e;
    case "LabeledStatement":
      return !1;
    case "CatchClause":
      return !1;
    case "RestElement":
      return !1;
    case "BreakStatement":
    case "ContinueStatement":
      return !1;
    case "FunctionDeclaration":
    case "FunctionExpression":
      return !1;
    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return !1;
    case "ExportSpecifier":
      return s != null && s.source ? !1 : t.local === e;
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "ImportSpecifier":
      return !1;
    case "ImportAttribute":
      return !1;
    case "JSXAttribute":
      return !1;
    case "ObjectPattern":
    case "ArrayPattern":
      return !1;
    case "MetaProperty":
      return !1;
    case "ObjectTypeProperty":
      return t.key !== e;
    case "TSEnumMember":
      return t.id !== e;
    case "TSPropertySignature":
      return t.key === e ? !!t.computed : !0;
  }
  return !0;
}
var isScope$2 = {};
Object.defineProperty(isScope$2, "__esModule", {
  value: !0
});
isScope$2.default = isScope$1;
var _index$2 = generated$3;
function isScope$1(e, t) {
  return (0, _index$2.isBlockStatement)(e) && ((0, _index$2.isFunction)(t) || (0, _index$2.isCatchClause)(t)) ? !1 : (0, _index$2.isPattern)(e) && ((0, _index$2.isFunction)(t) || (0, _index$2.isCatchClause)(t)) ? !0 : (0, _index$2.isScopable)(e);
}
var isSpecifierDefault$1 = {};
Object.defineProperty(isSpecifierDefault$1, "__esModule", {
  value: !0
});
isSpecifierDefault$1.default = isSpecifierDefault;
var _index$1 = generated$3;
function isSpecifierDefault(e) {
  return (0, _index$1.isImportDefaultSpecifier)(e) || (0, _index$1.isIdentifier)(e.imported || e.exported, {
    name: "default"
  });
}
var isValidES3Identifier$1 = {};
Object.defineProperty(isValidES3Identifier$1, "__esModule", {
  value: !0
});
isValidES3Identifier$1.default = isValidES3Identifier;
var _isValidIdentifier = isValidIdentifier$1;
const RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
function isValidES3Identifier(e) {
  return (0, _isValidIdentifier.default)(e) && !RESERVED_WORDS_ES3_ONLY.has(e);
}
var isVar$2 = {};
Object.defineProperty(isVar$2, "__esModule", {
  value: !0
});
isVar$2.default = isVar$1;
var _index = generated$3, _index2 = constants;
function isVar$1(e) {
  return (0, _index.isVariableDeclaration)(e, {
    kind: "var"
  }) && !e[_index2.BLOCK_SCOPED_SYMBOL];
}
var toSequenceExpression = {}, gatherSequenceExpressions = {}, hasRequiredGatherSequenceExpressions;
function requireGatherSequenceExpressions() {
  if (hasRequiredGatherSequenceExpressions)
    return gatherSequenceExpressions;
  hasRequiredGatherSequenceExpressions = 1, Object.defineProperty(gatherSequenceExpressions, "__esModule", {
    value: !0
  }), gatherSequenceExpressions.default = a;
  var e = getBindingIdentifiers$1, t = generated$3, s = requireGenerated(), i = cloneNode$5;
  function a(o, l, f) {
    const y = [];
    let g = !0;
    for (const T of o)
      if ((0, t.isEmptyStatement)(T) || (g = !1), (0, t.isExpression)(T))
        y.push(T);
      else if ((0, t.isExpressionStatement)(T))
        y.push(T.expression);
      else if ((0, t.isVariableDeclaration)(T)) {
        if (T.kind !== "var")
          return;
        for (const S of T.declarations) {
          const b = (0, e.default)(S);
          for (const v of Object.keys(b))
            f.push({
              kind: T.kind,
              id: (0, i.default)(b[v])
            });
          S.init && y.push((0, s.assignmentExpression)("=", S.id, S.init));
        }
        g = !0;
      } else if ((0, t.isIfStatement)(T)) {
        const S = T.consequent ? a([T.consequent], l, f) : l.buildUndefinedNode(), b = T.alternate ? a([T.alternate], l, f) : l.buildUndefinedNode();
        if (!S || !b)
          return;
        y.push((0, s.conditionalExpression)(T.test, S, b));
      } else if ((0, t.isBlockStatement)(T)) {
        const S = a(T.body, l, f);
        if (!S)
          return;
        y.push(S);
      } else if ((0, t.isEmptyStatement)(T))
        o.indexOf(T) === 0 && (g = !0);
      else
        return;
    return g && y.push(l.buildUndefinedNode()), y.length === 1 ? y[0] : (0, s.sequenceExpression)(y);
  }
  return gatherSequenceExpressions;
}
var hasRequiredToSequenceExpression;
function requireToSequenceExpression() {
  if (hasRequiredToSequenceExpression)
    return toSequenceExpression;
  hasRequiredToSequenceExpression = 1, Object.defineProperty(toSequenceExpression, "__esModule", {
    value: !0
  }), toSequenceExpression.default = t;
  var e = requireGatherSequenceExpressions();
  function t(s, i) {
    if (!(s != null && s.length))
      return;
    const a = [], o = (0, e.default)(s, i, a);
    if (o) {
      for (const l of a)
        i.push(l);
      return o;
    }
  }
  return toSequenceExpression;
}
var hasRequiredLib$1;
function requireLib$1() {
  return hasRequiredLib$1 || (hasRequiredLib$1 = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    });
    var t = {
      react: !0,
      assertNode: !0,
      createTypeAnnotationBasedOnTypeof: !0,
      createUnionTypeAnnotation: !0,
      createFlowUnionType: !0,
      createTSUnionType: !0,
      cloneNode: !0,
      clone: !0,
      cloneDeep: !0,
      cloneDeepWithoutLoc: !0,
      cloneWithoutLoc: !0,
      addComment: !0,
      addComments: !0,
      inheritInnerComments: !0,
      inheritLeadingComments: !0,
      inheritsComments: !0,
      inheritTrailingComments: !0,
      removeComments: !0,
      ensureBlock: !0,
      toBindingIdentifierName: !0,
      toBlock: !0,
      toComputedKey: !0,
      toExpression: !0,
      toIdentifier: !0,
      toKeyAlias: !0,
      toStatement: !0,
      valueToNode: !0,
      appendToMemberExpression: !0,
      inherits: !0,
      prependToMemberExpression: !0,
      removeProperties: !0,
      removePropertiesDeep: !0,
      removeTypeDuplicates: !0,
      getBindingIdentifiers: !0,
      getOuterBindingIdentifiers: !0,
      traverse: !0,
      traverseFast: !0,
      shallowEqual: !0,
      is: !0,
      isBinding: !0,
      isBlockScoped: !0,
      isImmutable: !0,
      isLet: !0,
      isNode: !0,
      isNodesEquivalent: !0,
      isPlaceholderType: !0,
      isReferenced: !0,
      isScope: !0,
      isSpecifierDefault: !0,
      isType: !0,
      isValidES3Identifier: !0,
      isValidIdentifier: !0,
      isVar: !0,
      matchesPattern: !0,
      validate: !0,
      buildMatchMemberExpression: !0,
      __internal__deprecationWarning: !0
    };
    Object.defineProperty(e, "__internal__deprecationWarning", {
      enumerable: !0,
      get: function() {
        return De.default;
      }
    }), Object.defineProperty(e, "addComment", {
      enumerable: !0,
      get: function() {
        return D.default;
      }
    }), Object.defineProperty(e, "addComments", {
      enumerable: !0,
      get: function() {
        return B.default;
      }
    }), Object.defineProperty(e, "appendToMemberExpression", {
      enumerable: !0,
      get: function() {
        return fe.default;
      }
    }), Object.defineProperty(e, "assertNode", {
      enumerable: !0,
      get: function() {
        return o.default;
      }
    }), Object.defineProperty(e, "buildMatchMemberExpression", {
      enumerable: !0,
      get: function() {
        return Le.default;
      }
    }), Object.defineProperty(e, "clone", {
      enumerable: !0,
      get: function() {
        return $.default;
      }
    }), Object.defineProperty(e, "cloneDeep", {
      enumerable: !0,
      get: function() {
        return U.default;
      }
    }), Object.defineProperty(e, "cloneDeepWithoutLoc", {
      enumerable: !0,
      get: function() {
        return X.default;
      }
    }), Object.defineProperty(e, "cloneNode", {
      enumerable: !0,
      get: function() {
        return v.default;
      }
    }), Object.defineProperty(e, "cloneWithoutLoc", {
      enumerable: !0,
      get: function() {
        return k.default;
      }
    }), Object.defineProperty(e, "createFlowUnionType", {
      enumerable: !0,
      get: function() {
        return y.default;
      }
    }), Object.defineProperty(e, "createTSUnionType", {
      enumerable: !0,
      get: function() {
        return g.default;
      }
    }), Object.defineProperty(e, "createTypeAnnotationBasedOnTypeof", {
      enumerable: !0,
      get: function() {
        return f.default;
      }
    }), Object.defineProperty(e, "createUnionTypeAnnotation", {
      enumerable: !0,
      get: function() {
        return y.default;
      }
    }), Object.defineProperty(e, "ensureBlock", {
      enumerable: !0,
      get: function() {
        return ee.default;
      }
    }), Object.defineProperty(e, "getBindingIdentifiers", {
      enumerable: !0,
      get: function() {
        return xe.default;
      }
    }), Object.defineProperty(e, "getOuterBindingIdentifiers", {
      enumerable: !0,
      get: function() {
        return we.default;
      }
    }), Object.defineProperty(e, "inheritInnerComments", {
      enumerable: !0,
      get: function() {
        return Z.default;
      }
    }), Object.defineProperty(e, "inheritLeadingComments", {
      enumerable: !0,
      get: function() {
        return H.default;
      }
    }), Object.defineProperty(e, "inheritTrailingComments", {
      enumerable: !0,
      get: function() {
        return _.default;
      }
    }), Object.defineProperty(e, "inherits", {
      enumerable: !0,
      get: function() {
        return ce.default;
      }
    }), Object.defineProperty(e, "inheritsComments", {
      enumerable: !0,
      get: function() {
        return q.default;
      }
    }), Object.defineProperty(e, "is", {
      enumerable: !0,
      get: function() {
        return oe.default;
      }
    }), Object.defineProperty(e, "isBinding", {
      enumerable: !0,
      get: function() {
        return me.default;
      }
    }), Object.defineProperty(e, "isBlockScoped", {
      enumerable: !0,
      get: function() {
        return pe.default;
      }
    }), Object.defineProperty(e, "isImmutable", {
      enumerable: !0,
      get: function() {
        return ye.default;
      }
    }), Object.defineProperty(e, "isLet", {
      enumerable: !0,
      get: function() {
        return le.default;
      }
    }), Object.defineProperty(e, "isNode", {
      enumerable: !0,
      get: function() {
        return he.default;
      }
    }), Object.defineProperty(e, "isNodesEquivalent", {
      enumerable: !0,
      get: function() {
        return Se.default;
      }
    }), Object.defineProperty(e, "isPlaceholderType", {
      enumerable: !0,
      get: function() {
        return Ie.default;
      }
    }), Object.defineProperty(e, "isReferenced", {
      enumerable: !0,
      get: function() {
        return J.default;
      }
    }), Object.defineProperty(e, "isScope", {
      enumerable: !0,
      get: function() {
        return A.default;
      }
    }), Object.defineProperty(e, "isSpecifierDefault", {
      enumerable: !0,
      get: function() {
        return N.default;
      }
    }), Object.defineProperty(e, "isType", {
      enumerable: !0,
      get: function() {
        return Y.default;
      }
    }), Object.defineProperty(e, "isValidES3Identifier", {
      enumerable: !0,
      get: function() {
        return ne.default;
      }
    }), Object.defineProperty(e, "isValidIdentifier", {
      enumerable: !0,
      get: function() {
        return de.default;
      }
    }), Object.defineProperty(e, "isVar", {
      enumerable: !0,
      get: function() {
        return Ae.default;
      }
    }), Object.defineProperty(e, "matchesPattern", {
      enumerable: !0,
      get: function() {
        return Ne.default;
      }
    }), Object.defineProperty(e, "prependToMemberExpression", {
      enumerable: !0,
      get: function() {
        return Pe.default;
      }
    }), e.react = void 0, Object.defineProperty(e, "removeComments", {
      enumerable: !0,
      get: function() {
        return j.default;
      }
    }), Object.defineProperty(e, "removeProperties", {
      enumerable: !0,
      get: function() {
        return Ce.default;
      }
    }), Object.defineProperty(e, "removePropertiesDeep", {
      enumerable: !0,
      get: function() {
        return _e.default;
      }
    }), Object.defineProperty(e, "removeTypeDuplicates", {
      enumerable: !0,
      get: function() {
        return ge.default;
      }
    }), Object.defineProperty(e, "shallowEqual", {
      enumerable: !0,
      get: function() {
        return te.default;
      }
    }), Object.defineProperty(e, "toBindingIdentifierName", {
      enumerable: !0,
      get: function() {
        return se.default;
      }
    }), Object.defineProperty(e, "toBlock", {
      enumerable: !0,
      get: function() {
        return be.default;
      }
    }), Object.defineProperty(e, "toComputedKey", {
      enumerable: !0,
      get: function() {
        return ve.default;
      }
    }), Object.defineProperty(e, "toExpression", {
      enumerable: !0,
      get: function() {
        return F.default;
      }
    }), Object.defineProperty(e, "toIdentifier", {
      enumerable: !0,
      get: function() {
        return R.default;
      }
    }), Object.defineProperty(e, "toKeyAlias", {
      enumerable: !0,
      get: function() {
        return K.default;
      }
    }), Object.defineProperty(e, "toStatement", {
      enumerable: !0,
      get: function() {
        return z.default;
      }
    }), Object.defineProperty(e, "traverse", {
      enumerable: !0,
      get: function() {
        return G.default;
      }
    }), Object.defineProperty(e, "traverseFast", {
      enumerable: !0,
      get: function() {
        return W.default;
      }
    }), Object.defineProperty(e, "validate", {
      enumerable: !0,
      get: function() {
        return ke.default;
      }
    }), Object.defineProperty(e, "valueToNode", {
      enumerable: !0,
      get: function() {
        return re.default;
      }
    });
    var s = isReactComponent$1, i = isCompatTag$2, a = requireBuildChildren(), o = assertNode$1, l = generated$1;
    Object.keys(l).forEach(function(ae) {
      ae === "default" || ae === "__esModule" || Object.prototype.hasOwnProperty.call(t, ae) || ae in e && e[ae] === l[ae] || Object.defineProperty(e, ae, {
        enumerable: !0,
        get: function() {
          return l[ae];
        }
      });
    });
    var f = requireCreateTypeAnnotationBasedOnTypeof(), y = requireCreateFlowUnionType(), g = requireCreateTSUnionType(), T = requireGenerated();
    Object.keys(T).forEach(function(ae) {
      ae === "default" || ae === "__esModule" || Object.prototype.hasOwnProperty.call(t, ae) || ae in e && e[ae] === T[ae] || Object.defineProperty(e, ae, {
        enumerable: !0,
        get: function() {
          return T[ae];
        }
      });
    });
    var S = requireUppercase();
    Object.keys(S).forEach(function(ae) {
      ae === "default" || ae === "__esModule" || Object.prototype.hasOwnProperty.call(t, ae) || ae in e && e[ae] === S[ae] || Object.defineProperty(e, ae, {
        enumerable: !0,
        get: function() {
          return S[ae];
        }
      });
    });
    var b = requireProductions();
    Object.keys(b).forEach(function(ae) {
      ae === "default" || ae === "__esModule" || Object.prototype.hasOwnProperty.call(t, ae) || ae in e && e[ae] === b[ae] || Object.defineProperty(e, ae, {
        enumerable: !0,
        get: function() {
          return b[ae];
        }
      });
    });
    var v = cloneNode$5, $ = clone$1, U = cloneDeep$1, X = cloneDeepWithoutLoc$1, k = cloneWithoutLoc$1, D = addComment$2, B = addComments$2, Z = inheritInnerComments$1, H = inheritLeadingComments$1, q = inheritsComments$1, _ = inheritTrailingComments$1, j = removeComments$1, V = generated;
    Object.keys(V).forEach(function(ae) {
      ae === "default" || ae === "__esModule" || Object.prototype.hasOwnProperty.call(t, ae) || ae in e && e[ae] === V[ae] || Object.defineProperty(e, ae, {
        enumerable: !0,
        get: function() {
          return V[ae];
        }
      });
    });
    var ue = constants;
    Object.keys(ue).forEach(function(ae) {
      ae === "default" || ae === "__esModule" || Object.prototype.hasOwnProperty.call(t, ae) || ae in e && e[ae] === ue[ae] || Object.defineProperty(e, ae, {
        enumerable: !0,
        get: function() {
          return ue[ae];
        }
      });
    });
    var ee = requireEnsureBlock(), se = toBindingIdentifierName$2, be = requireToBlock(), ve = requireToComputedKey(), F = toExpression$2, R = toIdentifier$1, K = toKeyAlias$1, z = requireToStatement(), re = requireValueToNode(), ie = requireDefinitions();
    Object.keys(ie).forEach(function(ae) {
      ae === "default" || ae === "__esModule" || Object.prototype.hasOwnProperty.call(t, ae) || ae in e && e[ae] === ie[ae] || Object.defineProperty(e, ae, {
        enumerable: !0,
        get: function() {
          return ie[ae];
        }
      });
    });
    var fe = requireAppendToMemberExpression(), ce = inherits$1, Pe = requirePrependToMemberExpression(), Ce = removeProperties$1, _e = removePropertiesDeep$2, ge = removeTypeDuplicates$3, xe = getBindingIdentifiers$1, we = getOuterBindingIdentifiers$1, G = traverse$3;
    Object.keys(G).forEach(function(ae) {
      ae === "default" || ae === "__esModule" || Object.prototype.hasOwnProperty.call(t, ae) || ae in e && e[ae] === G[ae] || Object.defineProperty(e, ae, {
        enumerable: !0,
        get: function() {
          return G[ae];
        }
      });
    });
    var W = traverseFast$1, te = shallowEqual$1, oe = requireIs(), me = isBinding$2, pe = isBlockScoped$2, ye = isImmutable$1, le = isLet$1, he = isNode$1, Se = isNodesEquivalent$1, Ie = requireIsPlaceholderType(), J = isReferenced$2, A = isScope$2, N = isSpecifierDefault$1, Y = requireIsType(), ne = isValidES3Identifier$1, de = isValidIdentifier$1, Ae = isVar$2, Ne = matchesPattern$2, ke = requireValidate(), Le = buildMatchMemberExpression$1, Me = generated$3;
    Object.keys(Me).forEach(function(ae) {
      ae === "default" || ae === "__esModule" || Object.prototype.hasOwnProperty.call(t, ae) || ae in e && e[ae] === Me[ae] || Object.defineProperty(e, ae, {
        enumerable: !0,
        get: function() {
          return Me[ae];
        }
      });
    });
    var De = deprecationWarning$2;
    e.react = {
      isReactComponent: s.default,
      isCompatTag: i.default,
      buildChildren: a.default
    }, e.toSequenceExpression = requireToSequenceExpression().default;
  }(lib$b)), lib$b;
}
Object.defineProperty(virtualTypesValidator, "__esModule", {
  value: !0
});
virtualTypesValidator.isBindingIdentifier = isBindingIdentifier;
virtualTypesValidator.isBlockScoped = isBlockScoped;
virtualTypesValidator.isExpression = isExpression$1;
virtualTypesValidator.isFlow = isFlow;
virtualTypesValidator.isForAwaitStatement = isForAwaitStatement;
virtualTypesValidator.isGenerated = isGenerated;
virtualTypesValidator.isPure = isPure;
virtualTypesValidator.isReferenced = isReferenced;
virtualTypesValidator.isReferencedIdentifier = isReferencedIdentifier;
virtualTypesValidator.isReferencedMemberExpression = isReferencedMemberExpression;
virtualTypesValidator.isRestProperty = isRestProperty;
virtualTypesValidator.isScope = isScope;
virtualTypesValidator.isSpreadProperty = isSpreadProperty;
virtualTypesValidator.isStatement = isStatement$5;
virtualTypesValidator.isUser = isUser;
virtualTypesValidator.isVar = isVar;
var _t$p = requireLib$1();
const {
  isBinding,
  isBlockScoped: nodeIsBlockScoped,
  isExportDeclaration: isExportDeclaration$1,
  isExpression: nodeIsExpression,
  isFlow: nodeIsFlow,
  isForStatement: isForStatement$1,
  isForXStatement,
  isIdentifier: isIdentifier$8,
  isImportDeclaration,
  isImportSpecifier,
  isJSXIdentifier: isJSXIdentifier$1,
  isJSXMemberExpression,
  isMemberExpression: isMemberExpression$4,
  isRestElement: nodeIsRestElement,
  isReferenced: nodeIsReferenced,
  isScope: nodeIsScope,
  isStatement: nodeIsStatement,
  isVar: nodeIsVar,
  isVariableDeclaration,
  react: react$1,
  isForOfStatement: isForOfStatement$1
} = _t$p, {
  isCompatTag
} = react$1;
function isReferencedIdentifier(e) {
  const {
    node: t,
    parent: s
  } = this;
  if (!isIdentifier$8(t, e) && !isJSXMemberExpression(s, e))
    if (isJSXIdentifier$1(t, e)) {
      if (isCompatTag(t.name))
        return !1;
    } else
      return !1;
  return nodeIsReferenced(t, s, this.parentPath.parent);
}
function isReferencedMemberExpression() {
  const {
    node: e,
    parent: t
  } = this;
  return isMemberExpression$4(e) && nodeIsReferenced(e, t);
}
function isBindingIdentifier() {
  const {
    node: e,
    parent: t
  } = this, s = this.parentPath.parent;
  return isIdentifier$8(e) && isBinding(e, t, s);
}
function isStatement$5() {
  const {
    node: e,
    parent: t
  } = this;
  return nodeIsStatement(e) ? !(isVariableDeclaration(e) && (isForXStatement(t, {
    left: e
  }) || isForStatement$1(t, {
    init: e
  }))) : !1;
}
function isExpression$1() {
  return this.isIdentifier() ? this.isReferencedIdentifier() : nodeIsExpression(this.node);
}
function isScope() {
  return nodeIsScope(this.node, this.parent);
}
function isReferenced() {
  return nodeIsReferenced(this.node, this.parent);
}
function isBlockScoped() {
  return nodeIsBlockScoped(this.node);
}
function isVar() {
  return nodeIsVar(this.node);
}
function isUser() {
  return this.node && !!this.node.loc;
}
function isGenerated() {
  return !this.isUser();
}
function isPure(e) {
  return this.scope.isPure(this.node, e);
}
function isFlow() {
  const {
    node: e
  } = this;
  return nodeIsFlow(e) ? !0 : isImportDeclaration(e) ? e.importKind === "type" || e.importKind === "typeof" : isExportDeclaration$1(e) ? e.exportKind === "type" : isImportSpecifier(e) ? e.importKind === "type" || e.importKind === "typeof" : !1;
}
function isRestProperty() {
  return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectPattern();
}
function isSpreadProperty() {
  return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectExpression();
}
function isForAwaitStatement() {
  return isForOfStatement$1(this.node, {
    await: !0
  });
}
virtualTypesValidator.isExistentialTypeParam = function() {
  throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
}, virtualTypesValidator.isNumericLiteralTypeAnnotation = function() {
  throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
};
Object.defineProperty(visitors, "__esModule", {
  value: !0
});
visitors.explode = explode;
visitors.isExplodedVisitor = isExplodedVisitor;
visitors.merge = merge$1;
visitors.verify = verify;
var virtualTypes = virtualTypes$1, virtualTypesValidators = virtualTypesValidator, _t$o = requireLib$1();
const {
  DEPRECATED_KEYS,
  DEPRECATED_ALIASES,
  FLIPPED_ALIAS_KEYS: FLIPPED_ALIAS_KEYS$2,
  TYPES,
  __internal__deprecationWarning: deprecationWarning
} = _t$o;
function isVirtualType(e) {
  return e in virtualTypes;
}
function isExplodedVisitor(e) {
  return e == null ? void 0 : e._exploded;
}
function explode(e) {
  if (isExplodedVisitor(e))
    return e;
  e._exploded = !0;
  for (const t of Object.keys(e)) {
    if (shouldIgnoreKey(t))
      continue;
    const s = t.split("|");
    if (s.length === 1)
      continue;
    const i = e[t];
    delete e[t];
    for (const a of s)
      e[a] = i;
  }
  verify(e), delete e.__esModule, ensureEntranceObjects(e), ensureCallbackArrays(e);
  for (const t of Object.keys(e)) {
    if (shouldIgnoreKey(t) || !isVirtualType(t))
      continue;
    const s = e[t];
    for (const a of Object.keys(s))
      s[a] = wrapCheck(t, s[a]);
    delete e[t];
    const i = virtualTypes[t];
    if (i !== null)
      for (const a of i)
        e[a] ? mergePair(e[a], s) : e[a] = s;
    else
      mergePair(e, s);
  }
  for (const t of Object.keys(e)) {
    if (shouldIgnoreKey(t))
      continue;
    let s = FLIPPED_ALIAS_KEYS$2[t];
    if (t in DEPRECATED_KEYS) {
      const a = DEPRECATED_KEYS[t];
      deprecationWarning(t, a, "Visitor "), s = [a];
    } else if (t in DEPRECATED_ALIASES) {
      const a = DEPRECATED_ALIASES[t];
      deprecationWarning(t, a, "Visitor "), s = FLIPPED_ALIAS_KEYS$2[a];
    }
    if (!s)
      continue;
    const i = e[t];
    delete e[t];
    for (const a of s) {
      const o = e[a];
      o ? mergePair(o, i) : e[a] = Object.assign({}, i);
    }
  }
  for (const t of Object.keys(e))
    shouldIgnoreKey(t) || ensureCallbackArrays(e[t]);
  return e;
}
function verify(e) {
  if (!e._verified) {
    if (typeof e == "function")
      throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
    for (const t of Object.keys(e)) {
      if ((t === "enter" || t === "exit") && validateVisitorMethods(t, e[t]), shouldIgnoreKey(t))
        continue;
      if (TYPES.indexOf(t) < 0)
        throw new Error(`You gave us a visitor for the node type ${t} but it's not a valid type`);
      const s = e[t];
      if (typeof s == "object")
        for (const i of Object.keys(s))
          if (i === "enter" || i === "exit")
            validateVisitorMethods(`${t}.${i}`, s[i]);
          else
            throw new Error(`You passed \`traverse()\` a visitor object with the property ${t} that has the invalid property ${i}`);
    }
    e._verified = !0;
  }
}
function validateVisitorMethods(e, t) {
  const s = [].concat(t);
  for (const i of s)
    if (typeof i != "function")
      throw new TypeError(`Non-function found defined in ${e} with type ${typeof i}`);
}
function merge$1(e, t = [], s) {
  const i = {};
  for (let a = 0; a < e.length; a++) {
    const o = explode(e[a]), l = t[a];
    let f = o;
    (l || s) && (f = wrapWithStateOrWrapper(f, l, s)), mergePair(i, f);
    for (const y of Object.keys(o)) {
      if (shouldIgnoreKey(y))
        continue;
      let g = o[y];
      (l || s) && (g = wrapWithStateOrWrapper(g, l, s));
      const T = i[y] || (i[y] = {});
      mergePair(T, g);
    }
  }
  return i;
}
function wrapWithStateOrWrapper(e, t, s) {
  const i = {};
  for (const a of ["enter", "exit"]) {
    let o = e[a];
    Array.isArray(o) && (o = o.map(function(l) {
      let f = l;
      return t && (f = function(y) {
        l.call(t, y, t);
      }), s && (f = s(t == null ? void 0 : t.key, a, f)), f !== l && (f.toString = () => l.toString()), f;
    }), i[a] = o);
  }
  return i;
}
function ensureEntranceObjects(e) {
  for (const t of Object.keys(e)) {
    if (shouldIgnoreKey(t))
      continue;
    const s = e[t];
    typeof s == "function" && (e[t] = {
      enter: s
    });
  }
}
function ensureCallbackArrays(e) {
  e.enter && !Array.isArray(e.enter) && (e.enter = [e.enter]), e.exit && !Array.isArray(e.exit) && (e.exit = [e.exit]);
}
function wrapCheck(e, t) {
  const s = `is${e}`, i = virtualTypesValidators[s], a = function(o) {
    if (i.call(o))
      return t.apply(this, arguments);
  };
  return a.toString = () => t.toString(), a;
}
function shouldIgnoreKey(e) {
  return e[0] === "_" || e === "enter" || e === "exit" || e === "shouldSkip" || e === "denylist" || e === "noScope" || e === "skipKeys" || e === "blacklist";
}
function mergePair(e, t) {
  for (const s of ["enter", "exit"])
    t[s] && (e[s] = [].concat(e[s] || [], t[s]));
}
var cache = {};
Object.defineProperty(cache, "__esModule", {
  value: !0
});
cache.clear = clear;
cache.clearPath = clearPath;
cache.clearScope = clearScope;
cache.getCachedPaths = getCachedPaths;
cache.getOrCreateCachedPaths = getOrCreateCachedPaths;
cache.scope = cache.path = void 0;
let pathsCache = cache.path = /* @__PURE__ */ new WeakMap();
cache.scope = /* @__PURE__ */ new WeakMap();
function clear() {
  clearPath(), clearScope();
}
function clearPath() {
  cache.path = pathsCache = /* @__PURE__ */ new WeakMap();
}
function clearScope() {
  cache.scope = /* @__PURE__ */ new WeakMap();
}
const nullHub = Object.freeze({});
function getCachedPaths(e, t) {
  var s, i;
  return e = null, (s = pathsCache.get((i = e) != null ? i : nullHub)) == null ? void 0 : s.get(t);
}
function getOrCreateCachedPaths(e, t) {
  var s, i;
  e = null;
  let a = pathsCache.get((s = e) != null ? s : nullHub);
  a || pathsCache.set((i = e) != null ? i : nullHub, a = /* @__PURE__ */ new WeakMap());
  let o = a.get(t);
  return o || a.set(t, o = /* @__PURE__ */ new Map()), o;
}
var traverseNode = {}, context$1 = {}, path = {}, browserExports = {}, browser$1 = {
  get exports() {
    return browserExports;
  },
  set exports(e) {
    browserExports = e;
  }
}, ms, hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var e = 1e3, t = e * 60, s = t * 60, i = s * 24, a = i * 7, o = i * 365.25;
  ms = function(T, S) {
    S = S || {};
    var b = typeof T;
    if (b === "string" && T.length > 0)
      return l(T);
    if (b === "number" && isFinite(T))
      return S.long ? y(T) : f(T);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(T)
    );
  };
  function l(T) {
    if (T = String(T), !(T.length > 100)) {
      var S = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        T
      );
      if (S) {
        var b = parseFloat(S[1]), v = (S[2] || "ms").toLowerCase();
        switch (v) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return b * o;
          case "weeks":
          case "week":
          case "w":
            return b * a;
          case "days":
          case "day":
          case "d":
            return b * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return b * s;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return b * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return b * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return b;
          default:
            return;
        }
      }
    }
  }
  function f(T) {
    var S = Math.abs(T);
    return S >= i ? Math.round(T / i) + "d" : S >= s ? Math.round(T / s) + "h" : S >= t ? Math.round(T / t) + "m" : S >= e ? Math.round(T / e) + "s" : T + "ms";
  }
  function y(T) {
    var S = Math.abs(T);
    return S >= i ? g(T, S, i, "day") : S >= s ? g(T, S, s, "hour") : S >= t ? g(T, S, t, "minute") : S >= e ? g(T, S, e, "second") : T + " ms";
  }
  function g(T, S, b, v) {
    var $ = S >= b * 1.5;
    return Math.round(T / b) + " " + v + ($ ? "s" : "");
  }
  return ms;
}
function setup(e) {
  s.debug = s, s.default = s, s.coerce = y, s.disable = o, s.enable = a, s.enabled = l, s.humanize = requireMs(), s.destroy = g, Object.keys(e).forEach((T) => {
    s[T] = e[T];
  }), s.names = [], s.skips = [], s.formatters = {};
  function t(T) {
    let S = 0;
    for (let b = 0; b < T.length; b++)
      S = (S << 5) - S + T.charCodeAt(b), S |= 0;
    return s.colors[Math.abs(S) % s.colors.length];
  }
  s.selectColor = t;
  function s(T) {
    let S, b = null, v, $;
    function U(...X) {
      if (!U.enabled)
        return;
      const k = U, D = Number(/* @__PURE__ */ new Date()), B = D - (S || D);
      k.diff = B, k.prev = S, k.curr = D, S = D, X[0] = s.coerce(X[0]), typeof X[0] != "string" && X.unshift("%O");
      let Z = 0;
      X[0] = X[0].replace(/%([a-zA-Z%])/g, (q, _) => {
        if (q === "%%")
          return "%";
        Z++;
        const j = s.formatters[_];
        if (typeof j == "function") {
          const V = X[Z];
          q = j.call(k, V), X.splice(Z, 1), Z--;
        }
        return q;
      }), s.formatArgs.call(k, X), (k.log || s.log).apply(k, X);
    }
    return U.namespace = T, U.useColors = s.useColors(), U.color = s.selectColor(T), U.extend = i, U.destroy = s.destroy, Object.defineProperty(U, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => b !== null ? b : (v !== s.namespaces && (v = s.namespaces, $ = s.enabled(T)), $),
      set: (X) => {
        b = X;
      }
    }), typeof s.init == "function" && s.init(U), U;
  }
  function i(T, S) {
    const b = s(this.namespace + (typeof S > "u" ? ":" : S) + T);
    return b.log = this.log, b;
  }
  function a(T) {
    s.save(T), s.namespaces = T, s.names = [], s.skips = [];
    let S;
    const b = (typeof T == "string" ? T : "").split(/[\s,]+/), v = b.length;
    for (S = 0; S < v; S++)
      b[S] && (T = b[S].replace(/\*/g, ".*?"), T[0] === "-" ? s.skips.push(new RegExp("^" + T.slice(1) + "$")) : s.names.push(new RegExp("^" + T + "$")));
  }
  function o() {
    const T = [
      ...s.names.map(f),
      ...s.skips.map(f).map((S) => "-" + S)
    ].join(",");
    return s.enable(""), T;
  }
  function l(T) {
    if (T[T.length - 1] === "*")
      return !0;
    let S, b;
    for (S = 0, b = s.skips.length; S < b; S++)
      if (s.skips[S].test(T))
        return !1;
    for (S = 0, b = s.names.length; S < b; S++)
      if (s.names[S].test(T))
        return !0;
    return !1;
  }
  function f(T) {
    return T.toString().substring(2, T.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function y(T) {
    return T instanceof Error ? T.stack || T.message : T;
  }
  function g() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return s.enable(s.load()), s;
}
var common = setup;
(function(e, t) {
  t.formatArgs = i, t.save = a, t.load = o, t.useColors = s, t.storage = l(), t.destroy = (() => {
    let y = !1;
    return () => {
      y || (y = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function s() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function i(y) {
    if (y[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + y[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
      return;
    const g = "color: " + this.color;
    y.splice(1, 0, g, "color: inherit");
    let T = 0, S = 0;
    y[0].replace(/%[a-zA-Z%]/g, (b) => {
      b !== "%%" && (T++, b === "%c" && (S = T));
    }), y.splice(S, 0, g);
  }
  t.log = console.debug || console.log || (() => {
  });
  function a(y) {
    try {
      y ? t.storage.setItem("debug", y) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function o() {
    let y;
    try {
      y = t.storage.getItem("debug");
    } catch {
    }
    return !y && typeof process < "u" && "env" in process && (y = { BABEL_TYPES_8_BREAKING: !1 }.DEBUG), y;
  }
  function l() {
    try {
      return localStorage;
    } catch {
    }
  }
  e.exports = common(t);
  const { formatters: f } = e.exports;
  f.j = function(y) {
    try {
      return JSON.stringify(y);
    } catch (g) {
      return "[UnexpectedJSONParseError]: " + g.message;
    }
  };
})(browser$1, browserExports);
var scope = {}, renamer = {}, lib$8 = {};
Object.defineProperty(lib$8, "__esModule", {
  value: !0
});
lib$8.default = splitExportDeclaration;
var _t$n = requireLib$1();
const {
  cloneNode: cloneNode$3,
  exportNamedDeclaration,
  exportSpecifier,
  identifier: identifier$4,
  variableDeclaration: variableDeclaration$1,
  variableDeclarator: variableDeclarator$1
} = _t$n;
function splitExportDeclaration(e) {
  if (!e.isExportDeclaration() || e.isExportAllDeclaration())
    throw new Error("Only default and named export declarations can be split.");
  if (e.isExportDefaultDeclaration()) {
    const o = e.get("declaration"), l = o.isFunctionDeclaration() || o.isClassDeclaration(), f = o.isFunctionExpression() || o.isClassExpression(), y = o.isScope() ? o.scope.parent : o.scope;
    let g = o.node.id, T = !1;
    g ? f && y.hasBinding(g.name) && (T = !0, g = y.generateUidIdentifier(g.name)) : (T = !0, g = y.generateUidIdentifier("default"), (l || f) && (o.node.id = cloneNode$3(g)));
    const S = l ? o.node : variableDeclaration$1("var", [variableDeclarator$1(cloneNode$3(g), o.node)]), b = exportNamedDeclaration(null, [exportSpecifier(cloneNode$3(g), identifier$4("default"))]);
    return e.insertAfter(b), e.replaceWith(S), T && y.registerDeclaration(e), e;
  } else if (e.get("specifiers").length > 0)
    throw new Error("It doesn't make sense to split exported specifiers.");
  const t = e.get("declaration"), s = t.getOuterBindingIdentifiers(), i = Object.keys(s).map((o) => exportSpecifier(identifier$4(o), identifier$4(o))), a = exportNamedDeclaration(null, i);
  return e.insertAfter(a), e.replaceWith(t.node), e;
}
var lib$7 = {};
Object.defineProperty(lib$7, "__esModule", {
  value: !0
});
lib$7.default = void 0;
lib$7.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
lib$7.skipAllButComputedKey = function(t) {
  t.skip(), t.node.computed && t.context.maybeQueue(t.get("key"));
};
function requeueComputedKeyAndDecorators(e) {
  const {
    context: t,
    node: s
  } = e;
  if (s.computed && t.maybeQueue(e.get("key")), s.decorators)
    for (const i of e.get("decorators"))
      t.maybeQueue(i);
}
const visitor$2 = {
  FunctionParent(e) {
    e.isArrowFunctionExpression() || (e.skip(), e.isMethod() && requeueComputedKeyAndDecorators(e));
  },
  Property(e) {
    e.isObjectProperty() || (e.skip(), requeueComputedKeyAndDecorators(e));
  }
};
var _default$5 = visitor$2;
lib$7.default = _default$5;
var hasRequiredRenamer;
function requireRenamer() {
  if (hasRequiredRenamer)
    return renamer;
  hasRequiredRenamer = 1, Object.defineProperty(renamer, "__esModule", {
    value: !0
  }), renamer.default = void 0;
  var e = lib$8, t = requireLib$1(), s = lib$7, i = requireTraverseNode(), a = visitors;
  const o = {
    ReferencedIdentifier({
      node: f
    }, y) {
      f.name === y.oldName && (f.name = y.newName);
    },
    Scope(f, y) {
      f.scope.bindingIdentifierEquals(y.oldName, y.binding.identifier) || (f.skip(), f.isMethod() && (0, s.requeueComputedKeyAndDecorators)(f));
    },
    ObjectProperty({
      node: f,
      scope: y
    }, g) {
      const {
        name: T
      } = f.key;
      if (f.shorthand && (T === g.oldName || T === g.newName) && y.getBindingIdentifier(T) === g.binding.identifier) {
        var S;
        f.shorthand = !1, (S = f.extra) != null && S.shorthand && (f.extra.shorthand = !1);
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(f, y) {
      if (f.isVariableDeclaration())
        return;
      const g = f.getOuterBindingIdentifiers();
      for (const T in g)
        T === y.oldName && (g[T].name = y.newName);
    }
  };
  class l {
    constructor(y, g, T) {
      this.newName = T, this.oldName = g, this.binding = y;
    }
    maybeConvertFromExportDeclaration(y) {
      const g = y.parentPath;
      if (g.isExportDeclaration()) {
        if (g.isExportDefaultDeclaration()) {
          const {
            declaration: T
          } = g.node;
          if (t.isDeclaration(T) && !T.id)
            return;
        }
        g.isExportAllDeclaration() || (0, e.default)(g);
      }
    }
    maybeConvertFromClassFunctionDeclaration(y) {
      return y;
    }
    maybeConvertFromClassFunctionExpression(y) {
      return y;
    }
    rename() {
      const {
        binding: y,
        oldName: g,
        newName: T
      } = this, {
        scope: S,
        path: b
      } = y, v = b.find((U) => U.isDeclaration() || U.isFunctionExpression() || U.isClassExpression());
      v && v.getOuterBindingIdentifiers()[g] === y.identifier && this.maybeConvertFromExportDeclaration(v);
      const $ = arguments[0] || S.block;
      (0, i.traverseNode)($, (0, a.explode)(o), S, this, S.path, {
        discriminant: !0
      }), arguments[0] || (S.removeOwnBinding(g), S.bindings[T] = y, this.binding.identifier.name = T), v && (this.maybeConvertFromClassFunctionDeclaration(b), this.maybeConvertFromClassFunctionExpression(b));
    }
  }
  return renamer.default = l, renamer;
}
var binding = {};
Object.defineProperty(binding, "__esModule", {
  value: !0
});
binding.default = void 0;
class Binding {
  constructor({
    identifier: t,
    scope: s,
    path: i,
    kind: a
  }) {
    this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0, this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = t, this.scope = s, this.path = i, this.kind = a, (a === "var" || a === "hoisted") && isDeclaredInLoop(i) && this.reassign(i), this.clearValue();
  }
  deoptValue() {
    this.clearValue(), this.hasDeoptedValue = !0;
  }
  setValue(t) {
    this.hasDeoptedValue || (this.hasValue = !0, this.value = t);
  }
  clearValue() {
    this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
  }
  reassign(t) {
    this.constant = !1, this.constantViolations.indexOf(t) === -1 && this.constantViolations.push(t);
  }
  reference(t) {
    this.referencePaths.indexOf(t) === -1 && (this.referenced = !0, this.references++, this.referencePaths.push(t));
  }
  dereference() {
    this.references--, this.referenced = !!this.references;
  }
}
binding.default = Binding;
function isDeclaredInLoop(e) {
  for (let {
    parentPath: t,
    key: s
  } = e; t; {
    parentPath: t,
    key: s
  } = t) {
    if (t.isFunctionParent())
      return !1;
    if (t.isWhile() || t.isForXStatement() || t.isForStatement() && s === "body")
      return !0;
  }
  return !1;
}
var globalsExports = {}, globals = {
  get exports() {
    return globalsExports;
  },
  set exports(e) {
    globalsExports = e;
  }
};
const builtin = {
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  BigInt: !1,
  BigInt64Array: !1,
  BigUint64Array: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  globalThis: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, es5 = {
  Array: !1,
  Boolean: !1,
  constructor: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  propertyIsEnumerable: !1,
  RangeError: !1,
  ReferenceError: !1,
  RegExp: !1,
  String: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1
}, es2015 = {
  Array: !1,
  ArrayBuffer: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, es2017 = {
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, browser = {
  AbortController: !1,
  AbortSignal: !1,
  addEventListener: !1,
  alert: !1,
  AnalyserNode: !1,
  Animation: !1,
  AnimationEffectReadOnly: !1,
  AnimationEffectTiming: !1,
  AnimationEffectTimingReadOnly: !1,
  AnimationEvent: !1,
  AnimationPlaybackEvent: !1,
  AnimationTimeline: !1,
  applicationCache: !1,
  ApplicationCache: !1,
  ApplicationCacheErrorEvent: !1,
  atob: !1,
  Attr: !1,
  Audio: !1,
  AudioBuffer: !1,
  AudioBufferSourceNode: !1,
  AudioContext: !1,
  AudioDestinationNode: !1,
  AudioListener: !1,
  AudioNode: !1,
  AudioParam: !1,
  AudioProcessingEvent: !1,
  AudioScheduledSourceNode: !1,
  "AudioWorkletGlobalScope ": !1,
  AudioWorkletNode: !1,
  AudioWorkletProcessor: !1,
  BarProp: !1,
  BaseAudioContext: !1,
  BatteryManager: !1,
  BeforeUnloadEvent: !1,
  BiquadFilterNode: !1,
  Blob: !1,
  BlobEvent: !1,
  blur: !1,
  BroadcastChannel: !1,
  btoa: !1,
  BudgetService: !1,
  ByteLengthQueuingStrategy: !1,
  Cache: !1,
  caches: !1,
  CacheStorage: !1,
  cancelAnimationFrame: !1,
  cancelIdleCallback: !1,
  CanvasCaptureMediaStreamTrack: !1,
  CanvasGradient: !1,
  CanvasPattern: !1,
  CanvasRenderingContext2D: !1,
  ChannelMergerNode: !1,
  ChannelSplitterNode: !1,
  CharacterData: !1,
  clearInterval: !1,
  clearTimeout: !1,
  clientInformation: !1,
  ClipboardEvent: !1,
  close: !1,
  closed: !1,
  CloseEvent: !1,
  Comment: !1,
  CompositionEvent: !1,
  confirm: !1,
  console: !1,
  ConstantSourceNode: !1,
  ConvolverNode: !1,
  CountQueuingStrategy: !1,
  createImageBitmap: !1,
  Credential: !1,
  CredentialsContainer: !1,
  crypto: !1,
  Crypto: !1,
  CryptoKey: !1,
  CSS: !1,
  CSSConditionRule: !1,
  CSSFontFaceRule: !1,
  CSSGroupingRule: !1,
  CSSImportRule: !1,
  CSSKeyframeRule: !1,
  CSSKeyframesRule: !1,
  CSSMediaRule: !1,
  CSSNamespaceRule: !1,
  CSSPageRule: !1,
  CSSRule: !1,
  CSSRuleList: !1,
  CSSStyleDeclaration: !1,
  CSSStyleRule: !1,
  CSSStyleSheet: !1,
  CSSSupportsRule: !1,
  CustomElementRegistry: !1,
  customElements: !1,
  CustomEvent: !1,
  DataTransfer: !1,
  DataTransferItem: !1,
  DataTransferItemList: !1,
  defaultstatus: !1,
  defaultStatus: !1,
  DelayNode: !1,
  DeviceMotionEvent: !1,
  DeviceOrientationEvent: !1,
  devicePixelRatio: !1,
  dispatchEvent: !1,
  document: !1,
  Document: !1,
  DocumentFragment: !1,
  DocumentType: !1,
  DOMError: !1,
  DOMException: !1,
  DOMImplementation: !1,
  DOMMatrix: !1,
  DOMMatrixReadOnly: !1,
  DOMParser: !1,
  DOMPoint: !1,
  DOMPointReadOnly: !1,
  DOMQuad: !1,
  DOMRect: !1,
  DOMRectReadOnly: !1,
  DOMStringList: !1,
  DOMStringMap: !1,
  DOMTokenList: !1,
  DragEvent: !1,
  DynamicsCompressorNode: !1,
  Element: !1,
  ErrorEvent: !1,
  event: !1,
  Event: !1,
  EventSource: !1,
  EventTarget: !1,
  external: !1,
  fetch: !1,
  File: !1,
  FileList: !1,
  FileReader: !1,
  find: !1,
  focus: !1,
  FocusEvent: !1,
  FontFace: !1,
  FontFaceSetLoadEvent: !1,
  FormData: !1,
  frameElement: !1,
  frames: !1,
  GainNode: !1,
  Gamepad: !1,
  GamepadButton: !1,
  GamepadEvent: !1,
  getComputedStyle: !1,
  getSelection: !1,
  HashChangeEvent: !1,
  Headers: !1,
  history: !1,
  History: !1,
  HTMLAllCollection: !1,
  HTMLAnchorElement: !1,
  HTMLAreaElement: !1,
  HTMLAudioElement: !1,
  HTMLBaseElement: !1,
  HTMLBodyElement: !1,
  HTMLBRElement: !1,
  HTMLButtonElement: !1,
  HTMLCanvasElement: !1,
  HTMLCollection: !1,
  HTMLContentElement: !1,
  HTMLDataElement: !1,
  HTMLDataListElement: !1,
  HTMLDetailsElement: !1,
  HTMLDialogElement: !1,
  HTMLDirectoryElement: !1,
  HTMLDivElement: !1,
  HTMLDListElement: !1,
  HTMLDocument: !1,
  HTMLElement: !1,
  HTMLEmbedElement: !1,
  HTMLFieldSetElement: !1,
  HTMLFontElement: !1,
  HTMLFormControlsCollection: !1,
  HTMLFormElement: !1,
  HTMLFrameElement: !1,
  HTMLFrameSetElement: !1,
  HTMLHeadElement: !1,
  HTMLHeadingElement: !1,
  HTMLHRElement: !1,
  HTMLHtmlElement: !1,
  HTMLIFrameElement: !1,
  HTMLImageElement: !1,
  HTMLInputElement: !1,
  HTMLLabelElement: !1,
  HTMLLegendElement: !1,
  HTMLLIElement: !1,
  HTMLLinkElement: !1,
  HTMLMapElement: !1,
  HTMLMarqueeElement: !1,
  HTMLMediaElement: !1,
  HTMLMenuElement: !1,
  HTMLMetaElement: !1,
  HTMLMeterElement: !1,
  HTMLModElement: !1,
  HTMLObjectElement: !1,
  HTMLOListElement: !1,
  HTMLOptGroupElement: !1,
  HTMLOptionElement: !1,
  HTMLOptionsCollection: !1,
  HTMLOutputElement: !1,
  HTMLParagraphElement: !1,
  HTMLParamElement: !1,
  HTMLPictureElement: !1,
  HTMLPreElement: !1,
  HTMLProgressElement: !1,
  HTMLQuoteElement: !1,
  HTMLScriptElement: !1,
  HTMLSelectElement: !1,
  HTMLShadowElement: !1,
  HTMLSlotElement: !1,
  HTMLSourceElement: !1,
  HTMLSpanElement: !1,
  HTMLStyleElement: !1,
  HTMLTableCaptionElement: !1,
  HTMLTableCellElement: !1,
  HTMLTableColElement: !1,
  HTMLTableElement: !1,
  HTMLTableRowElement: !1,
  HTMLTableSectionElement: !1,
  HTMLTemplateElement: !1,
  HTMLTextAreaElement: !1,
  HTMLTimeElement: !1,
  HTMLTitleElement: !1,
  HTMLTrackElement: !1,
  HTMLUListElement: !1,
  HTMLUnknownElement: !1,
  HTMLVideoElement: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  IdleDeadline: !1,
  IIRFilterNode: !1,
  Image: !1,
  ImageBitmap: !1,
  ImageBitmapRenderingContext: !1,
  ImageCapture: !1,
  ImageData: !1,
  indexedDB: !1,
  innerHeight: !1,
  innerWidth: !1,
  InputEvent: !1,
  IntersectionObserver: !1,
  IntersectionObserverEntry: !1,
  Intl: !1,
  isSecureContext: !1,
  KeyboardEvent: !1,
  KeyframeEffect: !1,
  KeyframeEffectReadOnly: !1,
  length: !1,
  localStorage: !1,
  location: !0,
  Location: !1,
  locationbar: !1,
  matchMedia: !1,
  MediaDeviceInfo: !1,
  MediaDevices: !1,
  MediaElementAudioSourceNode: !1,
  MediaEncryptedEvent: !1,
  MediaError: !1,
  MediaKeyMessageEvent: !1,
  MediaKeySession: !1,
  MediaKeyStatusMap: !1,
  MediaKeySystemAccess: !1,
  MediaList: !1,
  MediaQueryList: !1,
  MediaQueryListEvent: !1,
  MediaRecorder: !1,
  MediaSettingsRange: !1,
  MediaSource: !1,
  MediaStream: !1,
  MediaStreamAudioDestinationNode: !1,
  MediaStreamAudioSourceNode: !1,
  MediaStreamEvent: !1,
  MediaStreamTrack: !1,
  MediaStreamTrackEvent: !1,
  menubar: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  MIDIAccess: !1,
  MIDIConnectionEvent: !1,
  MIDIInput: !1,
  MIDIInputMap: !1,
  MIDIMessageEvent: !1,
  MIDIOutput: !1,
  MIDIOutputMap: !1,
  MIDIPort: !1,
  MimeType: !1,
  MimeTypeArray: !1,
  MouseEvent: !1,
  moveBy: !1,
  moveTo: !1,
  MutationEvent: !1,
  MutationObserver: !1,
  MutationRecord: !1,
  name: !1,
  NamedNodeMap: !1,
  NavigationPreloadManager: !1,
  navigator: !1,
  Navigator: !1,
  NetworkInformation: !1,
  Node: !1,
  NodeFilter: !1,
  NodeIterator: !1,
  NodeList: !1,
  Notification: !1,
  OfflineAudioCompletionEvent: !1,
  OfflineAudioContext: !1,
  offscreenBuffering: !1,
  OffscreenCanvas: !0,
  onabort: !0,
  onafterprint: !0,
  onanimationend: !0,
  onanimationiteration: !0,
  onanimationstart: !0,
  onappinstalled: !0,
  onauxclick: !0,
  onbeforeinstallprompt: !0,
  onbeforeprint: !0,
  onbeforeunload: !0,
  onblur: !0,
  oncancel: !0,
  oncanplay: !0,
  oncanplaythrough: !0,
  onchange: !0,
  onclick: !0,
  onclose: !0,
  oncontextmenu: !0,
  oncuechange: !0,
  ondblclick: !0,
  ondevicemotion: !0,
  ondeviceorientation: !0,
  ondeviceorientationabsolute: !0,
  ondrag: !0,
  ondragend: !0,
  ondragenter: !0,
  ondragleave: !0,
  ondragover: !0,
  ondragstart: !0,
  ondrop: !0,
  ondurationchange: !0,
  onemptied: !0,
  onended: !0,
  onerror: !0,
  onfocus: !0,
  ongotpointercapture: !0,
  onhashchange: !0,
  oninput: !0,
  oninvalid: !0,
  onkeydown: !0,
  onkeypress: !0,
  onkeyup: !0,
  onlanguagechange: !0,
  onload: !0,
  onloadeddata: !0,
  onloadedmetadata: !0,
  onloadstart: !0,
  onlostpointercapture: !0,
  onmessage: !0,
  onmessageerror: !0,
  onmousedown: !0,
  onmouseenter: !0,
  onmouseleave: !0,
  onmousemove: !0,
  onmouseout: !0,
  onmouseover: !0,
  onmouseup: !0,
  onmousewheel: !0,
  onoffline: !0,
  ononline: !0,
  onpagehide: !0,
  onpageshow: !0,
  onpause: !0,
  onplay: !0,
  onplaying: !0,
  onpointercancel: !0,
  onpointerdown: !0,
  onpointerenter: !0,
  onpointerleave: !0,
  onpointermove: !0,
  onpointerout: !0,
  onpointerover: !0,
  onpointerup: !0,
  onpopstate: !0,
  onprogress: !0,
  onratechange: !0,
  onrejectionhandled: !0,
  onreset: !0,
  onresize: !0,
  onscroll: !0,
  onsearch: !0,
  onseeked: !0,
  onseeking: !0,
  onselect: !0,
  onstalled: !0,
  onstorage: !0,
  onsubmit: !0,
  onsuspend: !0,
  ontimeupdate: !0,
  ontoggle: !0,
  ontransitionend: !0,
  onunhandledrejection: !0,
  onunload: !0,
  onvolumechange: !0,
  onwaiting: !0,
  onwheel: !0,
  open: !1,
  openDatabase: !1,
  opener: !1,
  Option: !1,
  origin: !1,
  OscillatorNode: !1,
  outerHeight: !1,
  outerWidth: !1,
  PageTransitionEvent: !1,
  pageXOffset: !1,
  pageYOffset: !1,
  PannerNode: !1,
  parent: !1,
  Path2D: !1,
  PaymentAddress: !1,
  PaymentRequest: !1,
  PaymentRequestUpdateEvent: !1,
  PaymentResponse: !1,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceLongTaskTiming: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceNavigationTiming: !1,
  PerformanceObserver: !1,
  PerformanceObserverEntryList: !1,
  PerformancePaintTiming: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  PeriodicWave: !1,
  Permissions: !1,
  PermissionStatus: !1,
  personalbar: !1,
  PhotoCapabilities: !1,
  Plugin: !1,
  PluginArray: !1,
  PointerEvent: !1,
  PopStateEvent: !1,
  postMessage: !1,
  Presentation: !1,
  PresentationAvailability: !1,
  PresentationConnection: !1,
  PresentationConnectionAvailableEvent: !1,
  PresentationConnectionCloseEvent: !1,
  PresentationConnectionList: !1,
  PresentationReceiver: !1,
  PresentationRequest: !1,
  print: !1,
  ProcessingInstruction: !1,
  ProgressEvent: !1,
  PromiseRejectionEvent: !1,
  prompt: !1,
  PushManager: !1,
  PushSubscription: !1,
  PushSubscriptionOptions: !1,
  queueMicrotask: !1,
  RadioNodeList: !1,
  Range: !1,
  ReadableStream: !1,
  registerProcessor: !1,
  RemotePlayback: !1,
  removeEventListener: !1,
  Request: !1,
  requestAnimationFrame: !1,
  requestIdleCallback: !1,
  resizeBy: !1,
  ResizeObserver: !1,
  ResizeObserverEntry: !1,
  resizeTo: !1,
  Response: !1,
  RTCCertificate: !1,
  RTCDataChannel: !1,
  RTCDataChannelEvent: !1,
  RTCDtlsTransport: !1,
  RTCIceCandidate: !1,
  RTCIceGatherer: !1,
  RTCIceTransport: !1,
  RTCPeerConnection: !1,
  RTCPeerConnectionIceEvent: !1,
  RTCRtpContributingSource: !1,
  RTCRtpReceiver: !1,
  RTCRtpSender: !1,
  RTCSctpTransport: !1,
  RTCSessionDescription: !1,
  RTCStatsReport: !1,
  RTCTrackEvent: !1,
  screen: !1,
  Screen: !1,
  screenLeft: !1,
  ScreenOrientation: !1,
  screenTop: !1,
  screenX: !1,
  screenY: !1,
  ScriptProcessorNode: !1,
  scroll: !1,
  scrollbars: !1,
  scrollBy: !1,
  scrollTo: !1,
  scrollX: !1,
  scrollY: !1,
  SecurityPolicyViolationEvent: !1,
  Selection: !1,
  self: !1,
  ServiceWorker: !1,
  ServiceWorkerContainer: !1,
  ServiceWorkerRegistration: !1,
  sessionStorage: !1,
  setInterval: !1,
  setTimeout: !1,
  ShadowRoot: !1,
  SharedWorker: !1,
  SourceBuffer: !1,
  SourceBufferList: !1,
  speechSynthesis: !1,
  SpeechSynthesisEvent: !1,
  SpeechSynthesisUtterance: !1,
  StaticRange: !1,
  status: !1,
  statusbar: !1,
  StereoPannerNode: !1,
  stop: !1,
  Storage: !1,
  StorageEvent: !1,
  StorageManager: !1,
  styleMedia: !1,
  StyleSheet: !1,
  StyleSheetList: !1,
  SubtleCrypto: !1,
  SVGAElement: !1,
  SVGAngle: !1,
  SVGAnimatedAngle: !1,
  SVGAnimatedBoolean: !1,
  SVGAnimatedEnumeration: !1,
  SVGAnimatedInteger: !1,
  SVGAnimatedLength: !1,
  SVGAnimatedLengthList: !1,
  SVGAnimatedNumber: !1,
  SVGAnimatedNumberList: !1,
  SVGAnimatedPreserveAspectRatio: !1,
  SVGAnimatedRect: !1,
  SVGAnimatedString: !1,
  SVGAnimatedTransformList: !1,
  SVGAnimateElement: !1,
  SVGAnimateMotionElement: !1,
  SVGAnimateTransformElement: !1,
  SVGAnimationElement: !1,
  SVGCircleElement: !1,
  SVGClipPathElement: !1,
  SVGComponentTransferFunctionElement: !1,
  SVGDefsElement: !1,
  SVGDescElement: !1,
  SVGDiscardElement: !1,
  SVGElement: !1,
  SVGEllipseElement: !1,
  SVGFEBlendElement: !1,
  SVGFEColorMatrixElement: !1,
  SVGFEComponentTransferElement: !1,
  SVGFECompositeElement: !1,
  SVGFEConvolveMatrixElement: !1,
  SVGFEDiffuseLightingElement: !1,
  SVGFEDisplacementMapElement: !1,
  SVGFEDistantLightElement: !1,
  SVGFEDropShadowElement: !1,
  SVGFEFloodElement: !1,
  SVGFEFuncAElement: !1,
  SVGFEFuncBElement: !1,
  SVGFEFuncGElement: !1,
  SVGFEFuncRElement: !1,
  SVGFEGaussianBlurElement: !1,
  SVGFEImageElement: !1,
  SVGFEMergeElement: !1,
  SVGFEMergeNodeElement: !1,
  SVGFEMorphologyElement: !1,
  SVGFEOffsetElement: !1,
  SVGFEPointLightElement: !1,
  SVGFESpecularLightingElement: !1,
  SVGFESpotLightElement: !1,
  SVGFETileElement: !1,
  SVGFETurbulenceElement: !1,
  SVGFilterElement: !1,
  SVGForeignObjectElement: !1,
  SVGGElement: !1,
  SVGGeometryElement: !1,
  SVGGradientElement: !1,
  SVGGraphicsElement: !1,
  SVGImageElement: !1,
  SVGLength: !1,
  SVGLengthList: !1,
  SVGLinearGradientElement: !1,
  SVGLineElement: !1,
  SVGMarkerElement: !1,
  SVGMaskElement: !1,
  SVGMatrix: !1,
  SVGMetadataElement: !1,
  SVGMPathElement: !1,
  SVGNumber: !1,
  SVGNumberList: !1,
  SVGPathElement: !1,
  SVGPatternElement: !1,
  SVGPoint: !1,
  SVGPointList: !1,
  SVGPolygonElement: !1,
  SVGPolylineElement: !1,
  SVGPreserveAspectRatio: !1,
  SVGRadialGradientElement: !1,
  SVGRect: !1,
  SVGRectElement: !1,
  SVGScriptElement: !1,
  SVGSetElement: !1,
  SVGStopElement: !1,
  SVGStringList: !1,
  SVGStyleElement: !1,
  SVGSVGElement: !1,
  SVGSwitchElement: !1,
  SVGSymbolElement: !1,
  SVGTextContentElement: !1,
  SVGTextElement: !1,
  SVGTextPathElement: !1,
  SVGTextPositioningElement: !1,
  SVGTitleElement: !1,
  SVGTransform: !1,
  SVGTransformList: !1,
  SVGTSpanElement: !1,
  SVGUnitTypes: !1,
  SVGUseElement: !1,
  SVGViewElement: !1,
  TaskAttributionTiming: !1,
  Text: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  TextEvent: !1,
  TextMetrics: !1,
  TextTrack: !1,
  TextTrackCue: !1,
  TextTrackCueList: !1,
  TextTrackList: !1,
  TimeRanges: !1,
  toolbar: !1,
  top: !1,
  Touch: !1,
  TouchEvent: !1,
  TouchList: !1,
  TrackEvent: !1,
  TransitionEvent: !1,
  TreeWalker: !1,
  UIEvent: !1,
  URL: !1,
  URLSearchParams: !1,
  ValidityState: !1,
  visualViewport: !1,
  VisualViewport: !1,
  VTTCue: !1,
  WaveShaperNode: !1,
  WebAssembly: !1,
  WebGL2RenderingContext: !1,
  WebGLActiveInfo: !1,
  WebGLBuffer: !1,
  WebGLContextEvent: !1,
  WebGLFramebuffer: !1,
  WebGLProgram: !1,
  WebGLQuery: !1,
  WebGLRenderbuffer: !1,
  WebGLRenderingContext: !1,
  WebGLSampler: !1,
  WebGLShader: !1,
  WebGLShaderPrecisionFormat: !1,
  WebGLSync: !1,
  WebGLTexture: !1,
  WebGLTransformFeedback: !1,
  WebGLUniformLocation: !1,
  WebGLVertexArrayObject: !1,
  WebSocket: !1,
  WheelEvent: !1,
  window: !1,
  Window: !1,
  Worker: !1,
  WritableStream: !1,
  XMLDocument: !1,
  XMLHttpRequest: !1,
  XMLHttpRequestEventTarget: !1,
  XMLHttpRequestUpload: !1,
  XMLSerializer: !1,
  XPathEvaluator: !1,
  XPathExpression: !1,
  XPathResult: !1,
  XSLTProcessor: !1
}, worker = {
  addEventListener: !1,
  applicationCache: !1,
  atob: !1,
  Blob: !1,
  BroadcastChannel: !1,
  btoa: !1,
  Cache: !1,
  caches: !1,
  clearInterval: !1,
  clearTimeout: !1,
  close: !0,
  console: !1,
  fetch: !1,
  FileReaderSync: !1,
  FormData: !1,
  Headers: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  ImageData: !1,
  importScripts: !0,
  indexedDB: !1,
  location: !1,
  MessageChannel: !1,
  MessagePort: !1,
  name: !1,
  navigator: !1,
  Notification: !1,
  onclose: !0,
  onconnect: !0,
  onerror: !0,
  onlanguagechange: !0,
  onmessage: !0,
  onoffline: !0,
  ononline: !0,
  onrejectionhandled: !0,
  onunhandledrejection: !0,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  postMessage: !0,
  Promise: !1,
  queueMicrotask: !1,
  removeEventListener: !1,
  Request: !1,
  Response: !1,
  self: !0,
  ServiceWorkerRegistration: !1,
  setInterval: !1,
  setTimeout: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1,
  WebSocket: !1,
  Worker: !1,
  WorkerGlobalScope: !1,
  XMLHttpRequest: !1
}, node$1 = {
  __dirname: !1,
  __filename: !1,
  Buffer: !1,
  clearImmediate: !1,
  clearInterval: !1,
  clearTimeout: !1,
  console: !1,
  exports: !0,
  global: !1,
  Intl: !1,
  module: !1,
  process: !1,
  queueMicrotask: !1,
  require: !1,
  setImmediate: !1,
  setInterval: !1,
  setTimeout: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1
}, commonjs = {
  exports: !0,
  global: !1,
  module: !1,
  require: !1
}, amd = {
  define: !1,
  require: !1
}, mocha = {
  after: !1,
  afterEach: !1,
  before: !1,
  beforeEach: !1,
  context: !1,
  describe: !1,
  it: !1,
  mocha: !1,
  run: !1,
  setup: !1,
  specify: !1,
  suite: !1,
  suiteSetup: !1,
  suiteTeardown: !1,
  teardown: !1,
  test: !1,
  xcontext: !1,
  xdescribe: !1,
  xit: !1,
  xspecify: !1
}, jasmine = {
  afterAll: !1,
  afterEach: !1,
  beforeAll: !1,
  beforeEach: !1,
  describe: !1,
  expect: !1,
  fail: !1,
  fdescribe: !1,
  fit: !1,
  it: !1,
  jasmine: !1,
  pending: !1,
  runs: !1,
  spyOn: !1,
  spyOnProperty: !1,
  waits: !1,
  waitsFor: !1,
  xdescribe: !1,
  xit: !1
}, jest = {
  afterAll: !1,
  afterEach: !1,
  beforeAll: !1,
  beforeEach: !1,
  describe: !1,
  expect: !1,
  fdescribe: !1,
  fit: !1,
  it: !1,
  jest: !1,
  pit: !1,
  require: !1,
  test: !1,
  xdescribe: !1,
  xit: !1,
  xtest: !1
}, qunit = {
  asyncTest: !1,
  deepEqual: !1,
  equal: !1,
  expect: !1,
  module: !1,
  notDeepEqual: !1,
  notEqual: !1,
  notOk: !1,
  notPropEqual: !1,
  notStrictEqual: !1,
  ok: !1,
  propEqual: !1,
  QUnit: !1,
  raises: !1,
  start: !1,
  stop: !1,
  strictEqual: !1,
  test: !1,
  throws: !1
}, phantomjs = {
  console: !0,
  exports: !0,
  phantom: !0,
  require: !0,
  WebPage: !0
}, couch = {
  emit: !1,
  exports: !1,
  getRow: !1,
  log: !1,
  module: !1,
  provides: !1,
  require: !1,
  respond: !1,
  send: !1,
  start: !1,
  sum: !1
}, rhino = {
  defineClass: !1,
  deserialize: !1,
  gc: !1,
  help: !1,
  importClass: !1,
  importPackage: !1,
  java: !1,
  load: !1,
  loadClass: !1,
  Packages: !1,
  print: !1,
  quit: !1,
  readFile: !1,
  readUrl: !1,
  runCommand: !1,
  seal: !1,
  serialize: !1,
  spawn: !1,
  sync: !1,
  toint32: !1,
  version: !1
}, nashorn = {
  __DIR__: !1,
  __FILE__: !1,
  __LINE__: !1,
  com: !1,
  edu: !1,
  exit: !1,
  java: !1,
  Java: !1,
  javafx: !1,
  JavaImporter: !1,
  javax: !1,
  JSAdapter: !1,
  load: !1,
  loadWithNewGlobal: !1,
  org: !1,
  Packages: !1,
  print: !1,
  quit: !1
}, wsh = {
  ActiveXObject: !0,
  Enumerator: !0,
  GetObject: !0,
  ScriptEngine: !0,
  ScriptEngineBuildVersion: !0,
  ScriptEngineMajorVersion: !0,
  ScriptEngineMinorVersion: !0,
  VBArray: !0,
  WScript: !0,
  WSH: !0,
  XDomainRequest: !0
}, jquery = {
  $: !1,
  jQuery: !1
}, yui = {
  YAHOO: !1,
  YAHOO_config: !1,
  YUI: !1,
  YUI_config: !1
}, shelljs = {
  cat: !1,
  cd: !1,
  chmod: !1,
  config: !1,
  cp: !1,
  dirs: !1,
  echo: !1,
  env: !1,
  error: !1,
  exec: !1,
  exit: !1,
  find: !1,
  grep: !1,
  ln: !1,
  ls: !1,
  mkdir: !1,
  mv: !1,
  popd: !1,
  pushd: !1,
  pwd: !1,
  rm: !1,
  sed: !1,
  set: !1,
  target: !1,
  tempdir: !1,
  test: !1,
  touch: !1,
  which: !1
}, prototypejs = {
  $: !1,
  $$: !1,
  $A: !1,
  $break: !1,
  $continue: !1,
  $F: !1,
  $H: !1,
  $R: !1,
  $w: !1,
  Abstract: !1,
  Ajax: !1,
  Autocompleter: !1,
  Builder: !1,
  Class: !1,
  Control: !1,
  Draggable: !1,
  Draggables: !1,
  Droppables: !1,
  Effect: !1,
  Element: !1,
  Enumerable: !1,
  Event: !1,
  Field: !1,
  Form: !1,
  Hash: !1,
  Insertion: !1,
  ObjectRange: !1,
  PeriodicalExecuter: !1,
  Position: !1,
  Prototype: !1,
  Scriptaculous: !1,
  Selector: !1,
  Sortable: !1,
  SortableObserver: !1,
  Sound: !1,
  Template: !1,
  Toggle: !1,
  Try: !1
}, meteor = {
  _: !1,
  $: !1,
  Accounts: !1,
  AccountsClient: !1,
  AccountsCommon: !1,
  AccountsServer: !1,
  App: !1,
  Assets: !1,
  Blaze: !1,
  check: !1,
  Cordova: !1,
  DDP: !1,
  DDPRateLimiter: !1,
  DDPServer: !1,
  Deps: !1,
  EJSON: !1,
  Email: !1,
  HTTP: !1,
  Log: !1,
  Match: !1,
  Meteor: !1,
  Mongo: !1,
  MongoInternals: !1,
  Npm: !1,
  Package: !1,
  Plugin: !1,
  process: !1,
  Random: !1,
  ReactiveDict: !1,
  ReactiveVar: !1,
  Router: !1,
  ServiceConfiguration: !1,
  Session: !1,
  share: !1,
  Spacebars: !1,
  Template: !1,
  Tinytest: !1,
  Tracker: !1,
  UI: !1,
  Utils: !1,
  WebApp: !1,
  WebAppInternals: !1
}, mongo = {
  _isWindows: !1,
  _rand: !1,
  BulkWriteResult: !1,
  cat: !1,
  cd: !1,
  connect: !1,
  db: !1,
  getHostName: !1,
  getMemInfo: !1,
  hostname: !1,
  ISODate: !1,
  listFiles: !1,
  load: !1,
  ls: !1,
  md5sumFile: !1,
  mkdir: !1,
  Mongo: !1,
  NumberInt: !1,
  NumberLong: !1,
  ObjectId: !1,
  PlanCache: !1,
  print: !1,
  printjson: !1,
  pwd: !1,
  quit: !1,
  removeFile: !1,
  rs: !1,
  sh: !1,
  UUID: !1,
  version: !1,
  WriteResult: !1
}, applescript = {
  $: !1,
  Application: !1,
  Automation: !1,
  console: !1,
  delay: !1,
  Library: !1,
  ObjC: !1,
  ObjectSpecifier: !1,
  Path: !1,
  Progress: !1,
  Ref: !1
}, serviceworker = {
  addEventListener: !1,
  applicationCache: !1,
  atob: !1,
  Blob: !1,
  BroadcastChannel: !1,
  btoa: !1,
  Cache: !1,
  caches: !1,
  CacheStorage: !1,
  clearInterval: !1,
  clearTimeout: !1,
  Client: !1,
  clients: !1,
  Clients: !1,
  close: !0,
  console: !1,
  ExtendableEvent: !1,
  ExtendableMessageEvent: !1,
  fetch: !1,
  FetchEvent: !1,
  FileReaderSync: !1,
  FormData: !1,
  Headers: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  ImageData: !1,
  importScripts: !1,
  indexedDB: !1,
  location: !1,
  MessageChannel: !1,
  MessagePort: !1,
  name: !1,
  navigator: !1,
  Notification: !1,
  onclose: !0,
  onconnect: !0,
  onerror: !0,
  onfetch: !0,
  oninstall: !0,
  onlanguagechange: !0,
  onmessage: !0,
  onmessageerror: !0,
  onnotificationclick: !0,
  onnotificationclose: !0,
  onoffline: !0,
  ononline: !0,
  onpush: !0,
  onpushsubscriptionchange: !0,
  onrejectionhandled: !0,
  onsync: !0,
  onunhandledrejection: !0,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  postMessage: !0,
  Promise: !1,
  queueMicrotask: !1,
  registration: !1,
  removeEventListener: !1,
  Request: !1,
  Response: !1,
  self: !1,
  ServiceWorker: !1,
  ServiceWorkerContainer: !1,
  ServiceWorkerGlobalScope: !1,
  ServiceWorkerMessageEvent: !1,
  ServiceWorkerRegistration: !1,
  setInterval: !1,
  setTimeout: !1,
  skipWaiting: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1,
  WebSocket: !1,
  WindowClient: !1,
  Worker: !1,
  WorkerGlobalScope: !1,
  XMLHttpRequest: !1
}, atomtest = {
  advanceClock: !1,
  fakeClearInterval: !1,
  fakeClearTimeout: !1,
  fakeSetInterval: !1,
  fakeSetTimeout: !1,
  resetTimeouts: !1,
  waitsForPromise: !1
}, embertest = {
  andThen: !1,
  click: !1,
  currentPath: !1,
  currentRouteName: !1,
  currentURL: !1,
  fillIn: !1,
  find: !1,
  findAll: !1,
  findWithAssert: !1,
  keyEvent: !1,
  pauseTest: !1,
  resumeTest: !1,
  triggerEvent: !1,
  visit: !1,
  wait: !1
}, protractor = {
  $: !1,
  $$: !1,
  browser: !1,
  by: !1,
  By: !1,
  DartObject: !1,
  element: !1,
  protractor: !1
}, webextensions = {
  browser: !1,
  chrome: !1,
  opr: !1
}, greasemonkey = {
  cloneInto: !1,
  createObjectIn: !1,
  exportFunction: !1,
  GM: !1,
  GM_addStyle: !1,
  GM_deleteValue: !1,
  GM_getResourceText: !1,
  GM_getResourceURL: !1,
  GM_getValue: !1,
  GM_info: !1,
  GM_listValues: !1,
  GM_log: !1,
  GM_openInTab: !1,
  GM_registerMenuCommand: !1,
  GM_setClipboard: !1,
  GM_setValue: !1,
  GM_xmlhttpRequest: !1,
  unsafeWindow: !1
}, devtools = {
  $: !1,
  $_: !1,
  $$: !1,
  $0: !1,
  $1: !1,
  $2: !1,
  $3: !1,
  $4: !1,
  $x: !1,
  chrome: !1,
  clear: !1,
  copy: !1,
  debug: !1,
  dir: !1,
  dirxml: !1,
  getEventListeners: !1,
  inspect: !1,
  keys: !1,
  monitor: !1,
  monitorEvents: !1,
  profile: !1,
  profileEnd: !1,
  queryObjects: !1,
  table: !1,
  undebug: !1,
  unmonitor: !1,
  unmonitorEvents: !1,
  values: !1
}, require$$0 = {
  builtin,
  es5,
  es2015,
  es2017,
  browser,
  worker,
  node: node$1,
  commonjs,
  amd,
  mocha,
  jasmine,
  jest,
  qunit,
  phantomjs,
  couch,
  rhino,
  nashorn,
  wsh,
  jquery,
  yui,
  shelljs,
  prototypejs,
  meteor,
  mongo,
  applescript,
  serviceworker,
  atomtest,
  embertest,
  protractor,
  "shared-node-browser": {
    clearInterval: !1,
    clearTimeout: !1,
    console: !1,
    setInterval: !1,
    setTimeout: !1,
    URL: !1,
    URLSearchParams: !1
  },
  webextensions,
  greasemonkey,
  devtools
};
(function(e) {
  e.exports = require$$0;
})(globals);
var hasRequiredScope;
function requireScope() {
  if (hasRequiredScope)
    return scope;
  hasRequiredScope = 1, Object.defineProperty(scope, "__esModule", {
    value: !0
  }), scope.default = void 0;
  var e = requireRenamer(), t = requireLib(), s = binding, i = globalsExports, a = requireLib$1(), o = a, l = cache, f = visitors;
  const {
    NOT_LOCAL_BINDING: y,
    callExpression: g,
    cloneNode: T,
    getBindingIdentifiers: S,
    identifier: b,
    isArrayExpression: v,
    isBinary: $,
    isClass: U,
    isClassBody: X,
    isClassDeclaration: k,
    isExportAllDeclaration: D,
    isExportDefaultDeclaration: B,
    isExportNamedDeclaration: Z,
    isFunctionDeclaration: H,
    isIdentifier: q,
    isImportDeclaration: _,
    isLiteral: j,
    isMethod: V,
    isModuleSpecifier: ue,
    isNullLiteral: ee,
    isObjectExpression: se,
    isProperty: be,
    isPureish: ve,
    isRegExpLiteral: F,
    isSuper: R,
    isTaggedTemplateExpression: K,
    isTemplateLiteral: z,
    isThisExpression: re,
    isUnaryExpression: ie,
    isVariableDeclaration: fe,
    matchesPattern: ce,
    memberExpression: Pe,
    numericLiteral: Ce,
    toIdentifier: _e,
    variableDeclaration: ge,
    variableDeclarator: xe,
    isRecordExpression: we,
    isTupleExpression: G,
    isObjectProperty: W,
    isTopicReference: te,
    isMetaProperty: oe,
    isPrivateName: me,
    isExportDeclaration: pe,
    buildUndefinedNode: ye
  } = a;
  function le(J, A) {
    switch (J == null ? void 0 : J.type) {
      default:
        if (_(J) || pe(J)) {
          var N;
          if ((D(J) || Z(J) || _(J)) && J.source)
            le(J.source, A);
          else if ((Z(J) || _(J)) && (N = J.specifiers) != null && N.length)
            for (const Y of J.specifiers)
              le(Y, A);
          else
            (B(J) || Z(J)) && J.declaration && le(J.declaration, A);
        } else
          ue(J) ? le(J.local, A) : j(J) && !ee(J) && !F(J) && !z(J) && A.push(J.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        le(J.object, A), le(J.property, A);
        break;
      case "Identifier":
      case "JSXIdentifier":
        A.push(J.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        le(J.callee, A);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (const Y of J.properties)
          le(Y, A);
        break;
      case "SpreadElement":
      case "RestElement":
        le(J.argument, A);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        le(J.key, A);
        break;
      case "ThisExpression":
        A.push("this");
        break;
      case "Super":
        A.push("super");
        break;
      case "Import":
        A.push("import");
        break;
      case "DoExpression":
        A.push("do");
        break;
      case "YieldExpression":
        A.push("yield"), le(J.argument, A);
        break;
      case "AwaitExpression":
        A.push("await"), le(J.argument, A);
        break;
      case "AssignmentExpression":
        le(J.left, A);
        break;
      case "VariableDeclarator":
        le(J.id, A);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        le(J.id, A);
        break;
      case "PrivateName":
        le(J.id, A);
        break;
      case "ParenthesizedExpression":
        le(J.expression, A);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        le(J.argument, A);
        break;
      case "MetaProperty":
        le(J.meta, A), le(J.property, A);
        break;
      case "JSXElement":
        le(J.openingElement, A);
        break;
      case "JSXOpeningElement":
        le(J.name, A);
        break;
      case "JSXFragment":
        le(J.openingFragment, A);
        break;
      case "JSXOpeningFragment":
        A.push("Fragment");
        break;
      case "JSXNamespacedName":
        le(J.namespace, A), le(J.name, A);
        break;
    }
  }
  const he = {
    ForStatement(J) {
      const A = J.get("init");
      if (A.isVar()) {
        const {
          scope: N
        } = J;
        (N.getFunctionParent() || N.getProgramParent()).registerBinding("var", A);
      }
    },
    Declaration(J) {
      if (J.isBlockScoped() || J.isImportDeclaration() || J.isExportDeclaration())
        return;
      (J.scope.getFunctionParent() || J.scope.getProgramParent()).registerDeclaration(J);
    },
    ImportDeclaration(J) {
      J.scope.getBlockParent().registerDeclaration(J);
    },
    ReferencedIdentifier(J, A) {
      A.references.push(J);
    },
    ForXStatement(J, A) {
      const N = J.get("left");
      if (N.isPattern() || N.isIdentifier())
        A.constantViolations.push(J);
      else if (N.isVar()) {
        const {
          scope: Y
        } = J;
        (Y.getFunctionParent() || Y.getProgramParent()).registerBinding("var", N);
      }
    },
    ExportDeclaration: {
      exit(J) {
        const {
          node: A,
          scope: N
        } = J;
        if (D(A))
          return;
        const Y = A.declaration;
        if (k(Y) || H(Y)) {
          const ne = Y.id;
          if (!ne)
            return;
          const de = N.getBinding(ne.name);
          de == null || de.reference(J);
        } else if (fe(Y))
          for (const ne of Y.declarations)
            for (const de of Object.keys(S(ne))) {
              const Ae = N.getBinding(de);
              Ae == null || Ae.reference(J);
            }
      }
    },
    LabeledStatement(J) {
      J.scope.getBlockParent().registerDeclaration(J);
    },
    AssignmentExpression(J, A) {
      A.assignments.push(J);
    },
    UpdateExpression(J, A) {
      A.constantViolations.push(J);
    },
    UnaryExpression(J, A) {
      J.node.operator === "delete" && A.constantViolations.push(J);
    },
    BlockScoped(J) {
      let A = J.scope;
      if (A.path === J && (A = A.parent), A.getBlockParent().registerDeclaration(J), J.isClassDeclaration() && J.node.id) {
        const ne = J.node.id.name;
        J.scope.bindings[ne] = J.scope.parent.getBinding(ne);
      }
    },
    CatchClause(J) {
      J.scope.registerBinding("let", J);
    },
    Function(J) {
      const A = J.get("params");
      for (const N of A)
        J.scope.registerBinding("param", N);
      J.isFunctionExpression() && J.has("id") && !J.get("id").node[y] && J.scope.registerBinding("local", J.get("id"), J);
    },
    ClassExpression(J) {
      J.has("id") && !J.get("id").node[y] && J.scope.registerBinding("local", J);
    }
  };
  let Se = 0;
  class Ie {
    constructor(A) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
      const {
        node: N
      } = A, Y = l.scope.get(N);
      if ((Y == null ? void 0 : Y.path) === A)
        return Y;
      l.scope.set(N, this), this.uid = Se++, this.block = N, this.path = A, this.labels = /* @__PURE__ */ new Map(), this.inited = !1;
    }
    get parent() {
      var A;
      let N, Y = this.path;
      do {
        const ne = Y.key === "key" || Y.listKey === "decorators";
        Y = Y.parentPath, ne && Y.isMethod() && (Y = Y.parentPath), Y && Y.isScope() && (N = Y);
      } while (Y && !N);
      return (A = N) == null ? void 0 : A.scope;
    }
    get parentBlock() {
      return this.path.parent;
    }
    get hub() {
      return this.path.hub;
    }
    traverse(A, N, Y) {
      (0, t.default)(A, N, this, Y, this.path);
    }
    generateDeclaredUidIdentifier(A) {
      const N = this.generateUidIdentifier(A);
      return this.push({
        id: N
      }), T(N);
    }
    generateUidIdentifier(A) {
      return b(this.generateUid(A));
    }
    generateUid(A = "temp") {
      A = _e(A).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      let N, Y = 1;
      do
        N = this._generateUid(A, Y), Y++;
      while (this.hasLabel(N) || this.hasBinding(N) || this.hasGlobal(N) || this.hasReference(N));
      const ne = this.getProgramParent();
      return ne.references[N] = !0, ne.uids[N] = !0, N;
    }
    _generateUid(A, N) {
      let Y = A;
      return N > 1 && (Y += N), `_${Y}`;
    }
    generateUidBasedOnNode(A, N) {
      const Y = [];
      le(A, Y);
      let ne = Y.join("$");
      return ne = ne.replace(/^_/, "") || N || "ref", this.generateUid(ne.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(A, N) {
      return b(this.generateUidBasedOnNode(A, N));
    }
    isStatic(A) {
      if (re(A) || R(A) || te(A))
        return !0;
      if (q(A)) {
        const N = this.getBinding(A.name);
        return N ? N.constant : this.hasBinding(A.name);
      }
      return !1;
    }
    maybeGenerateMemoised(A, N) {
      if (this.isStatic(A))
        return null;
      {
        const Y = this.generateUidIdentifierBasedOnNode(A);
        return N ? Y : (this.push({
          id: Y
        }), T(Y));
      }
    }
    checkBlockScopedCollisions(A, N, Y, ne) {
      if (N === "param" || A.kind === "local")
        return;
      if (N === "let" || A.kind === "let" || A.kind === "const" || A.kind === "module" || A.kind === "param" && N === "const")
        throw this.hub.buildError(ne, `Duplicate declaration "${Y}"`, TypeError);
    }
    rename(A, N) {
      const Y = this.getBinding(A);
      Y && (N || (N = this.generateUidIdentifier(A).name), new e.default(Y, A, N).rename(arguments[2]));
    }
    _renameFromMap(A, N, Y, ne) {
      A[N] && (A[Y] = ne, A[N] = null);
    }
    dump() {
      const A = "-".repeat(60);
      console.log(A);
      let N = this;
      do {
        console.log("#", N.block.type);
        for (const Y of Object.keys(N.bindings)) {
          const ne = N.bindings[Y];
          console.log(" -", Y, {
            constant: ne.constant,
            references: ne.references,
            violations: ne.constantViolations.length,
            kind: ne.kind
          });
        }
      } while (N = N.parent);
      console.log(A);
    }
    toArray(A, N, Y) {
      if (q(A)) {
        const Ae = this.getBinding(A.name);
        if (Ae != null && Ae.constant && Ae.path.isGenericType("Array"))
          return A;
      }
      if (v(A))
        return A;
      if (q(A, {
        name: "arguments"
      }))
        return g(Pe(Pe(Pe(b("Array"), b("prototype")), b("slice")), b("call")), [A]);
      let ne;
      const de = [A];
      return N === !0 ? ne = "toConsumableArray" : typeof N == "number" ? (de.push(Ce(N)), ne = "slicedToArray") : ne = "toArray", Y && (de.unshift(this.hub.addHelper(ne)), ne = "maybeArrayLike"), g(this.hub.addHelper(ne), de);
    }
    hasLabel(A) {
      return !!this.getLabel(A);
    }
    getLabel(A) {
      return this.labels.get(A);
    }
    registerLabel(A) {
      this.labels.set(A.node.label.name, A);
    }
    registerDeclaration(A) {
      if (A.isLabeledStatement())
        this.registerLabel(A);
      else if (A.isFunctionDeclaration())
        this.registerBinding("hoisted", A.get("id"), A);
      else if (A.isVariableDeclaration()) {
        const N = A.get("declarations"), {
          kind: Y
        } = A.node;
        for (const ne of N)
          this.registerBinding(Y === "using" || Y === "await using" ? "const" : Y, ne);
      } else if (A.isClassDeclaration()) {
        if (A.node.declare)
          return;
        this.registerBinding("let", A);
      } else if (A.isImportDeclaration()) {
        const N = A.node.importKind === "type" || A.node.importKind === "typeof", Y = A.get("specifiers");
        for (const ne of Y) {
          const de = N || ne.isImportSpecifier() && (ne.node.importKind === "type" || ne.node.importKind === "typeof");
          this.registerBinding(de ? "unknown" : "module", ne);
        }
      } else if (A.isExportDeclaration()) {
        const N = A.get("declaration");
        (N.isClassDeclaration() || N.isFunctionDeclaration() || N.isVariableDeclaration()) && this.registerDeclaration(N);
      } else
        this.registerBinding("unknown", A);
    }
    buildUndefinedNode() {
      return ye();
    }
    registerConstantViolation(A) {
      const N = A.getBindingIdentifiers();
      for (const ne of Object.keys(N)) {
        var Y;
        (Y = this.getBinding(ne)) == null || Y.reassign(A);
      }
    }
    registerBinding(A, N, Y = N) {
      if (!A)
        throw new ReferenceError("no `kind`");
      if (N.isVariableDeclaration()) {
        const Ae = N.get("declarations");
        for (const Ne of Ae)
          this.registerBinding(A, Ne);
        return;
      }
      const ne = this.getProgramParent(), de = N.getOuterBindingIdentifiers(!0);
      for (const Ae of Object.keys(de)) {
        ne.references[Ae] = !0;
        for (const Ne of de[Ae]) {
          const ke = this.getOwnBinding(Ae);
          if (ke) {
            if (ke.identifier === Ne)
              continue;
            this.checkBlockScopedCollisions(ke, A, Ae, Ne);
          }
          ke ? this.registerConstantViolation(Y) : this.bindings[Ae] = new s.default({
            identifier: Ne,
            scope: this,
            path: Y,
            kind: A
          });
        }
      }
    }
    addGlobal(A) {
      this.globals[A.name] = A;
    }
    hasUid(A) {
      let N = this;
      do
        if (N.uids[A])
          return !0;
      while (N = N.parent);
      return !1;
    }
    hasGlobal(A) {
      let N = this;
      do
        if (N.globals[A])
          return !0;
      while (N = N.parent);
      return !1;
    }
    hasReference(A) {
      return !!this.getProgramParent().references[A];
    }
    isPure(A, N) {
      if (q(A)) {
        const Ae = this.getBinding(A.name);
        return Ae ? N ? Ae.constant : !0 : !1;
      } else {
        if (re(A) || oe(A) || te(A) || me(A))
          return !0;
        if (U(A)) {
          var Y;
          return A.superClass && !this.isPure(A.superClass, N) || ((Y = A.decorators) == null ? void 0 : Y.length) > 0 ? !1 : this.isPure(A.body, N);
        } else if (X(A)) {
          for (const Ae of A.body)
            if (!this.isPure(Ae, N))
              return !1;
          return !0;
        } else {
          if ($(A))
            return this.isPure(A.left, N) && this.isPure(A.right, N);
          if (v(A) || G(A)) {
            for (const Ae of A.elements)
              if (Ae !== null && !this.isPure(Ae, N))
                return !1;
            return !0;
          } else if (se(A) || we(A)) {
            for (const Ae of A.properties)
              if (!this.isPure(Ae, N))
                return !1;
            return !0;
          } else if (V(A)) {
            var ne;
            return !(A.computed && !this.isPure(A.key, N) || ((ne = A.decorators) == null ? void 0 : ne.length) > 0);
          } else if (be(A)) {
            var de;
            return !(A.computed && !this.isPure(A.key, N) || ((de = A.decorators) == null ? void 0 : de.length) > 0 || (W(A) || A.static) && A.value !== null && !this.isPure(A.value, N));
          } else {
            if (ie(A))
              return this.isPure(A.argument, N);
            if (K(A))
              return ce(A.tag, "String.raw") && !this.hasBinding("String", !0) && this.isPure(A.quasi, N);
            if (z(A)) {
              for (const Ae of A.expressions)
                if (!this.isPure(Ae, N))
                  return !1;
              return !0;
            } else
              return ve(A);
          }
        }
      }
    }
    setData(A, N) {
      return this.data[A] = N;
    }
    getData(A) {
      let N = this;
      do {
        const Y = N.data[A];
        if (Y != null)
          return Y;
      } while (N = N.parent);
    }
    removeData(A) {
      let N = this;
      do
        N.data[A] != null && (N.data[A] = null);
      while (N = N.parent);
    }
    init() {
      this.inited || (this.inited = !0, this.crawl());
    }
    crawl() {
      const A = this.path;
      this.references = /* @__PURE__ */ Object.create(null), this.bindings = /* @__PURE__ */ Object.create(null), this.globals = /* @__PURE__ */ Object.create(null), this.uids = /* @__PURE__ */ Object.create(null), this.data = /* @__PURE__ */ Object.create(null);
      const N = this.getProgramParent();
      if (N.crawling)
        return;
      const Y = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      if (this.crawling = !0, A.type !== "Program" && (0, f.isExplodedVisitor)(he)) {
        for (const de of he.enter)
          de.call(Y, A, Y);
        const ne = he[A.type];
        if (ne)
          for (const de of ne.enter)
            de.call(Y, A, Y);
      }
      A.traverse(he, Y), this.crawling = !1;
      for (const ne of Y.assignments) {
        const de = ne.getBindingIdentifiers();
        for (const Ae of Object.keys(de))
          ne.scope.getBinding(Ae) || N.addGlobal(de[Ae]);
        ne.scope.registerConstantViolation(ne);
      }
      for (const ne of Y.references) {
        const de = ne.scope.getBinding(ne.node.name);
        de ? de.reference(ne) : N.addGlobal(ne.node);
      }
      for (const ne of Y.constantViolations)
        ne.scope.registerConstantViolation(ne);
    }
    push(A) {
      let N = this.path;
      N.isPattern() ? N = this.getPatternParent().path : !N.isBlockStatement() && !N.isProgram() && (N = this.getBlockParent().path), N.isSwitchStatement() && (N = (this.getFunctionParent() || this.getProgramParent()).path);
      const {
        init: Y,
        unique: ne,
        kind: de = "var",
        id: Ae
      } = A;
      if (!Y && !ne && (de === "var" || de === "let") && N.isFunction() && !N.node.name && o.isCallExpression(N.parent, {
        callee: N.node
      }) && N.parent.arguments.length <= N.node.params.length && o.isIdentifier(Ae)) {
        N.pushContainer("params", Ae), N.scope.registerBinding("param", N.get("params")[N.node.params.length - 1]);
        return;
      }
      (N.isLoop() || N.isCatchClause() || N.isFunction()) && (N.ensureBlock(), N = N.get("body"));
      const Ne = A._blockHoist == null ? 2 : A._blockHoist, ke = `declaration:${de}:${Ne}`;
      let Le = !ne && N.getData(ke);
      if (!Le) {
        const ae = ge(de, []);
        ae._blockHoist = Ne, [Le] = N.unshiftContainer("body", [ae]), ne || N.setData(ke, Le);
      }
      const Me = xe(Ae, Y), De = Le.node.declarations.push(Me);
      N.scope.registerBinding(de, Le.get("declarations")[De - 1]);
    }
    getProgramParent() {
      let A = this;
      do
        if (A.path.isProgram())
          return A;
      while (A = A.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let A = this;
      do
        if (A.path.isFunctionParent())
          return A;
      while (A = A.parent);
      return null;
    }
    getBlockParent() {
      let A = this;
      do
        if (A.path.isBlockParent())
          return A;
      while (A = A.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let A = this;
      do
        if (!A.path.isPattern())
          return A.getBlockParent();
      while (A = A.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      const A = /* @__PURE__ */ Object.create(null);
      let N = this;
      do {
        for (const Y of Object.keys(N.bindings))
          Y in A || (A[Y] = N.bindings[Y]);
        N = N.parent;
      } while (N);
      return A;
    }
    getAllBindingsOfKind(...A) {
      const N = /* @__PURE__ */ Object.create(null);
      for (const Y of A) {
        let ne = this;
        do {
          for (const de of Object.keys(ne.bindings)) {
            const Ae = ne.bindings[de];
            Ae.kind === Y && (N[de] = Ae);
          }
          ne = ne.parent;
        } while (ne);
      }
      return N;
    }
    bindingIdentifierEquals(A, N) {
      return this.getBindingIdentifier(A) === N;
    }
    getBinding(A) {
      let N = this, Y;
      do {
        const de = N.getOwnBinding(A);
        if (de) {
          var ne;
          if (!((ne = Y) != null && ne.isPattern() && de.kind !== "param" && de.kind !== "local"))
            return de;
        } else if (!de && A === "arguments" && N.path.isFunction() && !N.path.isArrowFunctionExpression())
          break;
        Y = N.path;
      } while (N = N.parent);
    }
    getOwnBinding(A) {
      return this.bindings[A];
    }
    getBindingIdentifier(A) {
      var N;
      return (N = this.getBinding(A)) == null ? void 0 : N.identifier;
    }
    getOwnBindingIdentifier(A) {
      const N = this.bindings[A];
      return N == null ? void 0 : N.identifier;
    }
    hasOwnBinding(A) {
      return !!this.getOwnBinding(A);
    }
    hasBinding(A, N) {
      var Y, ne, de;
      return A ? !!(this.hasOwnBinding(A) || (typeof N == "boolean" && (N = {
        noGlobals: N
      }), this.parentHasBinding(A, N)) || !((Y = N) != null && Y.noUids) && this.hasUid(A) || !((ne = N) != null && ne.noGlobals) && Ie.globals.includes(A) || !((de = N) != null && de.noGlobals) && Ie.contextVariables.includes(A)) : !1;
    }
    parentHasBinding(A, N) {
      var Y;
      return (Y = this.parent) == null ? void 0 : Y.hasBinding(A, N);
    }
    moveBindingTo(A, N) {
      const Y = this.getBinding(A);
      Y && (Y.scope.removeOwnBinding(A), Y.scope = N, N.bindings[A] = Y);
    }
    removeOwnBinding(A) {
      delete this.bindings[A];
    }
    removeBinding(A) {
      var N;
      (N = this.getBinding(A)) == null || N.scope.removeOwnBinding(A);
      let Y = this;
      do
        Y.uids[A] && (Y.uids[A] = !1);
      while (Y = Y.parent);
    }
  }
  return scope.default = Ie, Ie.globals = Object.keys(i.builtin), Ie.contextVariables = ["arguments", "undefined", "Infinity", "NaN"], scope;
}
var lib$6 = {}, sourceMap = {}, genMapping_umdExports = {}, genMapping_umd = {
  get exports() {
    return genMapping_umdExports;
  },
  set exports(e) {
    genMapping_umdExports = e;
  }
}, setArray_umdExports = {}, setArray_umd = {
  get exports() {
    return setArray_umdExports;
  },
  set exports(e) {
    setArray_umdExports = e;
  }
}, hasRequiredSetArray_umd;
function requireSetArray_umd() {
  return hasRequiredSetArray_umd || (hasRequiredSetArray_umd = 1, function(e, t) {
    (function(s, i) {
      i(t);
    })(commonjsGlobal, function(s) {
      s.get = void 0, s.put = void 0, s.pop = void 0;
      class i {
        constructor() {
          this._indexes = { __proto__: null }, this.array = [];
        }
      }
      s.get = (a, o) => a._indexes[o], s.put = (a, o) => {
        const l = s.get(a, o);
        if (l !== void 0)
          return l;
        const { array: f, _indexes: y } = a;
        return y[o] = f.push(o) - 1;
      }, s.pop = (a) => {
        const { array: o, _indexes: l } = a;
        if (o.length === 0)
          return;
        const f = o.pop();
        l[f] = void 0;
      }, s.SetArray = i, Object.defineProperty(s, "__esModule", { value: !0 });
    });
  }(setArray_umd, setArray_umdExports)), setArray_umdExports;
}
var sourcemapCodec_umdExports$1 = {}, sourcemapCodec_umd$1 = {
  get exports() {
    return sourcemapCodec_umdExports$1;
  },
  set exports(e) {
    sourcemapCodec_umdExports$1 = e;
  }
}, hasRequiredSourcemapCodec_umd$1;
function requireSourcemapCodec_umd$1() {
  return hasRequiredSourcemapCodec_umd$1 || (hasRequiredSourcemapCodec_umd$1 = 1, function(e, t) {
    (function(s, i) {
      i(t);
    })(commonjsGlobal, function(s) {
      const i = ",".charCodeAt(0), a = ";".charCodeAt(0), o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", l = new Uint8Array(64), f = new Uint8Array(128);
      for (let k = 0; k < o.length; k++) {
        const D = o.charCodeAt(k);
        l[k] = D, f[D] = k;
      }
      const y = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
        decode(k) {
          return Buffer.from(k.buffer, k.byteOffset, k.byteLength).toString();
        }
      } : {
        decode(k) {
          let D = "";
          for (let B = 0; B < k.length; B++)
            D += String.fromCharCode(k[B]);
          return D;
        }
      };
      function g(k) {
        const D = new Int32Array(5), B = [];
        let Z = 0;
        do {
          const H = T(k, Z), q = [];
          let _ = !0, j = 0;
          D[0] = 0;
          for (let V = Z; V < H; V++) {
            let ue;
            V = S(k, V, D, 0);
            const ee = D[0];
            ee < j && (_ = !1), j = ee, b(k, V, H) ? (V = S(k, V, D, 1), V = S(k, V, D, 2), V = S(k, V, D, 3), b(k, V, H) ? (V = S(k, V, D, 4), ue = [ee, D[1], D[2], D[3], D[4]]) : ue = [ee, D[1], D[2], D[3]]) : ue = [ee], q.push(ue);
          }
          _ || v(q), B.push(q), Z = H + 1;
        } while (Z <= k.length);
        return B;
      }
      function T(k, D) {
        const B = k.indexOf(";", D);
        return B === -1 ? k.length : B;
      }
      function S(k, D, B, Z) {
        let H = 0, q = 0, _ = 0;
        do {
          const V = k.charCodeAt(D++);
          _ = f[V], H |= (_ & 31) << q, q += 5;
        } while (_ & 32);
        const j = H & 1;
        return H >>>= 1, j && (H = -2147483648 | -H), B[Z] += H, D;
      }
      function b(k, D, B) {
        return D >= B ? !1 : k.charCodeAt(D) !== i;
      }
      function v(k) {
        k.sort($);
      }
      function $(k, D) {
        return k[0] - D[0];
      }
      function U(k) {
        const D = new Int32Array(5), B = 1024 * 16, Z = B - 36, H = new Uint8Array(B), q = H.subarray(0, Z);
        let _ = 0, j = "";
        for (let V = 0; V < k.length; V++) {
          const ue = k[V];
          if (V > 0 && (_ === B && (j += y.decode(H), _ = 0), H[_++] = a), ue.length !== 0) {
            D[0] = 0;
            for (let ee = 0; ee < ue.length; ee++) {
              const se = ue[ee];
              _ > Z && (j += y.decode(q), H.copyWithin(0, Z, _), _ -= Z), ee > 0 && (H[_++] = i), _ = X(H, _, D, se, 0), se.length !== 1 && (_ = X(H, _, D, se, 1), _ = X(H, _, D, se, 2), _ = X(H, _, D, se, 3), se.length !== 4 && (_ = X(H, _, D, se, 4)));
            }
          }
        }
        return j + y.decode(H.subarray(0, _));
      }
      function X(k, D, B, Z, H) {
        const q = Z[H];
        let _ = q - B[H];
        B[H] = q, _ = _ < 0 ? -_ << 1 | 1 : _ << 1;
        do {
          let j = _ & 31;
          _ >>>= 5, _ > 0 && (j |= 32), k[D++] = l[j];
        } while (_ > 0);
        return D;
      }
      s.decode = g, s.encode = U, Object.defineProperty(s, "__esModule", { value: !0 });
    });
  }(sourcemapCodec_umd$1, sourcemapCodec_umdExports$1)), sourcemapCodec_umdExports$1;
}
var traceMapping_umdExports = {}, traceMapping_umd = {
  get exports() {
    return traceMapping_umdExports;
  },
  set exports(e) {
    traceMapping_umdExports = e;
  }
}, sourcemapCodec_umdExports = {}, sourcemapCodec_umd = {
  get exports() {
    return sourcemapCodec_umdExports;
  },
  set exports(e) {
    sourcemapCodec_umdExports = e;
  }
}, hasRequiredSourcemapCodec_umd;
function requireSourcemapCodec_umd() {
  return hasRequiredSourcemapCodec_umd || (hasRequiredSourcemapCodec_umd = 1, function(e, t) {
    (function(s, i) {
      i(t);
    })(commonjsGlobal, function(s) {
      const i = ",".charCodeAt(0), a = ";".charCodeAt(0), o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", l = new Uint8Array(64), f = new Uint8Array(128);
      for (let k = 0; k < o.length; k++) {
        const D = o.charCodeAt(k);
        l[k] = D, f[D] = k;
      }
      const y = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
        decode(k) {
          return Buffer.from(k.buffer, k.byteOffset, k.byteLength).toString();
        }
      } : {
        decode(k) {
          let D = "";
          for (let B = 0; B < k.length; B++)
            D += String.fromCharCode(k[B]);
          return D;
        }
      };
      function g(k) {
        const D = new Int32Array(5), B = [];
        let Z = 0;
        do {
          const H = T(k, Z), q = [];
          let _ = !0, j = 0;
          D[0] = 0;
          for (let V = Z; V < H; V++) {
            let ue;
            V = S(k, V, D, 0);
            const ee = D[0];
            ee < j && (_ = !1), j = ee, b(k, V, H) ? (V = S(k, V, D, 1), V = S(k, V, D, 2), V = S(k, V, D, 3), b(k, V, H) ? (V = S(k, V, D, 4), ue = [ee, D[1], D[2], D[3], D[4]]) : ue = [ee, D[1], D[2], D[3]]) : ue = [ee], q.push(ue);
          }
          _ || v(q), B.push(q), Z = H + 1;
        } while (Z <= k.length);
        return B;
      }
      function T(k, D) {
        const B = k.indexOf(";", D);
        return B === -1 ? k.length : B;
      }
      function S(k, D, B, Z) {
        let H = 0, q = 0, _ = 0;
        do {
          const V = k.charCodeAt(D++);
          _ = f[V], H |= (_ & 31) << q, q += 5;
        } while (_ & 32);
        const j = H & 1;
        return H >>>= 1, j && (H = -2147483648 | -H), B[Z] += H, D;
      }
      function b(k, D, B) {
        return D >= B ? !1 : k.charCodeAt(D) !== i;
      }
      function v(k) {
        k.sort($);
      }
      function $(k, D) {
        return k[0] - D[0];
      }
      function U(k) {
        const D = new Int32Array(5), B = 1024 * 16, Z = B - 36, H = new Uint8Array(B), q = H.subarray(0, Z);
        let _ = 0, j = "";
        for (let V = 0; V < k.length; V++) {
          const ue = k[V];
          if (V > 0 && (_ === B && (j += y.decode(H), _ = 0), H[_++] = a), ue.length !== 0) {
            D[0] = 0;
            for (let ee = 0; ee < ue.length; ee++) {
              const se = ue[ee];
              _ > Z && (j += y.decode(q), H.copyWithin(0, Z, _), _ -= Z), ee > 0 && (H[_++] = i), _ = X(H, _, D, se, 0), se.length !== 1 && (_ = X(H, _, D, se, 1), _ = X(H, _, D, se, 2), _ = X(H, _, D, se, 3), se.length !== 4 && (_ = X(H, _, D, se, 4)));
            }
          }
        }
        return j + y.decode(H.subarray(0, _));
      }
      function X(k, D, B, Z, H) {
        const q = Z[H];
        let _ = q - B[H];
        B[H] = q, _ = _ < 0 ? -_ << 1 | 1 : _ << 1;
        do {
          let j = _ & 31;
          _ >>>= 5, _ > 0 && (j |= 32), k[D++] = l[j];
        } while (_ > 0);
        return D;
      }
      s.decode = g, s.encode = U, Object.defineProperty(s, "__esModule", { value: !0 });
    });
  }(sourcemapCodec_umd, sourcemapCodec_umdExports)), sourcemapCodec_umdExports;
}
var resolveUri_umdExports = {}, resolveUri_umd = {
  get exports() {
    return resolveUri_umdExports;
  },
  set exports(e) {
    resolveUri_umdExports = e;
  }
}, hasRequiredResolveUri_umd;
function requireResolveUri_umd() {
  return hasRequiredResolveUri_umd || (hasRequiredResolveUri_umd = 1, function(e, t) {
    (function(s, i) {
      e.exports = i();
    })(commonjsGlobal, function() {
      const s = /^[\w+.-]+:\/\//, i = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, a = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      var o;
      (function(B) {
        B[B.Empty = 1] = "Empty", B[B.Hash = 2] = "Hash", B[B.Query = 3] = "Query", B[B.RelativePath = 4] = "RelativePath", B[B.AbsolutePath = 5] = "AbsolutePath", B[B.SchemeRelative = 6] = "SchemeRelative", B[B.Absolute = 7] = "Absolute";
      })(o || (o = {}));
      function l(B) {
        return s.test(B);
      }
      function f(B) {
        return B.startsWith("//");
      }
      function y(B) {
        return B.startsWith("/");
      }
      function g(B) {
        return B.startsWith("file:");
      }
      function T(B) {
        return /^[.?#]/.test(B);
      }
      function S(B) {
        const Z = i.exec(B);
        return v(Z[1], Z[2] || "", Z[3], Z[4] || "", Z[5] || "/", Z[6] || "", Z[7] || "");
      }
      function b(B) {
        const Z = a.exec(B), H = Z[2];
        return v("file:", "", Z[1] || "", "", y(H) ? H : "/" + H, Z[3] || "", Z[4] || "");
      }
      function v(B, Z, H, q, _, j, V) {
        return {
          scheme: B,
          user: Z,
          host: H,
          port: q,
          path: _,
          query: j,
          hash: V,
          type: o.Absolute
        };
      }
      function $(B) {
        if (f(B)) {
          const H = S("http:" + B);
          return H.scheme = "", H.type = o.SchemeRelative, H;
        }
        if (y(B)) {
          const H = S("http://foo.com" + B);
          return H.scheme = "", H.host = "", H.type = o.AbsolutePath, H;
        }
        if (g(B))
          return b(B);
        if (l(B))
          return S(B);
        const Z = S("http://foo.com/" + B);
        return Z.scheme = "", Z.host = "", Z.type = B ? B.startsWith("?") ? o.Query : B.startsWith("#") ? o.Hash : o.RelativePath : o.Empty, Z;
      }
      function U(B) {
        if (B.endsWith("/.."))
          return B;
        const Z = B.lastIndexOf("/");
        return B.slice(0, Z + 1);
      }
      function X(B, Z) {
        k(Z, Z.type), B.path === "/" ? B.path = Z.path : B.path = U(Z.path) + B.path;
      }
      function k(B, Z) {
        const H = Z <= o.RelativePath, q = B.path.split("/");
        let _ = 1, j = 0, V = !1;
        for (let ee = 1; ee < q.length; ee++) {
          const se = q[ee];
          if (!se) {
            V = !0;
            continue;
          }
          if (V = !1, se !== ".") {
            if (se === "..") {
              j ? (V = !0, j--, _--) : H && (q[_++] = se);
              continue;
            }
            q[_++] = se, j++;
          }
        }
        let ue = "";
        for (let ee = 1; ee < _; ee++)
          ue += "/" + q[ee];
        (!ue || V && !ue.endsWith("/..")) && (ue += "/"), B.path = ue;
      }
      function D(B, Z) {
        if (!B && !Z)
          return "";
        const H = $(B);
        let q = H.type;
        if (Z && q !== o.Absolute) {
          const j = $(Z), V = j.type;
          switch (q) {
            case o.Empty:
              H.hash = j.hash;
            case o.Hash:
              H.query = j.query;
            case o.Query:
            case o.RelativePath:
              X(H, j);
            case o.AbsolutePath:
              H.user = j.user, H.host = j.host, H.port = j.port;
            case o.SchemeRelative:
              H.scheme = j.scheme;
          }
          V > q && (q = V);
        }
        k(H, q);
        const _ = H.query + H.hash;
        switch (q) {
          case o.Hash:
          case o.Query:
            return _;
          case o.RelativePath: {
            const j = H.path.slice(1);
            return j ? T(Z || B) && !T(j) ? "./" + j + _ : j + _ : _ || ".";
          }
          case o.AbsolutePath:
            return H.path + _;
          default:
            return H.scheme + "//" + H.user + H.host + H.port + H.path + _;
        }
      }
      return D;
    });
  }(resolveUri_umd)), resolveUri_umdExports;
}
(function(e, t) {
  (function(s, i) {
    i(t, requireSourcemapCodec_umd(), requireResolveUri_umd());
  })(commonjsGlobal, function(s, i, a) {
    function o(G) {
      return G && typeof G == "object" && "default" in G ? G : { default: G };
    }
    var l = /* @__PURE__ */ o(a);
    function f(G, W) {
      return W && !W.endsWith("/") && (W += "/"), l.default(G, W);
    }
    function y(G) {
      if (!G)
        return "";
      const W = G.lastIndexOf("/");
      return G.slice(0, W + 1);
    }
    const g = 0, T = 1, S = 2, b = 3, v = 4, $ = 1, U = 2;
    function X(G, W) {
      const te = k(G, 0);
      if (te === G.length)
        return G;
      W || (G = G.slice());
      for (let oe = te; oe < G.length; oe = k(G, oe + 1))
        G[oe] = B(G[oe], W);
      return G;
    }
    function k(G, W) {
      for (let te = W; te < G.length; te++)
        if (!D(G[te]))
          return te;
      return G.length;
    }
    function D(G) {
      for (let W = 1; W < G.length; W++)
        if (G[W][g] < G[W - 1][g])
          return !1;
      return !0;
    }
    function B(G, W) {
      return W || (G = G.slice()), G.sort(Z);
    }
    function Z(G, W) {
      return G[g] - W[g];
    }
    let H = !1;
    function q(G, W, te, oe) {
      for (; te <= oe; ) {
        const me = te + (oe - te >> 1), pe = G[me][g] - W;
        if (pe === 0)
          return H = !0, me;
        pe < 0 ? te = me + 1 : oe = me - 1;
      }
      return H = !1, te - 1;
    }
    function _(G, W, te) {
      for (let oe = te + 1; oe < G.length && G[oe][g] === W; te = oe++)
        ;
      return te;
    }
    function j(G, W, te) {
      for (let oe = te - 1; oe >= 0 && G[oe][g] === W; te = oe--)
        ;
      return te;
    }
    function V() {
      return {
        lastKey: -1,
        lastNeedle: -1,
        lastIndex: -1
      };
    }
    function ue(G, W, te, oe) {
      const { lastKey: me, lastNeedle: pe, lastIndex: ye } = te;
      let le = 0, he = G.length - 1;
      if (oe === me) {
        if (W === pe)
          return H = ye !== -1 && G[ye][g] === W, ye;
        W >= pe ? le = ye === -1 ? 0 : ye : he = ye;
      }
      return te.lastKey = oe, te.lastNeedle = W, te.lastIndex = q(G, W, le, he);
    }
    function ee(G, W) {
      const te = W.map(be);
      for (let oe = 0; oe < G.length; oe++) {
        const me = G[oe];
        for (let pe = 0; pe < me.length; pe++) {
          const ye = me[pe];
          if (ye.length === 1)
            continue;
          const le = ye[T], he = ye[S], Se = ye[b], Ie = te[le], J = Ie[he] || (Ie[he] = []), A = W[le], N = _(J, Se, ue(J, Se, A, he));
          se(J, A.lastIndex = N + 1, [Se, oe, ye[g]]);
        }
      }
      return te;
    }
    function se(G, W, te) {
      for (let oe = G.length; oe > W; oe--)
        G[oe] = G[oe - 1];
      G[W] = te;
    }
    function be() {
      return { __proto__: null };
    }
    const ve = function(G, W) {
      const te = typeof G == "string" ? JSON.parse(G) : G;
      if (!("sections" in te))
        return new Pe(te, W);
      const oe = [], me = [], pe = [], ye = [];
      F(te, W, oe, me, pe, ye, 0, 0, 1 / 0, 1 / 0);
      const le = {
        version: 3,
        file: te.file,
        names: ye,
        sources: me,
        sourcesContent: pe,
        mappings: oe
      };
      return s.presortedDecodedMap(le);
    };
    function F(G, W, te, oe, me, pe, ye, le, he, Se) {
      const { sections: Ie } = G;
      for (let J = 0; J < Ie.length; J++) {
        const { map: A, offset: N } = Ie[J];
        let Y = he, ne = Se;
        if (J + 1 < Ie.length) {
          const de = Ie[J + 1].offset;
          Y = Math.min(he, ye + de.line), Y === he ? ne = Math.min(Se, le + de.column) : Y < he && (ne = le + de.column);
        }
        R(A, W, te, oe, me, pe, ye + N.line, le + N.column, Y, ne);
      }
    }
    function R(G, W, te, oe, me, pe, ye, le, he, Se) {
      if ("sections" in G)
        return F(...arguments);
      const Ie = new Pe(G, W), J = oe.length, A = pe.length, N = s.decodedMappings(Ie), { resolvedSources: Y, sourcesContent: ne } = Ie;
      if (K(oe, Y), K(pe, Ie.names), ne)
        K(me, ne);
      else
        for (let de = 0; de < Y.length; de++)
          me.push(null);
      for (let de = 0; de < N.length; de++) {
        const Ae = ye + de;
        if (Ae > he)
          return;
        const Ne = z(te, Ae), ke = de === 0 ? le : 0, Le = N[de];
        for (let Me = 0; Me < Le.length; Me++) {
          const De = Le[Me], ae = ke + De[g];
          if (Ae === he && ae >= Se)
            return;
          if (De.length === 1) {
            Ne.push([ae]);
            continue;
          }
          const je = J + De[T], Re = De[S], qe = De[b];
          Ne.push(De.length === 4 ? [ae, je, Re, qe] : [ae, je, Re, qe, A + De[v]]);
        }
      }
    }
    function K(G, W) {
      for (let te = 0; te < W.length; te++)
        G.push(W[te]);
    }
    function z(G, W) {
      for (let te = G.length; te <= W; te++)
        G[te] = [];
      return G[W];
    }
    const re = "`line` must be greater than 0 (lines start at line 1)", ie = "`column` must be greater than or equal to 0 (columns start at column 0)", fe = -1, ce = 1;
    s.encodedMappings = void 0, s.decodedMappings = void 0, s.traceSegment = void 0, s.originalPositionFor = void 0, s.generatedPositionFor = void 0, s.allGeneratedPositionsFor = void 0, s.eachMapping = void 0, s.sourceContentFor = void 0, s.presortedDecodedMap = void 0, s.decodedMap = void 0, s.encodedMap = void 0;
    class Pe {
      constructor(W, te) {
        const oe = typeof W == "string";
        if (!oe && W._decodedMemo)
          return W;
        const me = oe ? JSON.parse(W) : W, { version: pe, file: ye, names: le, sourceRoot: he, sources: Se, sourcesContent: Ie } = me;
        this.version = pe, this.file = ye, this.names = le, this.sourceRoot = he, this.sources = Se, this.sourcesContent = Ie;
        const J = f(he || "", y(te));
        this.resolvedSources = Se.map((N) => f(N || "", J));
        const { mappings: A } = me;
        typeof A == "string" ? (this._encoded = A, this._decoded = void 0) : (this._encoded = void 0, this._decoded = X(A, oe)), this._decodedMemo = V(), this._bySources = void 0, this._bySourceMemos = void 0;
      }
    }
    (() => {
      s.encodedMappings = (W) => {
        var te;
        return (te = W._encoded) !== null && te !== void 0 ? te : W._encoded = i.encode(W._decoded);
      }, s.decodedMappings = (W) => W._decoded || (W._decoded = i.decode(W._encoded)), s.traceSegment = (W, te, oe) => {
        const me = s.decodedMappings(W);
        if (te >= me.length)
          return null;
        const pe = me[te], ye = xe(pe, W._decodedMemo, te, oe, ce);
        return ye === -1 ? null : pe[ye];
      }, s.originalPositionFor = (W, { line: te, column: oe, bias: me }) => {
        if (te--, te < 0)
          throw new Error(re);
        if (oe < 0)
          throw new Error(ie);
        const pe = s.decodedMappings(W);
        if (te >= pe.length)
          return _e(null, null, null, null);
        const ye = pe[te], le = xe(ye, W._decodedMemo, te, oe, me || ce);
        if (le === -1)
          return _e(null, null, null, null);
        const he = ye[le];
        if (he.length === 1)
          return _e(null, null, null, null);
        const { names: Se, resolvedSources: Ie } = W;
        return _e(Ie[he[T]], he[S] + 1, he[b], he.length === 5 ? Se[he[v]] : null);
      }, s.allGeneratedPositionsFor = (W, { source: te, line: oe, column: me, bias: pe }) => G(W, te, oe, me, pe || fe, !0), s.generatedPositionFor = (W, { source: te, line: oe, column: me, bias: pe }) => G(W, te, oe, me, pe || ce, !1), s.eachMapping = (W, te) => {
        const oe = s.decodedMappings(W), { names: me, resolvedSources: pe } = W;
        for (let ye = 0; ye < oe.length; ye++) {
          const le = oe[ye];
          for (let he = 0; he < le.length; he++) {
            const Se = le[he], Ie = ye + 1, J = Se[0];
            let A = null, N = null, Y = null, ne = null;
            Se.length !== 1 && (A = pe[Se[1]], N = Se[2] + 1, Y = Se[3]), Se.length === 5 && (ne = me[Se[4]]), te({
              generatedLine: Ie,
              generatedColumn: J,
              source: A,
              originalLine: N,
              originalColumn: Y,
              name: ne
            });
          }
        }
      }, s.sourceContentFor = (W, te) => {
        const { sources: oe, resolvedSources: me, sourcesContent: pe } = W;
        if (pe == null)
          return null;
        let ye = oe.indexOf(te);
        return ye === -1 && (ye = me.indexOf(te)), ye === -1 ? null : pe[ye];
      }, s.presortedDecodedMap = (W, te) => {
        const oe = new Pe(Ce(W, []), te);
        return oe._decoded = W.mappings, oe;
      }, s.decodedMap = (W) => Ce(W, s.decodedMappings(W)), s.encodedMap = (W) => Ce(W, s.encodedMappings(W));
      function G(W, te, oe, me, pe, ye) {
        if (oe--, oe < 0)
          throw new Error(re);
        if (me < 0)
          throw new Error(ie);
        const { sources: le, resolvedSources: he } = W;
        let Se = le.indexOf(te);
        if (Se === -1 && (Se = he.indexOf(te)), Se === -1)
          return ye ? [] : ge(null, null);
        const J = (W._bySources || (W._bySources = ee(s.decodedMappings(W), W._bySourceMemos = le.map(V))))[Se][oe];
        if (J == null)
          return ye ? [] : ge(null, null);
        const A = W._bySourceMemos[Se];
        if (ye)
          return we(J, A, oe, me, pe);
        const N = xe(J, A, oe, me, pe);
        if (N === -1)
          return ge(null, null);
        const Y = J[N];
        return ge(Y[$] + 1, Y[U]);
      }
    })();
    function Ce(G, W) {
      return {
        version: G.version,
        file: G.file,
        names: G.names,
        sourceRoot: G.sourceRoot,
        sources: G.sources,
        sourcesContent: G.sourcesContent,
        mappings: W
      };
    }
    function _e(G, W, te, oe) {
      return { source: G, line: W, column: te, name: oe };
    }
    function ge(G, W) {
      return { line: G, column: W };
    }
    function xe(G, W, te, oe, me) {
      let pe = ue(G, oe, W, te);
      return H ? pe = (me === fe ? _ : j)(G, oe, pe) : me === fe && pe++, pe === -1 || pe === G.length ? -1 : pe;
    }
    function we(G, W, te, oe, me) {
      let pe = xe(G, W, te, oe, ce);
      if (!H && me === fe && pe++, pe === -1 || pe === G.length)
        return [];
      const ye = H ? oe : G[pe][g];
      H || (pe = j(G, ye, pe));
      const le = _(G, ye, pe), he = [];
      for (; pe <= le; pe++) {
        const Se = G[pe];
        he.push(ge(Se[$] + 1, Se[U]));
      }
      return he;
    }
    s.AnyMap = ve, s.GREATEST_LOWER_BOUND = ce, s.LEAST_UPPER_BOUND = fe, s.TraceMap = Pe, Object.defineProperty(s, "__esModule", { value: !0 });
  });
})(traceMapping_umd, traceMapping_umdExports);
(function(e, t) {
  (function(s, i) {
    i(t, requireSetArray_umd(), requireSourcemapCodec_umd$1(), traceMapping_umdExports);
  })(commonjsGlobal, function(s, i, a, o) {
    s.addSegment = void 0, s.addMapping = void 0, s.maybeAddSegment = void 0, s.maybeAddMapping = void 0, s.setSourceContent = void 0, s.toDecodedMap = void 0, s.toEncodedMap = void 0, s.fromMap = void 0, s.allMappings = void 0;
    let b;
    class v {
      constructor({ file: _, sourceRoot: j } = {}) {
        this._names = new i.SetArray(), this._sources = new i.SetArray(), this._sourcesContent = [], this._mappings = [], this.file = _, this.sourceRoot = j;
      }
    }
    s.addSegment = (q, _, j, V, ue, ee, se, be) => b(!1, q, _, j, V, ue, ee, se, be), s.maybeAddSegment = (q, _, j, V, ue, ee, se, be) => b(!0, q, _, j, V, ue, ee, se, be), s.addMapping = (q, _) => H(!1, q, _), s.maybeAddMapping = (q, _) => H(!0, q, _), s.setSourceContent = (q, _, j) => {
      const { _sources: V, _sourcesContent: ue } = q;
      ue[i.put(V, _)] = j;
    }, s.toDecodedMap = (q) => {
      const { file: _, sourceRoot: j, _mappings: V, _sources: ue, _sourcesContent: ee, _names: se } = q;
      return k(V), {
        version: 3,
        file: _ || void 0,
        names: se.array,
        sourceRoot: j || void 0,
        sources: ue.array,
        sourcesContent: ee,
        mappings: V
      };
    }, s.toEncodedMap = (q) => {
      const _ = s.toDecodedMap(q);
      return Object.assign(Object.assign({}, _), { mappings: a.encode(_.mappings) });
    }, s.allMappings = (q) => {
      const _ = [], { _mappings: j, _sources: V, _names: ue } = q;
      for (let ee = 0; ee < j.length; ee++) {
        const se = j[ee];
        for (let be = 0; be < se.length; be++) {
          const ve = se[be], F = { line: ee + 1, column: ve[0] };
          let R, K, z;
          ve.length !== 1 && (R = V.array[ve[1]], K = { line: ve[2] + 1, column: ve[3] }, ve.length === 5 && (z = ue.array[ve[4]])), _.push({ generated: F, source: R, original: K, name: z });
        }
      }
      return _;
    }, s.fromMap = (q) => {
      const _ = new o.TraceMap(q), j = new v({ file: _.file, sourceRoot: _.sourceRoot });
      return D(j._names, _.names), D(j._sources, _.sources), j._sourcesContent = _.sourcesContent || _.sources.map(() => null), j._mappings = o.decodedMappings(_), j;
    }, b = (q, _, j, V, ue, ee, se, be, ve) => {
      const { _mappings: F, _sources: R, _sourcesContent: K, _names: z } = _, re = $(F, j), ie = U(re, V);
      if (!ue)
        return q && B(re, ie) ? void 0 : X(re, ie, [V]);
      const fe = i.put(R, ue), ce = be ? i.put(z, be) : -1;
      if (fe === K.length && (K[fe] = ve ?? null), !(q && Z(re, ie, fe, ee, se, ce)))
        return X(re, ie, be ? [V, fe, ee, se, ce] : [V, fe, ee, se]);
    };
    function $(q, _) {
      for (let j = q.length; j <= _; j++)
        q[j] = [];
      return q[_];
    }
    function U(q, _) {
      let j = q.length;
      for (let V = j - 1; V >= 0; j = V--) {
        const ue = q[V];
        if (_ >= ue[0])
          break;
      }
      return j;
    }
    function X(q, _, j) {
      for (let V = q.length; V > _; V--)
        q[V] = q[V - 1];
      q[_] = j;
    }
    function k(q) {
      const { length: _ } = q;
      let j = _;
      for (let V = j - 1; V >= 0 && !(q[V].length > 0); j = V, V--)
        ;
      j < _ && (q.length = j);
    }
    function D(q, _) {
      for (let j = 0; j < _.length; j++)
        i.put(q, _[j]);
    }
    function B(q, _) {
      return _ === 0 ? !0 : q[_ - 1].length === 1;
    }
    function Z(q, _, j, V, ue, ee) {
      if (_ === 0)
        return !1;
      const se = q[_ - 1];
      return se.length === 1 ? !1 : j === se[1] && V === se[2] && ue === se[3] && ee === (se.length === 5 ? se[4] : -1);
    }
    function H(q, _, j) {
      const { generated: V, source: ue, original: ee, name: se, content: be } = j;
      if (!ue)
        return b(q, _, V.line - 1, V.column, null, null, null, null, null);
      const ve = ue;
      return b(q, _, V.line - 1, V.column, ve, ee.line - 1, ee.column, se, be);
    }
    s.GenMapping = v, Object.defineProperty(s, "__esModule", { value: !0 });
  });
})(genMapping_umd, genMapping_umdExports);
Object.defineProperty(sourceMap, "__esModule", {
  value: !0
});
sourceMap.default = void 0;
var _genMapping = genMapping_umdExports, _traceMapping = traceMapping_umdExports;
class SourceMap {
  constructor(t, s) {
    var i;
    this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0, this._inputMap = void 0;
    const a = this._map = new _genMapping.GenMapping({
      sourceRoot: t.sourceRoot
    });
    if (this._sourceFileName = (i = t.sourceFileName) == null ? void 0 : i.replace(/\\/g, "/"), this._rawMappings = void 0, t.inputSourceMap) {
      this._inputMap = new _traceMapping.TraceMap(t.inputSourceMap);
      const l = this._inputMap.resolvedSources;
      if (l.length)
        for (let f = 0; f < l.length; f++) {
          var o;
          (0, _genMapping.setSourceContent)(a, l[f], (o = this._inputMap.sourcesContent) == null ? void 0 : o[f]);
        }
    }
    if (typeof s == "string" && !t.inputSourceMap)
      (0, _genMapping.setSourceContent)(a, this._sourceFileName, s);
    else if (typeof s == "object")
      for (const l of Object.keys(s))
        (0, _genMapping.setSourceContent)(a, l.replace(/\\/g, "/"), s[l]);
  }
  get() {
    return (0, _genMapping.toEncodedMap)(this._map);
  }
  getDecoded() {
    return (0, _genMapping.toDecodedMap)(this._map);
  }
  getRawMappings() {
    return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
  }
  mark(t, s, i, a, o, l) {
    var f;
    this._rawMappings = void 0;
    let y;
    if (s != null)
      if (this._inputMap) {
        if (y = (0, _traceMapping.originalPositionFor)(this._inputMap, {
          line: s,
          column: i
        }), !y.name && o) {
          const g = (0, _traceMapping.originalPositionFor)(this._inputMap, o);
          g.name && (a = g.name);
        }
      } else
        y = {
          source: (l == null ? void 0 : l.replace(/\\/g, "/")) || this._sourceFileName,
          line: s,
          column: i
        };
    (0, _genMapping.maybeAddMapping)(this._map, {
      name: a,
      generated: t,
      source: (f = y) == null ? void 0 : f.source,
      original: y
    });
  }
}
sourceMap.default = SourceMap;
var printer = {}, buffer = {};
Object.defineProperty(buffer, "__esModule", {
  value: !0
});
buffer.default = void 0;
let Buffer$1 = class {
  constructor(t, s) {
    this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
      line: 1,
      column: 0
    }, this._sourcePosition = {
      identifierName: void 0,
      identifierNamePos: void 0,
      line: void 0,
      column: void 0,
      filename: void 0
    }, this._map = t, this._indentChar = s;
    for (let i = 0; i < 64; i++)
      this._fastIndentations.push(s.repeat(i));
    this._allocQueue();
  }
  _allocQueue() {
    const t = this._queue;
    for (let s = 0; s < 16; s++)
      t.push({
        char: 0,
        repeat: 1,
        line: void 0,
        column: void 0,
        identifierName: void 0,
        identifierNamePos: void 0,
        filename: ""
      });
  }
  _pushQueue(t, s, i, a, o) {
    const l = this._queueCursor;
    l === this._queue.length && this._allocQueue();
    const f = this._queue[l];
    f.char = t, f.repeat = s, f.line = i, f.column = a, f.filename = o, this._queueCursor++;
  }
  _popQueue() {
    if (this._queueCursor === 0)
      throw new Error("Cannot pop from empty queue");
    return this._queue[--this._queueCursor];
  }
  get() {
    this._flush();
    const t = this._map, s = {
      code: (this._buf + this._str).trimRight(),
      decodedMap: t == null ? void 0 : t.getDecoded(),
      get __mergedMap() {
        return this.map;
      },
      get map() {
        const i = t ? t.get() : null;
        return s.map = i, i;
      },
      set map(i) {
        Object.defineProperty(s, "map", {
          value: i,
          writable: !0
        });
      },
      get rawMappings() {
        const i = t == null ? void 0 : t.getRawMappings();
        return s.rawMappings = i, i;
      },
      set rawMappings(i) {
        Object.defineProperty(s, "rawMappings", {
          value: i,
          writable: !0
        });
      }
    };
    return s;
  }
  append(t, s) {
    this._flush(), this._append(t, this._sourcePosition, s);
  }
  appendChar(t) {
    this._flush(), this._appendChar(t, 1, this._sourcePosition);
  }
  queue(t) {
    if (t === 10)
      for (; this._queueCursor !== 0; ) {
        const i = this._queue[this._queueCursor - 1].char;
        if (i !== 32 && i !== 9)
          break;
        this._queueCursor--;
      }
    const s = this._sourcePosition;
    this._pushQueue(t, 1, s.line, s.column, s.filename);
  }
  queueIndentation(t) {
    t !== 0 && this._pushQueue(-1, t, void 0, void 0, void 0);
  }
  _flush() {
    const t = this._queueCursor, s = this._queue;
    for (let i = 0; i < t; i++) {
      const a = s[i];
      this._appendChar(a.char, a.repeat, a);
    }
    this._queueCursor = 0;
  }
  _appendChar(t, s, i) {
    if (this._last = t, t === -1) {
      const a = this._fastIndentations[s];
      a !== void 0 ? this._str += a : this._str += s > 1 ? this._indentChar.repeat(s) : this._indentChar;
    } else
      this._str += s > 1 ? String.fromCharCode(t).repeat(s) : String.fromCharCode(t);
    t !== 10 ? (this._mark(i.line, i.column, i.identifierName, i.identifierNamePos, i.filename), this._position.column += s) : (this._position.line++, this._position.column = 0), this._canMarkIdName && (i.identifierName = void 0, i.identifierNamePos = void 0);
  }
  _append(t, s, i) {
    const a = t.length, o = this._position;
    if (this._last = t.charCodeAt(a - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = t, this._appendCount = 0) : this._str += t, !i && !this._map) {
      o.column += a;
      return;
    }
    const {
      column: l,
      identifierName: f,
      identifierNamePos: y,
      filename: g
    } = s;
    let T = s.line;
    (f != null || y != null) && this._canMarkIdName && (s.identifierName = void 0, s.identifierNamePos = void 0);
    let S = t.indexOf(`
`), b = 0;
    for (S !== 0 && this._mark(T, l, f, y, g); S !== -1; )
      o.line++, o.column = 0, b = S + 1, b < a && T !== void 0 && this._mark(++T, 0, null, null, g), S = t.indexOf(`
`, b);
    o.column += a - b;
  }
  _mark(t, s, i, a, o) {
    var l;
    (l = this._map) == null || l.mark(this._position, t, s, i, a, o);
  }
  removeTrailingNewline() {
    const t = this._queueCursor;
    t !== 0 && this._queue[t - 1].char === 10 && this._queueCursor--;
  }
  removeLastSemicolon() {
    const t = this._queueCursor;
    t !== 0 && this._queue[t - 1].char === 59 && this._queueCursor--;
  }
  getLastChar() {
    const t = this._queueCursor;
    return t !== 0 ? this._queue[t - 1].char : this._last;
  }
  getNewlineCount() {
    const t = this._queueCursor;
    let s = 0;
    if (t === 0)
      return this._last === 10 ? 1 : 0;
    for (let i = t - 1; i >= 0 && this._queue[i].char === 10; i--)
      s++;
    return s === t && this._last === 10 ? s + 1 : s;
  }
  endsWithCharAndNewline() {
    const t = this._queue, s = this._queueCursor;
    if (s !== 0)
      return t[s - 1].char !== 10 ? void 0 : s > 1 ? t[s - 2].char : this._last;
  }
  hasContent() {
    return this._queueCursor !== 0 || !!this._last;
  }
  exactSource(t, s) {
    if (!this._map) {
      s();
      return;
    }
    this.source("start", t);
    const i = t.identifierName, a = this._sourcePosition;
    i && (this._canMarkIdName = !1, a.identifierName = i), s(), i && (this._canMarkIdName = !0, a.identifierName = void 0, a.identifierNamePos = void 0), this.source("end", t);
  }
  source(t, s) {
    this._map && this._normalizePosition(t, s, 0);
  }
  sourceWithOffset(t, s, i) {
    this._map && this._normalizePosition(t, s, i);
  }
  withSource(t, s, i) {
    this._map && this.source(t, s), i();
  }
  _normalizePosition(t, s, i) {
    const a = s[t], o = this._sourcePosition;
    a && (o.line = a.line, o.column = Math.max(a.column + i, 0), o.filename = s.filename);
  }
  getCurrentColumn() {
    const t = this._queue, s = this._queueCursor;
    let i = -1, a = 0;
    for (let o = 0; o < s; o++) {
      const l = t[o];
      l.char === 10 && (i = a), a += l.repeat;
    }
    return i === -1 ? this._position.column + a : a - 1 - i;
  }
  getCurrentLine() {
    let t = 0;
    const s = this._queue;
    for (let i = 0; i < this._queueCursor; i++)
      s[i].char === 10 && t++;
    return this._position.line + t;
  }
};
buffer.default = Buffer$1;
var node = {}, whitespace$1 = {};
Object.defineProperty(whitespace$1, "__esModule", {
  value: !0
});
whitespace$1.nodes = void 0;
var _t$m = requireLib$1();
const {
  FLIPPED_ALIAS_KEYS: FLIPPED_ALIAS_KEYS$1,
  isArrayExpression,
  isAssignmentExpression: isAssignmentExpression$1,
  isBinary,
  isBlockStatement: isBlockStatement$1,
  isCallExpression: isCallExpression$4,
  isFunction: isFunction$4,
  isIdentifier: isIdentifier$7,
  isLiteral: isLiteral$3,
  isMemberExpression: isMemberExpression$3,
  isObjectExpression,
  isOptionalCallExpression,
  isOptionalMemberExpression: isOptionalMemberExpression$1,
  isStringLiteral: isStringLiteral$3
} = _t$m;
function crawlInternal(e, t) {
  return e && (isMemberExpression$3(e) || isOptionalMemberExpression$1(e) ? (crawlInternal(e.object, t), e.computed && crawlInternal(e.property, t)) : isBinary(e) || isAssignmentExpression$1(e) ? (crawlInternal(e.left, t), crawlInternal(e.right, t)) : isCallExpression$4(e) || isOptionalCallExpression(e) ? (t.hasCall = !0, crawlInternal(e.callee, t)) : isFunction$4(e) ? t.hasFunction = !0 : isIdentifier$7(e) && (t.hasHelper = t.hasHelper || e.callee && isHelper(e.callee))), t;
}
function crawl(e) {
  return crawlInternal(e, {
    hasCall: !1,
    hasFunction: !1,
    hasHelper: !1
  });
}
function isHelper(e) {
  return e ? isMemberExpression$3(e) ? isHelper(e.object) || isHelper(e.property) : isIdentifier$7(e) ? e.name === "require" || e.name.charCodeAt(0) === 95 : isCallExpression$4(e) ? isHelper(e.callee) : isBinary(e) || isAssignmentExpression$1(e) ? isIdentifier$7(e.left) && isHelper(e.left) || isHelper(e.right) : !1 : !1;
}
function isType$1(e) {
  return isLiteral$3(e) || isObjectExpression(e) || isArrayExpression(e) || isIdentifier$7(e) || isMemberExpression$3(e);
}
const nodes = whitespace$1.nodes = {
  AssignmentExpression(e) {
    const t = crawl(e.right);
    if (t.hasCall && t.hasHelper || t.hasFunction)
      return t.hasFunction ? 3 : 2;
  },
  SwitchCase(e, t) {
    return (e.consequent.length || t.cases[0] === e ? 1 : 0) | (!e.consequent.length && t.cases[t.cases.length - 1] === e ? 2 : 0);
  },
  LogicalExpression(e) {
    if (isFunction$4(e.left) || isFunction$4(e.right))
      return 2;
  },
  Literal(e) {
    if (isStringLiteral$3(e) && e.value === "use strict")
      return 2;
  },
  CallExpression(e) {
    if (isFunction$4(e.callee) || isHelper(e))
      return 3;
  },
  OptionalCallExpression(e) {
    if (isFunction$4(e.callee))
      return 3;
  },
  VariableDeclaration(e) {
    for (let t = 0; t < e.declarations.length; t++) {
      const s = e.declarations[t];
      let i = isHelper(s.id) && !isType$1(s.init);
      if (!i && s.init) {
        const a = crawl(s.init);
        i = isHelper(s.init) && a.hasCall || a.hasFunction;
      }
      if (i)
        return 3;
    }
  },
  IfStatement(e) {
    if (isBlockStatement$1(e.consequent))
      return 3;
  }
};
nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(e, t) {
  if (t.properties[0] === e)
    return 1;
};
nodes.ObjectTypeCallProperty = function(e, t) {
  var s;
  if (t.callProperties[0] === e && !((s = t.properties) != null && s.length))
    return 1;
};
nodes.ObjectTypeIndexer = function(e, t) {
  var s, i;
  if (t.indexers[0] === e && !((s = t.properties) != null && s.length) && !((i = t.callProperties) != null && i.length))
    return 1;
};
nodes.ObjectTypeInternalSlot = function(e, t) {
  var s, i, a;
  if (t.internalSlots[0] === e && !((s = t.properties) != null && s.length) && !((i = t.callProperties) != null && i.length) && !((a = t.indexers) != null && a.length))
    return 1;
};
[["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([e, t]) {
  [e].concat(FLIPPED_ALIAS_KEYS$1[e] || []).forEach(function(s) {
    const i = t ? 3 : 0;
    nodes[s] = () => i;
  });
});
var parentheses = {};
Object.defineProperty(parentheses, "__esModule", {
  value: !0
});
parentheses.ArrowFunctionExpression = ArrowFunctionExpression$1;
parentheses.AssignmentExpression = AssignmentExpression$1;
parentheses.Binary = Binary;
parentheses.BinaryExpression = BinaryExpression;
parentheses.ClassExpression = ClassExpression;
parentheses.ConditionalExpression = ConditionalExpression$1;
parentheses.DoExpression = DoExpression$1;
parentheses.FunctionExpression = FunctionExpression$1;
parentheses.FunctionTypeAnnotation = FunctionTypeAnnotation;
parentheses.Identifier = Identifier$1;
parentheses.LogicalExpression = LogicalExpression;
parentheses.NullableTypeAnnotation = NullableTypeAnnotation;
parentheses.ObjectExpression = ObjectExpression$1;
parentheses.OptionalIndexedAccessType = OptionalIndexedAccessType;
parentheses.OptionalCallExpression = parentheses.OptionalMemberExpression = OptionalMemberExpression$1;
parentheses.SequenceExpression = SequenceExpression$1;
parentheses.TSTypeAssertion = parentheses.TSSatisfiesExpression = parentheses.TSAsExpression = TSAsExpression;
parentheses.TSInferType = TSInferType$1;
parentheses.TSInstantiationExpression = TSInstantiationExpression$1;
parentheses.TSIntersectionType = parentheses.TSUnionType = TSUnionType$1;
parentheses.UnaryLike = UnaryLike;
parentheses.IntersectionTypeAnnotation = parentheses.UnionTypeAnnotation = UnionTypeAnnotation;
parentheses.UpdateExpression = UpdateExpression$1;
parentheses.AwaitExpression = parentheses.YieldExpression = YieldExpression$1;
var _t$l = requireLib$1();
const {
  isArrayTypeAnnotation: isArrayTypeAnnotation$1,
  isArrowFunctionExpression,
  isBinaryExpression,
  isCallExpression: isCallExpression$3,
  isExportDeclaration,
  isForOfStatement,
  isIndexedAccessType,
  isMemberExpression: isMemberExpression$2,
  isObjectPattern,
  isOptionalMemberExpression,
  isYieldExpression
} = _t$l, PRECEDENCE = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
function isTSTypeExpression(e) {
  return e === "TSAsExpression" || e === "TSSatisfiesExpression" || e === "TSTypeAssertion";
}
const isClassExtendsClause = (e, t) => {
  const s = t.type;
  return (s === "ClassDeclaration" || s === "ClassExpression") && t.superClass === e;
}, hasPostfixPart = (e, t) => {
  const s = t.type;
  return (s === "MemberExpression" || s === "OptionalMemberExpression") && t.object === e || (s === "CallExpression" || s === "OptionalCallExpression" || s === "NewExpression") && t.callee === e || s === "TaggedTemplateExpression" && t.tag === e || s === "TSNonNullExpression";
};
function NullableTypeAnnotation(e, t) {
  return isArrayTypeAnnotation$1(t);
}
function FunctionTypeAnnotation(e, t, s) {
  if (s.length < 3)
    return;
  const i = t.type;
  return i === "UnionTypeAnnotation" || i === "IntersectionTypeAnnotation" || i === "ArrayTypeAnnotation" || i === "TypeAnnotation" && isArrowFunctionExpression(s[s.length - 3]);
}
function UpdateExpression$1(e, t) {
  return hasPostfixPart(e, t) || isClassExtendsClause(e, t);
}
function ObjectExpression$1(e, t, s) {
  return isFirstInContext(s, 3);
}
function DoExpression$1(e, t, s) {
  return !e.async && isFirstInContext(s, 1);
}
function Binary(e, t) {
  const s = t.type;
  if (e.operator === "**" && s === "BinaryExpression" && t.operator === "**")
    return t.left === e;
  if (isClassExtendsClause(e, t) || hasPostfixPart(e, t) || s === "UnaryExpression" || s === "SpreadElement" || s === "AwaitExpression")
    return !0;
  if (s === "BinaryExpression" || s === "LogicalExpression") {
    const i = PRECEDENCE.get(t.operator), a = PRECEDENCE.get(e.operator);
    if (i === a && t.right === e && s !== "LogicalExpression" || i > a)
      return !0;
  }
}
function UnionTypeAnnotation(e, t) {
  const s = t.type;
  return s === "ArrayTypeAnnotation" || s === "NullableTypeAnnotation" || s === "IntersectionTypeAnnotation" || s === "UnionTypeAnnotation";
}
function OptionalIndexedAccessType(e, t) {
  return isIndexedAccessType(t) && t.objectType === e;
}
function TSAsExpression() {
  return !0;
}
function TSUnionType$1(e, t) {
  const s = t.type;
  return s === "TSArrayType" || s === "TSOptionalType" || s === "TSIntersectionType" || s === "TSUnionType" || s === "TSRestType";
}
function TSInferType$1(e, t) {
  const s = t.type;
  return s === "TSArrayType" || s === "TSOptionalType";
}
function TSInstantiationExpression$1(e, t) {
  const s = t.type;
  return (s === "CallExpression" || s === "OptionalCallExpression" || s === "NewExpression" || s === "TSInstantiationExpression") && !!t.typeParameters;
}
function BinaryExpression(e, t) {
  if (e.operator === "in") {
    const s = t.type;
    return s === "VariableDeclarator" || s === "ForStatement" || s === "ForInStatement" || s === "ForOfStatement";
  }
  return !1;
}
function SequenceExpression$1(e, t) {
  const s = t.type;
  return !(s === "ForStatement" || s === "ThrowStatement" || s === "ReturnStatement" || s === "IfStatement" && t.test === e || s === "WhileStatement" && t.test === e || s === "ForInStatement" && t.right === e || s === "SwitchStatement" && t.discriminant === e || s === "ExpressionStatement" && t.expression === e);
}
function YieldExpression$1(e, t) {
  const s = t.type;
  return s === "BinaryExpression" || s === "LogicalExpression" || s === "UnaryExpression" || s === "SpreadElement" || hasPostfixPart(e, t) || s === "AwaitExpression" && isYieldExpression(e) || s === "ConditionalExpression" && e === t.test || isClassExtendsClause(e, t);
}
function ClassExpression(e, t, s) {
  return isFirstInContext(s, 5);
}
function UnaryLike(e, t) {
  return hasPostfixPart(e, t) || isBinaryExpression(t) && t.operator === "**" && t.left === e || isClassExtendsClause(e, t);
}
function FunctionExpression$1(e, t, s) {
  return isFirstInContext(s, 5);
}
function ArrowFunctionExpression$1(e, t) {
  return isExportDeclaration(t) || ConditionalExpression$1(e, t);
}
function ConditionalExpression$1(e, t) {
  const s = t.type;
  return s === "UnaryExpression" || s === "SpreadElement" || s === "BinaryExpression" || s === "LogicalExpression" || s === "ConditionalExpression" && t.test === e || s === "AwaitExpression" || isTSTypeExpression(s) ? !0 : UnaryLike(e, t);
}
function OptionalMemberExpression$1(e, t) {
  return isCallExpression$3(t) && t.callee === e || isMemberExpression$2(t) && t.object === e;
}
function AssignmentExpression$1(e, t) {
  return isObjectPattern(e.left) ? !0 : ConditionalExpression$1(e, t);
}
function LogicalExpression(e, t) {
  const s = t.type;
  if (isTSTypeExpression(s))
    return !0;
  if (s !== "LogicalExpression")
    return !1;
  switch (e.operator) {
    case "||":
      return t.operator === "??" || t.operator === "&&";
    case "&&":
      return t.operator === "??";
    case "??":
      return t.operator !== "??";
  }
}
function Identifier$1(e, t, s) {
  var i;
  const a = t.type;
  if ((i = e.extra) != null && i.parenthesized && a === "AssignmentExpression" && t.left === e) {
    const o = t.right.type;
    if ((o === "FunctionExpression" || o === "ClassExpression") && t.right.id == null)
      return !0;
  }
  if (e.name === "let") {
    const o = isMemberExpression$2(t, {
      object: e,
      computed: !0
    }) || isOptionalMemberExpression(t, {
      object: e,
      computed: !0,
      optional: !1
    });
    return isFirstInContext(s, o ? 57 : 32);
  }
  return e.name === "async" && isForOfStatement(t) && e === t.left;
}
function isFirstInContext(e, t) {
  const s = t & 1, i = t & 2, a = t & 4, o = t & 8, l = t & 16, f = t & 32;
  let y = e.length - 1;
  if (y <= 0)
    return;
  let g = e[y];
  y--;
  let T = e[y];
  for (; y >= 0; ) {
    const S = T.type;
    if (s && S === "ExpressionStatement" && T.expression === g || a && S === "ExportDefaultDeclaration" && g === T.declaration || i && S === "ArrowFunctionExpression" && T.body === g || o && S === "ForStatement" && T.init === g || l && S === "ForInStatement" && T.left === g || f && S === "ForOfStatement" && T.left === g)
      return !0;
    if (y > 0 && (hasPostfixPart(g, T) && S !== "NewExpression" || S === "SequenceExpression" && T.expressions[0] === g || S === "UpdateExpression" && !T.prefix || S === "ConditionalExpression" && T.test === g || (S === "BinaryExpression" || S === "LogicalExpression") && T.left === g || S === "AssignmentExpression" && T.left === g))
      g = T, y--, T = e[y];
    else
      return !1;
  }
  return !1;
}
Object.defineProperty(node, "__esModule", {
  value: !0
});
node.needsParens = needsParens$1;
node.needsWhitespace = needsWhitespace;
node.needsWhitespaceAfter = needsWhitespaceAfter;
node.needsWhitespaceBefore = needsWhitespaceBefore;
var whitespace = whitespace$1, parens = parentheses, _t$k = requireLib$1();
const {
  FLIPPED_ALIAS_KEYS,
  isCallExpression: isCallExpression$2,
  isExpressionStatement: isExpressionStatement$1,
  isMemberExpression: isMemberExpression$1,
  isNewExpression: isNewExpression$2
} = _t$k;
function expandAliases(e) {
  const t = /* @__PURE__ */ new Map();
  function s(i, a) {
    const o = t.get(i);
    t.set(i, o ? function(l, f, y) {
      var g;
      return (g = o(l, f, y)) != null ? g : a(l, f, y);
    } : a);
  }
  for (const i of Object.keys(e)) {
    const a = FLIPPED_ALIAS_KEYS[i];
    if (a)
      for (const o of a)
        s(o, e[i]);
    else
      s(i, e[i]);
  }
  return t;
}
const expandedParens = expandAliases(parens), expandedWhitespaceNodes = expandAliases(whitespace.nodes);
function isOrHasCallExpression(e) {
  return isCallExpression$2(e) ? !0 : isMemberExpression$1(e) && isOrHasCallExpression(e.object);
}
function needsWhitespace(e, t, s) {
  var i;
  if (!e)
    return !1;
  isExpressionStatement$1(e) && (e = e.expression);
  const a = (i = expandedWhitespaceNodes.get(e.type)) == null ? void 0 : i(e, t);
  return typeof a == "number" ? (a & s) !== 0 : !1;
}
function needsWhitespaceBefore(e, t) {
  return needsWhitespace(e, t, 1);
}
function needsWhitespaceAfter(e, t) {
  return needsWhitespace(e, t, 2);
}
function needsParens$1(e, t, s) {
  var i;
  return t ? isNewExpression$2(t) && t.callee === e && isOrHasCallExpression(e) ? !0 : (i = expandedParens.get(e.type)) == null ? void 0 : i(e, t, s) : !1;
}
var generators = {}, templateLiterals = {};
Object.defineProperty(templateLiterals, "__esModule", {
  value: !0
});
templateLiterals.TaggedTemplateExpression = TaggedTemplateExpression;
templateLiterals.TemplateElement = TemplateElement;
templateLiterals.TemplateLiteral = TemplateLiteral;
function TaggedTemplateExpression(e) {
  this.print(e.tag, e), this.print(e.typeParameters, e), this.print(e.quasi, e);
}
function TemplateElement(e, t) {
  const s = t.quasis[0] === e, i = t.quasis[t.quasis.length - 1] === e, a = (s ? "`" : "}") + e.value.raw + (i ? "`" : "${");
  this.token(a, !0);
}
function TemplateLiteral(e) {
  const t = e.quasis;
  for (let s = 0; s < t.length; s++)
    this.print(t[s], e), s + 1 < t.length && this.print(e.expressions[s], e);
}
var expressions = {};
Object.defineProperty(expressions, "__esModule", {
  value: !0
});
expressions.LogicalExpression = expressions.BinaryExpression = expressions.AssignmentExpression = AssignmentExpression;
expressions.AssignmentPattern = AssignmentPattern;
expressions.AwaitExpression = AwaitExpression;
expressions.BindExpression = BindExpression;
expressions.CallExpression = CallExpression;
expressions.ConditionalExpression = ConditionalExpression;
expressions.Decorator = Decorator;
expressions.DoExpression = DoExpression;
expressions.EmptyStatement = EmptyStatement;
expressions.ExpressionStatement = ExpressionStatement;
expressions.Import = Import;
expressions.MemberExpression = MemberExpression;
expressions.MetaProperty = MetaProperty;
expressions.ModuleExpression = ModuleExpression;
expressions.NewExpression = NewExpression;
expressions.OptionalCallExpression = OptionalCallExpression;
expressions.OptionalMemberExpression = OptionalMemberExpression;
expressions.ParenthesizedExpression = ParenthesizedExpression;
expressions.PrivateName = PrivateName;
expressions.SequenceExpression = SequenceExpression;
expressions.Super = Super;
expressions.ThisExpression = ThisExpression;
expressions.UnaryExpression = UnaryExpression;
expressions.UpdateExpression = UpdateExpression;
expressions.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
expressions.YieldExpression = YieldExpression;
expressions._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;
var _t$j = requireLib$1(), n$1 = node;
const {
  isCallExpression: isCallExpression$1,
  isLiteral: isLiteral$2,
  isMemberExpression,
  isNewExpression: isNewExpression$1
} = _t$j;
function UnaryExpression(e) {
  const {
    operator: t
  } = e;
  t === "void" || t === "delete" || t === "typeof" || t === "throw" ? (this.word(t), this.space()) : this.token(t), this.print(e.argument, e);
}
function DoExpression(e) {
  e.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(e.body, e);
}
function ParenthesizedExpression(e) {
  this.tokenChar(40), this.print(e.expression, e), this.rightParens(e);
}
function UpdateExpression(e) {
  e.prefix ? (this.token(e.operator), this.print(e.argument, e)) : (this.printTerminatorless(e.argument, e, !0), this.token(e.operator));
}
function ConditionalExpression(e) {
  this.print(e.test, e), this.space(), this.tokenChar(63), this.space(), this.print(e.consequent, e), this.space(), this.tokenChar(58), this.space(), this.print(e.alternate, e);
}
function NewExpression(e, t) {
  this.word("new"), this.space(), this.print(e.callee, e), !(this.format.minified && e.arguments.length === 0 && !e.optional && !isCallExpression$1(t, {
    callee: e
  }) && !isMemberExpression(t) && !isNewExpression$1(t)) && (this.print(e.typeArguments, e), this.print(e.typeParameters, e), e.optional && this.token("?."), this.tokenChar(40), this.printList(e.arguments, e), this.rightParens(e));
}
function SequenceExpression(e) {
  this.printList(e.expressions, e);
}
function ThisExpression() {
  this.word("this");
}
function Super() {
  this.word("super");
}
function isDecoratorMemberExpression(e) {
  switch (e.type) {
    case "Identifier":
      return !0;
    case "MemberExpression":
      return !e.computed && e.property.type === "Identifier" && isDecoratorMemberExpression(e.object);
    default:
      return !1;
  }
}
function shouldParenthesizeDecoratorExpression(e) {
  return e.type === "ParenthesizedExpression" ? !1 : !isDecoratorMemberExpression(e.type === "CallExpression" ? e.callee : e);
}
function _shouldPrintDecoratorsBeforeExport(e) {
  return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof e.start == "number" && e.start === e.declaration.start;
}
function Decorator(e) {
  this.tokenChar(64);
  const {
    expression: t
  } = e;
  shouldParenthesizeDecoratorExpression(t) ? (this.tokenChar(40), this.print(t, e), this.tokenChar(41)) : this.print(t, e), this.newline();
}
function OptionalMemberExpression(e) {
  let {
    computed: t
  } = e;
  const {
    optional: s,
    property: i
  } = e;
  if (this.print(e.object, e), !t && isMemberExpression(i))
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  isLiteral$2(i) && typeof i.value == "number" && (t = !0), s && this.token("?."), t ? (this.tokenChar(91), this.print(i, e), this.tokenChar(93)) : (s || this.tokenChar(46), this.print(i, e));
}
function OptionalCallExpression(e) {
  this.print(e.callee, e), this.print(e.typeParameters, e), e.optional && this.token("?."), this.print(e.typeArguments, e), this.tokenChar(40), this.printList(e.arguments, e), this.rightParens(e);
}
function CallExpression(e) {
  this.print(e.callee, e), this.print(e.typeArguments, e), this.print(e.typeParameters, e), this.tokenChar(40), this.printList(e.arguments, e), this.rightParens(e);
}
function Import() {
  this.word("import");
}
function AwaitExpression(e) {
  this.word("await"), e.argument && (this.space(), this.printTerminatorless(e.argument, e, !1));
}
function YieldExpression(e) {
  this.word("yield", !0), e.delegate ? (this.tokenChar(42), e.argument && (this.space(), this.print(e.argument, e))) : e.argument && (this.space(), this.printTerminatorless(e.argument, e, !1));
}
function EmptyStatement() {
  this.semicolon(!0);
}
function ExpressionStatement(e) {
  this.print(e.expression, e), this.semicolon();
}
function AssignmentPattern(e) {
  this.print(e.left, e), e.left.optional && this.tokenChar(63), this.print(e.left.typeAnnotation, e), this.space(), this.tokenChar(61), this.space(), this.print(e.right, e);
}
function AssignmentExpression(e, t) {
  const s = this.inForStatementInitCounter && e.operator === "in" && !n$1.needsParens(e, t);
  s && this.tokenChar(40), this.print(e.left, e), this.space(), e.operator === "in" || e.operator === "instanceof" ? this.word(e.operator) : this.token(e.operator), this.space(), this.print(e.right, e), s && this.tokenChar(41);
}
function BindExpression(e) {
  this.print(e.object, e), this.token("::"), this.print(e.callee, e);
}
function MemberExpression(e) {
  if (this.print(e.object, e), !e.computed && isMemberExpression(e.property))
    throw new TypeError("Got a MemberExpression for MemberExpression property");
  let t = e.computed;
  isLiteral$2(e.property) && typeof e.property.value == "number" && (t = !0), t ? (this.tokenChar(91), this.print(e.property, e), this.tokenChar(93)) : (this.tokenChar(46), this.print(e.property, e));
}
function MetaProperty(e) {
  this.print(e.meta, e), this.tokenChar(46), this.print(e.property, e);
}
function PrivateName(e) {
  this.tokenChar(35), this.print(e.id, e);
}
function V8IntrinsicIdentifier(e) {
  this.tokenChar(37), this.word(e.name);
}
function ModuleExpression(e) {
  this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
  const {
    body: t
  } = e;
  (t.body.length || t.directives.length) && this.newline(), this.print(t, e), this.dedent(), this.rightBrace(e);
}
var statements$2 = {};
Object.defineProperty(statements$2, "__esModule", {
  value: !0
});
statements$2.BreakStatement = BreakStatement;
statements$2.CatchClause = CatchClause;
statements$2.ContinueStatement = ContinueStatement;
statements$2.DebuggerStatement = DebuggerStatement;
statements$2.DoWhileStatement = DoWhileStatement;
statements$2.ForOfStatement = statements$2.ForInStatement = void 0;
statements$2.ForStatement = ForStatement;
statements$2.IfStatement = IfStatement;
statements$2.LabeledStatement = LabeledStatement;
statements$2.ReturnStatement = ReturnStatement;
statements$2.SwitchCase = SwitchCase;
statements$2.SwitchStatement = SwitchStatement;
statements$2.ThrowStatement = ThrowStatement;
statements$2.TryStatement = TryStatement;
statements$2.VariableDeclaration = VariableDeclaration;
statements$2.VariableDeclarator = VariableDeclarator;
statements$2.WhileStatement = WhileStatement;
statements$2.WithStatement = WithStatement;
var _t$i = requireLib$1();
const {
  isFor,
  isForStatement,
  isIfStatement,
  isStatement: isStatement$4
} = _t$i;
function WithStatement(e) {
  this.word("with"), this.space(), this.tokenChar(40), this.print(e.object, e), this.tokenChar(41), this.printBlock(e);
}
function IfStatement(e) {
  this.word("if"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.space();
  const t = e.alternate && isIfStatement(getLastStatement(e.consequent));
  t && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(e.consequent, e), t && (this.dedent(), this.newline(), this.tokenChar(125)), e.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(e.alternate, e));
}
function getLastStatement(e) {
  const {
    body: t
  } = e;
  return isStatement$4(t) === !1 ? e : getLastStatement(t);
}
function ForStatement(e) {
  this.word("for"), this.space(), this.tokenChar(40), this.inForStatementInitCounter++, this.print(e.init, e), this.inForStatementInitCounter--, this.tokenChar(59), e.test && (this.space(), this.print(e.test, e)), this.tokenChar(59), e.update && (this.space(), this.print(e.update, e)), this.tokenChar(41), this.printBlock(e);
}
function WhileStatement(e) {
  this.word("while"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.printBlock(e);
}
function ForXStatement(e) {
  this.word("for"), this.space();
  const t = e.type === "ForOfStatement";
  t && e.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40), this.print(e.left, e), this.space(), this.word(t ? "of" : "in"), this.space(), this.print(e.right, e), this.tokenChar(41), this.printBlock(e);
}
statements$2.ForInStatement = ForXStatement;
statements$2.ForOfStatement = ForXStatement;
function DoWhileStatement(e) {
  this.word("do"), this.space(), this.print(e.body, e), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e.test, e), this.tokenChar(41), this.semicolon();
}
function printStatementAfterKeyword(e, t, s, i) {
  t && (e.space(), e.printTerminatorless(t, s, i)), e.semicolon();
}
function BreakStatement(e) {
  this.word("break"), printStatementAfterKeyword(this, e.label, e, !0);
}
function ContinueStatement(e) {
  this.word("continue"), printStatementAfterKeyword(this, e.label, e, !0);
}
function ReturnStatement(e) {
  this.word("return"), printStatementAfterKeyword(this, e.argument, e, !1);
}
function ThrowStatement(e) {
  this.word("throw"), printStatementAfterKeyword(this, e.argument, e, !1);
}
function LabeledStatement(e) {
  this.print(e.label, e), this.tokenChar(58), this.space(), this.print(e.body, e);
}
function TryStatement(e) {
  this.word("try"), this.space(), this.print(e.block, e), this.space(), e.handlers ? this.print(e.handlers[0], e) : this.print(e.handler, e), e.finalizer && (this.space(), this.word("finally"), this.space(), this.print(e.finalizer, e));
}
function CatchClause(e) {
  this.word("catch"), this.space(), e.param && (this.tokenChar(40), this.print(e.param, e), this.print(e.param.typeAnnotation, e), this.tokenChar(41), this.space()), this.print(e.body, e);
}
function SwitchStatement(e) {
  this.word("switch"), this.space(), this.tokenChar(40), this.print(e.discriminant, e), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(e.cases, e, {
    indent: !0,
    addNewlines(t, s) {
      if (!t && e.cases[e.cases.length - 1] === s)
        return -1;
    }
  }), this.rightBrace(e);
}
function SwitchCase(e) {
  e.test ? (this.word("case"), this.space(), this.print(e.test, e), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), e.consequent.length && (this.newline(), this.printSequence(e.consequent, e, {
    indent: !0
  }));
}
function DebuggerStatement() {
  this.word("debugger"), this.semicolon();
}
function VariableDeclaration(e, t) {
  e.declare && (this.word("declare"), this.space());
  const {
    kind: s
  } = e;
  this.word(s, s === "using" || s === "await using"), this.space();
  let i = !1;
  if (!isFor(t))
    for (const a of e.declarations)
      a.init && (i = !0);
  if (this.printList(e.declarations, e, {
    separator: i ? function() {
      this.tokenChar(44), this.newline();
    } : void 0,
    indent: e.declarations.length > 1
  }), isFor(t)) {
    if (isForStatement(t)) {
      if (t.init === e)
        return;
    } else if (t.left === e)
      return;
  }
  this.semicolon();
}
function VariableDeclarator(e) {
  this.print(e.id, e), e.definite && this.tokenChar(33), this.print(e.id.typeAnnotation, e), e.init && (this.space(), this.tokenChar(61), this.space(), this.print(e.init, e));
}
var classes = {};
Object.defineProperty(classes, "__esModule", {
  value: !0
});
classes.ClassAccessorProperty = ClassAccessorProperty;
classes.ClassBody = ClassBody;
classes.ClassExpression = classes.ClassDeclaration = ClassDeclaration;
classes.ClassMethod = ClassMethod;
classes.ClassPrivateMethod = ClassPrivateMethod;
classes.ClassPrivateProperty = ClassPrivateProperty;
classes.ClassProperty = ClassProperty;
classes.StaticBlock = StaticBlock;
classes._classMethodHead = _classMethodHead;
var _t$h = requireLib$1();
const {
  isExportDefaultDeclaration,
  isExportNamedDeclaration
} = _t$h;
function ClassDeclaration(e, t) {
  (!(isExportDefaultDeclaration(t) || isExportNamedDeclaration(t)) || !this._shouldPrintDecoratorsBeforeExport(t)) && this.printJoin(e.decorators, e), e.declare && (this.word("declare"), this.space()), e.abstract && (this.word("abstract"), this.space()), this.word("class"), e.id && (this.space(), this.print(e.id, e)), this.print(e.typeParameters, e), e.superClass && (this.space(), this.word("extends"), this.space(), this.print(e.superClass, e), this.print(e.superTypeParameters, e)), e.implements && (this.space(), this.word("implements"), this.space(), this.printList(e.implements, e)), this.space(), this.print(e.body, e);
}
function ClassBody(e) {
  this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(e.body, e, {
    indent: !0
  }), this.endsWith(10) || this.newline(), this.rightBrace(e));
}
function ClassProperty(e) {
  var t;
  this.printJoin(e.decorators, e);
  const s = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
  s && this.catchUp(s), this.tsPrintClassMemberModifiers(e), e.computed ? (this.tokenChar(91), this.print(e.key, e), this.tokenChar(93)) : (this._variance(e), this.print(e.key, e)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation, e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
}
function ClassAccessorProperty(e) {
  var t;
  this.printJoin(e.decorators, e);
  const s = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
  s && this.catchUp(s), this.tsPrintClassMemberModifiers(e), this.word("accessor", !0), this.space(), e.computed ? (this.tokenChar(91), this.print(e.key, e), this.tokenChar(93)) : (this._variance(e), this.print(e.key, e)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation, e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
}
function ClassPrivateProperty(e) {
  this.printJoin(e.decorators, e), e.static && (this.word("static"), this.space()), this.print(e.key, e), this.print(e.typeAnnotation, e), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value, e)), this.semicolon();
}
function ClassMethod(e) {
  this._classMethodHead(e), this.space(), this.print(e.body, e);
}
function ClassPrivateMethod(e) {
  this._classMethodHead(e), this.space(), this.print(e.body, e);
}
function _classMethodHead(e) {
  var t;
  this.printJoin(e.decorators, e);
  const s = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
  s && this.catchUp(s), this.tsPrintClassMemberModifiers(e), this._methodHead(e);
}
function StaticBlock(e) {
  this.word("static"), this.space(), this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(e.body, e, {
    indent: !0
  }), this.rightBrace(e));
}
var methods = {};
Object.defineProperty(methods, "__esModule", {
  value: !0
});
methods.ArrowFunctionExpression = ArrowFunctionExpression;
methods.FunctionDeclaration = methods.FunctionExpression = FunctionExpression;
methods._functionHead = _functionHead;
methods._methodHead = _methodHead;
methods._param = _param;
methods._parameters = _parameters;
methods._params = _params;
methods._predicate = _predicate;
var _t$g = requireLib$1();
const {
  isIdentifier: isIdentifier$6
} = _t$g;
function _params(e, t, s) {
  this.print(e.typeParameters, e);
  const i = _getFuncIdName.call(this, t, s);
  i && this.sourceIdentifierName(i.name, i.pos), this.tokenChar(40), this._parameters(e.params, e), this.tokenChar(41);
  const a = e.type === "ArrowFunctionExpression";
  this.print(e.returnType, e, a), this._noLineTerminator = a;
}
function _parameters(e, t) {
  const s = e.length;
  for (let i = 0; i < s; i++)
    this._param(e[i], t), i < e.length - 1 && (this.tokenChar(44), this.space());
}
function _param(e, t) {
  this.printJoin(e.decorators, e), this.print(e, t), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
}
function _methodHead(e) {
  const t = e.kind, s = e.key;
  (t === "get" || t === "set") && (this.word(t), this.space()), e.async && (this.word("async", !0), this.space()), (t === "method" || t === "init") && e.generator && this.tokenChar(42), e.computed ? (this.tokenChar(91), this.print(s, e), this.tokenChar(93)) : this.print(s, e), e.optional && this.tokenChar(63), this._params(e, e.computed && e.key.type !== "StringLiteral" ? void 0 : e.key, void 0);
}
function _predicate(e, t) {
  e.predicate && (e.returnType || this.tokenChar(58), this.space(), this.print(e.predicate, e, t));
}
function _functionHead(e, t) {
  e.async && (this.word("async"), this._endsWithInnerRaw = !1, this.space()), this.word("function"), e.generator && (this._endsWithInnerRaw = !1, this.tokenChar(42)), this.space(), e.id && this.print(e.id, e), this._params(e, e.id, t), e.type !== "TSDeclareFunction" && this._predicate(e);
}
function FunctionExpression(e, t) {
  this._functionHead(e, t), this.space(), this.print(e.body, e);
}
function ArrowFunctionExpression(e, t) {
  e.async && (this.word("async", !0), this.space());
  let s;
  !this.format.retainLines && e.params.length === 1 && isIdentifier$6(s = e.params[0]) && !hasTypesOrComments(e, s) ? this.print(s, e, !0) : this._params(e, void 0, t), this._predicate(e, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.print(e.body, e);
}
function hasTypesOrComments(e, t) {
  var s, i;
  return !!(e.typeParameters || e.returnType || e.predicate || t.typeAnnotation || t.optional || (s = t.leadingComments) != null && s.length || (i = t.trailingComments) != null && i.length);
}
function _getFuncIdName(e, t) {
  let s = e;
  if (!s && t) {
    const y = t.type;
    y === "VariableDeclarator" ? s = t.id : y === "AssignmentExpression" || y === "AssignmentPattern" ? s = t.left : y === "ObjectProperty" || y === "ClassProperty" ? (!t.computed || t.key.type === "StringLiteral") && (s = t.key) : (y === "ClassPrivateProperty" || y === "ClassAccessorProperty") && (s = t.key);
  }
  if (!s)
    return;
  let i;
  if (s.type === "Identifier") {
    var a, o;
    i = {
      pos: (a = s.loc) == null ? void 0 : a.start,
      name: ((o = s.loc) == null ? void 0 : o.identifierName) || s.name
    };
  } else if (s.type === "PrivateName") {
    var l;
    i = {
      pos: (l = s.loc) == null ? void 0 : l.start,
      name: "#" + s.id.name
    };
  } else if (s.type === "StringLiteral") {
    var f;
    i = {
      pos: (f = s.loc) == null ? void 0 : f.start,
      name: s.value
    };
  }
  return i;
}
var modules = {};
Object.defineProperty(modules, "__esModule", {
  value: !0
});
modules.ExportAllDeclaration = ExportAllDeclaration;
modules.ExportDefaultDeclaration = ExportDefaultDeclaration;
modules.ExportDefaultSpecifier = ExportDefaultSpecifier;
modules.ExportNamedDeclaration = ExportNamedDeclaration;
modules.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
modules.ExportSpecifier = ExportSpecifier;
modules.ImportAttribute = ImportAttribute;
modules.ImportDeclaration = ImportDeclaration;
modules.ImportDefaultSpecifier = ImportDefaultSpecifier;
modules.ImportExpression = ImportExpression;
modules.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
modules.ImportSpecifier = ImportSpecifier;
modules._printAttributes = _printAttributes;
var _t$f = requireLib$1();
const {
  isClassDeclaration,
  isExportDefaultSpecifier,
  isExportNamespaceSpecifier,
  isImportDefaultSpecifier,
  isImportNamespaceSpecifier,
  isStatement: isStatement$3
} = _t$f;
function ImportSpecifier(e) {
  (e.importKind === "type" || e.importKind === "typeof") && (this.word(e.importKind), this.space()), this.print(e.imported, e), e.local && e.local.name !== e.imported.name && (this.space(), this.word("as"), this.space(), this.print(e.local, e));
}
function ImportDefaultSpecifier(e) {
  this.print(e.local, e);
}
function ExportDefaultSpecifier(e) {
  this.print(e.exported, e);
}
function ExportSpecifier(e) {
  e.exportKind === "type" && (this.word("type"), this.space()), this.print(e.local, e), e.exported && e.local.name !== e.exported.name && (this.space(), this.word("as"), this.space(), this.print(e.exported, e));
}
function ExportNamespaceSpecifier(e) {
  this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.exported, e);
}
let warningShown = !1;
function _printAttributes(e) {
  const {
    importAttributesKeyword: t
  } = this.format, {
    attributes: s,
    assertions: i
  } = e;
  s && !t && !warningShown && (warningShown = !0, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
  const a = t === "assert" || !t && i;
  if (this.word(a ? "assert" : "with"), this.space(), !a && t !== "with") {
    this.printList(s || i, e);
    return;
  }
  this.tokenChar(123), this.space(), this.printList(s || i, e), this.space(), this.tokenChar(125);
}
function ExportAllDeclaration(e) {
  var t, s;
  this.word("export"), this.space(), e.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (s = e.assertions) != null && s.length ? (this.print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e), this.semicolon();
}
function maybePrintDecoratorsBeforeExport(e, t) {
  isClassDeclaration(t.declaration) && e._shouldPrintDecoratorsBeforeExport(t) && e.printJoin(t.declaration.decorators, t);
}
function ExportNamedDeclaration(e) {
  if (maybePrintDecoratorsBeforeExport(this, e), this.word("export"), this.space(), e.declaration) {
    const i = e.declaration;
    this.print(i, e), isStatement$3(i) || this.semicolon();
  } else {
    e.exportKind === "type" && (this.word("type"), this.space());
    const i = e.specifiers.slice(0);
    let a = !1;
    for (; ; ) {
      const o = i[0];
      if (isExportDefaultSpecifier(o) || isExportNamespaceSpecifier(o))
        a = !0, this.print(i.shift(), e), i.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    if ((i.length || !i.length && !a) && (this.tokenChar(123), i.length && (this.space(), this.printList(i, e), this.space()), this.tokenChar(125)), e.source) {
      var t, s;
      this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (s = e.assertions) != null && s.length ? (this.print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e);
    }
    this.semicolon();
  }
}
function ExportDefaultDeclaration(e) {
  maybePrintDecoratorsBeforeExport(this, e), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space();
  const t = e.declaration;
  this.print(t, e), isStatement$3(t) || this.semicolon();
}
function ImportDeclaration(e) {
  var t, s;
  this.word("import"), this.space();
  const i = e.importKind === "type" || e.importKind === "typeof";
  i ? (this.noIndentInnerCommentsHere(), this.word(e.importKind), this.space()) : e.module ? (this.noIndentInnerCommentsHere(), this.word("module"), this.space()) : e.phase && (this.noIndentInnerCommentsHere(), this.word(e.phase), this.space());
  const a = e.specifiers.slice(0), o = !!a.length;
  for (; o; ) {
    const l = a[0];
    if (isImportDefaultSpecifier(l) || isImportNamespaceSpecifier(l))
      this.print(a.shift(), e), a.length && (this.tokenChar(44), this.space());
    else
      break;
  }
  a.length ? (this.tokenChar(123), this.space(), this.printList(a, e), this.space(), this.tokenChar(125)) : i && !o && (this.tokenChar(123), this.tokenChar(125)), (o || i) && (this.space(), this.word("from"), this.space()), (t = e.attributes) != null && t.length || (s = e.assertions) != null && s.length ? (this.print(e.source, e, !0), this.space(), this._printAttributes(e)) : this.print(e.source, e), this.semicolon();
}
function ImportAttribute(e) {
  this.print(e.key), this.tokenChar(58), this.space(), this.print(e.value);
}
function ImportNamespaceSpecifier(e) {
  this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.local, e);
}
function ImportExpression(e) {
  this.word("import"), e.phase && (this.tokenChar(46), this.word(e.phase)), this.tokenChar(40), this.print(e.source, e), e.options != null && (this.tokenChar(44), this.space(), this.print(e.options, e)), this.tokenChar(41);
}
var types$1 = {};
const object = {}, hasOwnProperty = object.hasOwnProperty, forOwn = (e, t) => {
  for (const s in e)
    hasOwnProperty.call(e, s) && t(s, e[s]);
}, extend = (e, t) => (t && forOwn(t, (s, i) => {
  e[s] = i;
}), e), forEach = (e, t) => {
  const s = e.length;
  let i = -1;
  for (; ++i < s; )
    t(e[i]);
}, toString = object.toString, isArray$1 = Array.isArray, isBuffer = Buffer.isBuffer, isObject = (e) => toString.call(e) == "[object Object]", isString = (e) => typeof e == "string" || toString.call(e) == "[object String]", isNumber$1 = (e) => typeof e == "number" || toString.call(e) == "[object Number]", isFunction$3 = (e) => typeof e == "function", isMap = (e) => toString.call(e) == "[object Map]", isSet = (e) => toString.call(e) == "[object Set]", singleEscapes = {
  '"': '\\"',
  "'": "\\'",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
  // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
  // '\v': '\\x0B'
}, regexSingleEscape = /["'\\\b\f\n\r\t]/, regexDigit = /[0-9]/, regexWhitelist = /[ !#-&\(-\[\]-_a-~]/, jsesc = (e, t) => {
  const s = () => {
    g = y, ++t.indentLevel, y = t.indent.repeat(t.indentLevel);
  }, i = {
    escapeEverything: !1,
    minimal: !1,
    isScriptContext: !1,
    quotes: "single",
    wrap: !1,
    es6: !1,
    json: !1,
    compact: !0,
    lowercaseHex: !1,
    numbers: "decimal",
    indent: "	",
    indentLevel: 0,
    __inline1__: !1,
    __inline2__: !1
  }, a = t && t.json;
  a && (i.quotes = "double", i.wrap = !0), t = extend(i, t), t.quotes != "single" && t.quotes != "double" && t.quotes != "backtick" && (t.quotes = "single");
  const o = t.quotes == "double" ? '"' : t.quotes == "backtick" ? "`" : "'", l = t.compact, f = t.lowercaseHex;
  let y = t.indent.repeat(t.indentLevel), g = "";
  const T = t.__inline1__, S = t.__inline2__, b = l ? "" : `
`;
  let v, $ = !0;
  const U = t.numbers == "binary", X = t.numbers == "octal", k = t.numbers == "decimal", D = t.numbers == "hexadecimal";
  if (a && e && isFunction$3(e.toJSON) && (e = e.toJSON()), !isString(e)) {
    if (isMap(e))
      return e.size == 0 ? "new Map()" : (l || (t.__inline1__ = !0, t.__inline2__ = !1), "new Map(" + jsesc(Array.from(e), t) + ")");
    if (isSet(e))
      return e.size == 0 ? "new Set()" : "new Set(" + jsesc(Array.from(e), t) + ")";
    if (isBuffer(e))
      return e.length == 0 ? "Buffer.from([])" : "Buffer.from(" + jsesc(Array.from(e), t) + ")";
    if (isArray$1(e))
      return v = [], t.wrap = !0, T && (t.__inline1__ = !1, t.__inline2__ = !0), S || s(), forEach(e, (q) => {
        $ = !1, S && (t.__inline2__ = !1), v.push(
          (l || S ? "" : y) + jsesc(q, t)
        );
      }), $ ? "[]" : S ? "[" + v.join(", ") + "]" : "[" + b + v.join("," + b) + b + (l ? "" : g) + "]";
    if (isNumber$1(e)) {
      if (a)
        return JSON.stringify(e);
      if (k)
        return String(e);
      if (D) {
        let q = e.toString(16);
        return f || (q = q.toUpperCase()), "0x" + q;
      }
      if (U)
        return "0b" + e.toString(2);
      if (X)
        return "0o" + e.toString(8);
    } else
      return isObject(e) ? (v = [], t.wrap = !0, s(), forOwn(e, (q, _) => {
        $ = !1, v.push(
          (l ? "" : y) + jsesc(q, t) + ":" + (l ? "" : " ") + jsesc(_, t)
        );
      }), $ ? "{}" : "{" + b + v.join("," + b) + b + (l ? "" : g) + "}") : a ? JSON.stringify(e) || "null" : String(e);
  }
  const B = e;
  let Z = -1;
  const H = B.length;
  for (v = ""; ++Z < H; ) {
    const q = B.charAt(Z);
    if (t.es6) {
      const ee = B.charCodeAt(Z);
      if (
        // check if it’s the start of a surrogate pair
        ee >= 55296 && ee <= 56319 && // high surrogate
        H > Z + 1
      ) {
        const se = B.charCodeAt(Z + 1);
        if (se >= 56320 && se <= 57343) {
          let ve = ((ee - 55296) * 1024 + se - 56320 + 65536).toString(16);
          f || (ve = ve.toUpperCase()), v += "\\u{" + ve + "}", ++Z;
          continue;
        }
      }
    }
    if (!t.escapeEverything) {
      if (regexWhitelist.test(q)) {
        v += q;
        continue;
      }
      if (q == '"') {
        v += o == q ? '\\"' : q;
        continue;
      }
      if (q == "`") {
        v += o == q ? "\\`" : q;
        continue;
      }
      if (q == "'") {
        v += o == q ? "\\'" : q;
        continue;
      }
    }
    if (q == "\0" && !a && !regexDigit.test(B.charAt(Z + 1))) {
      v += "\\0";
      continue;
    }
    if (regexSingleEscape.test(q)) {
      v += singleEscapes[q];
      continue;
    }
    const _ = q.charCodeAt(0);
    if (t.minimal && _ != 8232 && _ != 8233) {
      v += q;
      continue;
    }
    let j = _.toString(16);
    f || (j = j.toUpperCase());
    const V = j.length > 2 || a, ue = "\\" + (V ? "u" : "x") + ("0000" + j).slice(V ? -4 : -2);
    v += ue;
  }
  return t.wrap && (v = o + v + o), o == "`" && (v = v.replace(/\$\{/g, "\\${")), t.isScriptContext ? v.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, a ? "\\u003C!--" : "\\x3C!--") : v;
};
jsesc.version = "2.5.2";
var jsesc_1 = jsesc;
Object.defineProperty(types$1, "__esModule", {
  value: !0
});
types$1.ArgumentPlaceholder = ArgumentPlaceholder;
types$1.ArrayPattern = types$1.ArrayExpression = ArrayExpression;
types$1.BigIntLiteral = BigIntLiteral;
types$1.BooleanLiteral = BooleanLiteral;
types$1.DecimalLiteral = DecimalLiteral;
types$1.Identifier = Identifier;
types$1.NullLiteral = NullLiteral;
types$1.NumericLiteral = NumericLiteral;
types$1.ObjectPattern = types$1.ObjectExpression = ObjectExpression;
types$1.ObjectMethod = ObjectMethod;
types$1.ObjectProperty = ObjectProperty;
types$1.PipelineBareFunction = PipelineBareFunction;
types$1.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
types$1.PipelineTopicExpression = PipelineTopicExpression;
types$1.RecordExpression = RecordExpression;
types$1.RegExpLiteral = RegExpLiteral;
types$1.SpreadElement = types$1.RestElement = RestElement;
types$1.StringLiteral = StringLiteral;
types$1.TopicReference = TopicReference;
types$1.TupleExpression = TupleExpression;
var _t$e = requireLib$1(), _jsesc = jsesc_1;
const {
  isAssignmentPattern: isAssignmentPattern$1,
  isIdentifier: isIdentifier$5
} = _t$e;
function Identifier(e) {
  var t;
  this.sourceIdentifierName(((t = e.loc) == null ? void 0 : t.identifierName) || e.name), this.word(e.name);
}
function ArgumentPlaceholder() {
  this.tokenChar(63);
}
function RestElement(e) {
  this.token("..."), this.print(e.argument, e);
}
function ObjectExpression(e) {
  const t = e.properties;
  this.tokenChar(123), t.length && (this.space(), this.printList(t, e, {
    indent: !0,
    statement: !0
  }), this.space()), this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
}
function ObjectMethod(e) {
  this.printJoin(e.decorators, e), this._methodHead(e), this.space(), this.print(e.body, e);
}
function ObjectProperty(e) {
  if (this.printJoin(e.decorators, e), e.computed)
    this.tokenChar(91), this.print(e.key, e), this.tokenChar(93);
  else {
    if (isAssignmentPattern$1(e.value) && isIdentifier$5(e.key) && e.key.name === e.value.left.name) {
      this.print(e.value, e);
      return;
    }
    if (this.print(e.key, e), e.shorthand && isIdentifier$5(e.key) && isIdentifier$5(e.value) && e.key.name === e.value.name)
      return;
  }
  this.tokenChar(58), this.space(), this.print(e.value, e);
}
function ArrayExpression(e) {
  const t = e.elements, s = t.length;
  this.tokenChar(91);
  for (let i = 0; i < t.length; i++) {
    const a = t[i];
    a ? (i > 0 && this.space(), this.print(a, e), i < s - 1 && this.tokenChar(44)) : this.tokenChar(44);
  }
  this.tokenChar(93);
}
function RecordExpression(e) {
  const t = e.properties;
  let s, i;
  if (this.format.recordAndTupleSyntaxType === "bar")
    s = "{|", i = "|}";
  else {
    if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
      throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
    s = "#{", i = "}";
  }
  this.token(s), t.length && (this.space(), this.printList(t, e, {
    indent: !0,
    statement: !0
  }), this.space()), this.token(i);
}
function TupleExpression(e) {
  const t = e.elements, s = t.length;
  let i, a;
  if (this.format.recordAndTupleSyntaxType === "bar")
    i = "[|", a = "|]";
  else if (this.format.recordAndTupleSyntaxType === "hash")
    i = "#[", a = "]";
  else
    throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
  this.token(i);
  for (let o = 0; o < t.length; o++) {
    const l = t[o];
    l && (o > 0 && this.space(), this.print(l, e), o < s - 1 && this.tokenChar(44));
  }
  this.token(a);
}
function RegExpLiteral(e) {
  this.word(`/${e.pattern}/${e.flags}`);
}
function BooleanLiteral(e) {
  this.word(e.value ? "true" : "false");
}
function NullLiteral() {
  this.word("null");
}
function NumericLiteral(e) {
  const t = this.getPossibleRaw(e), s = this.format.jsescOption, i = e.value, a = i + "";
  s.numbers ? this.number(_jsesc(i, s), i) : t == null ? this.number(a, i) : this.format.minified ? this.number(t.length < a.length ? t : a, i) : this.number(t, i);
}
function StringLiteral(e) {
  const t = this.getPossibleRaw(e);
  if (!this.format.minified && t !== void 0) {
    this.token(t);
    return;
  }
  const s = _jsesc(e.value, this.format.jsescOption);
  this.token(s);
}
function BigIntLiteral(e) {
  const t = this.getPossibleRaw(e);
  if (!this.format.minified && t !== void 0) {
    this.word(t);
    return;
  }
  this.word(e.value + "n");
}
function DecimalLiteral(e) {
  const t = this.getPossibleRaw(e);
  if (!this.format.minified && t !== void 0) {
    this.word(t);
    return;
  }
  this.word(e.value + "m");
}
const validTopicTokenSet = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
function TopicReference() {
  const {
    topicToken: e
  } = this.format;
  if (validTopicTokenSet.has(e))
    this.token(e);
  else {
    const t = JSON.stringify(e), s = Array.from(validTopicTokenSet, (i) => JSON.stringify(i));
    throw new Error(`The "topicToken" generator option must be one of ${s.join(", ")} (${t} received instead).`);
  }
}
function PipelineTopicExpression(e) {
  this.print(e.expression, e);
}
function PipelineBareFunction(e) {
  this.print(e.callee, e);
}
function PipelinePrimaryTopicReference() {
  this.tokenChar(35);
}
var flow$1 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.AnyTypeAnnotation = l, e.ArrayTypeAnnotation = f, e.BooleanLiteralTypeAnnotation = g, e.BooleanTypeAnnotation = y, e.DeclareClass = S, e.DeclareExportAllDeclaration = q, e.DeclareExportDeclaration = H, e.DeclareFunction = b, e.DeclareInterface = U, e.DeclareModule = X, e.DeclareModuleExports = k, e.DeclareOpaqueType = B, e.DeclareTypeAlias = D, e.DeclareVariable = Z, e.DeclaredPredicate = $, e.EmptyTypeAnnotation = te, e.EnumBooleanBody = ue, e.EnumBooleanMember = R, e.EnumDeclaration = _, e.EnumDefaultedMember = ve, e.EnumNumberBody = ee, e.EnumNumberMember = K, e.EnumStringBody = se, e.EnumStringMember = z, e.EnumSymbolBody = be, e.ExistsTypeAnnotation = ie, e.FunctionTypeAnnotation = fe, e.FunctionTypeParam = ce, e.IndexedAccessType = Ve, e.InferredPredicate = v, e.InterfaceDeclaration = ge, e.GenericTypeAnnotation = e.ClassImplements = e.InterfaceExtends = Pe, e.InterfaceTypeAnnotation = we, e.IntersectionTypeAnnotation = G, e.MixedTypeAnnotation = W, e.NullLiteralTypeAnnotation = T, e.NullableTypeAnnotation = oe, Object.defineProperty(e, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return i.NumericLiteral;
    }
  }), e.NumberTypeAnnotation = me, e.ObjectTypeAnnotation = Y, e.ObjectTypeCallProperty = de, e.ObjectTypeIndexer = Ae, e.ObjectTypeInternalSlot = ne, e.ObjectTypeProperty = Ne, e.ObjectTypeSpreadProperty = ke, e.OpaqueType = N, e.OptionalIndexedAccessType = Ue, e.QualifiedTypeIdentifier = Le, Object.defineProperty(e, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: function() {
      return i.StringLiteral;
    }
  }), e.StringTypeAnnotation = pe, e.SymbolTypeAnnotation = Me, e.ThisTypeAnnotation = ye, e.TupleTypeAnnotation = le, e.TypeAlias = Se, e.TypeAnnotation = Ie, e.TypeCastExpression = je, e.TypeParameter = A, e.TypeParameterDeclaration = e.TypeParameterInstantiation = J, e.TypeofTypeAnnotation = he, e.UnionTypeAnnotation = ae, e.Variance = Re, e.VoidTypeAnnotation = qe, e._interfaceish = Ce, e._variance = _e;
  var t = requireLib$1(), s = modules, i = types$1;
  const {
    isDeclareExportDeclaration: a,
    isStatement: o
  } = t;
  function l() {
    this.word("any");
  }
  function f(C) {
    this.print(C.elementType, C, !0), this.tokenChar(91), this.tokenChar(93);
  }
  function y() {
    this.word("boolean");
  }
  function g(C) {
    this.word(C.value ? "true" : "false");
  }
  function T() {
    this.word("null");
  }
  function S(C, Ee) {
    a(Ee) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(C);
  }
  function b(C, Ee) {
    a(Ee) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(C.id, C), this.print(C.id.typeAnnotation.typeAnnotation, C), C.predicate && (this.space(), this.print(C.predicate, C)), this.semicolon();
  }
  function v() {
    this.tokenChar(37), this.word("checks");
  }
  function $(C) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(C.value, C), this.tokenChar(41);
  }
  function U(C) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(C);
  }
  function X(C) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(C.id, C), this.space(), this.print(C.body, C);
  }
  function k(C) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(C.typeAnnotation, C);
  }
  function D(C) {
    this.word("declare"), this.space(), this.TypeAlias(C);
  }
  function B(C, Ee) {
    a(Ee) || (this.word("declare"), this.space()), this.OpaqueType(C);
  }
  function Z(C, Ee) {
    a(Ee) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(C.id, C), this.print(C.id.typeAnnotation, C), this.semicolon();
  }
  function H(C) {
    this.word("declare"), this.space(), this.word("export"), this.space(), C.default && (this.word("default"), this.space()), re.call(this, C);
  }
  function q(C) {
    this.word("declare"), this.space(), s.ExportAllDeclaration.call(this, C);
  }
  function _(C) {
    const {
      id: Ee,
      body: $e
    } = C;
    this.word("enum"), this.space(), this.print(Ee, C), this.print($e, C);
  }
  function j(C, Ee, $e) {
    $e && (C.space(), C.word("of"), C.space(), C.word(Ee)), C.space();
  }
  function V(C, Ee) {
    const {
      members: $e
    } = Ee;
    C.token("{"), C.indent(), C.newline();
    for (const Fe of $e)
      C.print(Fe, Ee), C.newline();
    Ee.hasUnknownMembers && (C.token("..."), C.newline()), C.dedent(), C.token("}");
  }
  function ue(C) {
    const {
      explicitType: Ee
    } = C;
    j(this, "boolean", Ee), V(this, C);
  }
  function ee(C) {
    const {
      explicitType: Ee
    } = C;
    j(this, "number", Ee), V(this, C);
  }
  function se(C) {
    const {
      explicitType: Ee
    } = C;
    j(this, "string", Ee), V(this, C);
  }
  function be(C) {
    j(this, "symbol", !0), V(this, C);
  }
  function ve(C) {
    const {
      id: Ee
    } = C;
    this.print(Ee, C), this.tokenChar(44);
  }
  function F(C, Ee) {
    const {
      id: $e,
      init: Fe
    } = Ee;
    C.print($e, Ee), C.space(), C.token("="), C.space(), C.print(Fe, Ee), C.token(",");
  }
  function R(C) {
    F(this, C);
  }
  function K(C) {
    F(this, C);
  }
  function z(C) {
    F(this, C);
  }
  function re(C) {
    if (C.declaration) {
      const Ee = C.declaration;
      this.print(Ee, C), o(Ee) || this.semicolon();
    } else
      this.tokenChar(123), C.specifiers.length && (this.space(), this.printList(C.specifiers, C), this.space()), this.tokenChar(125), C.source && (this.space(), this.word("from"), this.space(), this.print(C.source, C)), this.semicolon();
  }
  function ie() {
    this.tokenChar(42);
  }
  function fe(C, Ee) {
    this.print(C.typeParameters, C), this.tokenChar(40), C.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(C.this.typeAnnotation, C), (C.params.length || C.rest) && (this.tokenChar(44), this.space())), this.printList(C.params, C), C.rest && (C.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(C.rest, C)), this.tokenChar(41);
    const $e = Ee == null ? void 0 : Ee.type;
    $e != null && ($e === "ObjectTypeCallProperty" || $e === "ObjectTypeInternalSlot" || $e === "DeclareFunction" || $e === "ObjectTypeProperty" && Ee.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(C.returnType, C);
  }
  function ce(C) {
    this.print(C.name, C), C.optional && this.tokenChar(63), C.name && (this.tokenChar(58), this.space()), this.print(C.typeAnnotation, C);
  }
  function Pe(C) {
    this.print(C.id, C), this.print(C.typeParameters, C, !0);
  }
  function Ce(C) {
    var Ee;
    if (this.print(C.id, C), this.print(C.typeParameters, C), (Ee = C.extends) != null && Ee.length && (this.space(), this.word("extends"), this.space(), this.printList(C.extends, C)), C.type === "DeclareClass") {
      var $e, Fe;
      ($e = C.mixins) != null && $e.length && (this.space(), this.word("mixins"), this.space(), this.printList(C.mixins, C)), (Fe = C.implements) != null && Fe.length && (this.space(), this.word("implements"), this.space(), this.printList(C.implements, C));
    }
    this.space(), this.print(C.body, C);
  }
  function _e(C) {
    var Ee;
    const $e = (Ee = C.variance) == null ? void 0 : Ee.kind;
    $e != null && ($e === "plus" ? this.tokenChar(43) : $e === "minus" && this.tokenChar(45));
  }
  function ge(C) {
    this.word("interface"), this.space(), this._interfaceish(C);
  }
  function xe() {
    this.space(), this.tokenChar(38), this.space();
  }
  function we(C) {
    var Ee;
    this.word("interface"), (Ee = C.extends) != null && Ee.length && (this.space(), this.word("extends"), this.space(), this.printList(C.extends, C)), this.space(), this.print(C.body, C);
  }
  function G(C) {
    this.printJoin(C.types, C, {
      separator: xe
    });
  }
  function W() {
    this.word("mixed");
  }
  function te() {
    this.word("empty");
  }
  function oe(C) {
    this.tokenChar(63), this.print(C.typeAnnotation, C);
  }
  function me() {
    this.word("number");
  }
  function pe() {
    this.word("string");
  }
  function ye() {
    this.word("this");
  }
  function le(C) {
    this.tokenChar(91), this.printList(C.types, C), this.tokenChar(93);
  }
  function he(C) {
    this.word("typeof"), this.space(), this.print(C.argument, C);
  }
  function Se(C) {
    this.word("type"), this.space(), this.print(C.id, C), this.print(C.typeParameters, C), this.space(), this.tokenChar(61), this.space(), this.print(C.right, C), this.semicolon();
  }
  function Ie(C) {
    this.tokenChar(58), this.space(), C.optional && this.tokenChar(63), this.print(C.typeAnnotation, C);
  }
  function J(C) {
    this.tokenChar(60), this.printList(C.params, C, {}), this.tokenChar(62);
  }
  function A(C) {
    this._variance(C), this.word(C.name), C.bound && this.print(C.bound, C), C.default && (this.space(), this.tokenChar(61), this.space(), this.print(C.default, C));
  }
  function N(C) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(C.id, C), this.print(C.typeParameters, C), C.supertype && (this.tokenChar(58), this.space(), this.print(C.supertype, C)), C.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(C.impltype, C)), this.semicolon();
  }
  function Y(C) {
    C.exact ? this.token("{|") : this.tokenChar(123);
    const Ee = [...C.properties, ...C.callProperties || [], ...C.indexers || [], ...C.internalSlots || []];
    Ee.length && (this.newline(), this.space(), this.printJoin(Ee, C, {
      addNewlines($e) {
        if ($e && !Ee[0])
          return 1;
      },
      indent: !0,
      statement: !0,
      iterator: () => {
        (Ee.length !== 1 || C.inexact) && (this.tokenChar(44), this.space());
      }
    }), this.space()), C.inexact && (this.indent(), this.token("..."), Ee.length && this.newline(), this.dedent()), C.exact ? this.token("|}") : this.tokenChar(125);
  }
  function ne(C) {
    C.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(C.id, C), this.tokenChar(93), this.tokenChar(93), C.optional && this.tokenChar(63), C.method || (this.tokenChar(58), this.space()), this.print(C.value, C);
  }
  function de(C) {
    C.static && (this.word("static"), this.space()), this.print(C.value, C);
  }
  function Ae(C) {
    C.static && (this.word("static"), this.space()), this._variance(C), this.tokenChar(91), C.id && (this.print(C.id, C), this.tokenChar(58), this.space()), this.print(C.key, C), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(C.value, C);
  }
  function Ne(C) {
    C.proto && (this.word("proto"), this.space()), C.static && (this.word("static"), this.space()), (C.kind === "get" || C.kind === "set") && (this.word(C.kind), this.space()), this._variance(C), this.print(C.key, C), C.optional && this.tokenChar(63), C.method || (this.tokenChar(58), this.space()), this.print(C.value, C);
  }
  function ke(C) {
    this.token("..."), this.print(C.argument, C);
  }
  function Le(C) {
    this.print(C.qualification, C), this.tokenChar(46), this.print(C.id, C);
  }
  function Me() {
    this.word("symbol");
  }
  function De() {
    this.space(), this.tokenChar(124), this.space();
  }
  function ae(C) {
    this.printJoin(C.types, C, {
      separator: De
    });
  }
  function je(C) {
    this.tokenChar(40), this.print(C.expression, C), this.print(C.typeAnnotation, C), this.tokenChar(41);
  }
  function Re(C) {
    C.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  function qe() {
    this.word("void");
  }
  function Ve(C) {
    this.print(C.objectType, C, !0), this.tokenChar(91), this.print(C.indexType, C), this.tokenChar(93);
  }
  function Ue(C) {
    this.print(C.objectType, C), C.optional && this.token("?."), this.tokenChar(91), this.print(C.indexType, C), this.tokenChar(93);
  }
})(flow$1);
var base = {};
Object.defineProperty(base, "__esModule", {
  value: !0
});
base.BlockStatement = BlockStatement;
base.Directive = Directive;
base.DirectiveLiteral = DirectiveLiteral;
base.File = File;
base.InterpreterDirective = InterpreterDirective;
base.Placeholder = Placeholder;
base.Program = Program;
function File(e) {
  e.program && this.print(e.program.interpreter, e), this.print(e.program, e);
}
function Program(e) {
  var t;
  this.noIndentInnerCommentsHere(), this.printInnerComments();
  const s = (t = e.directives) == null ? void 0 : t.length;
  if (s) {
    var i;
    const a = e.body.length ? 2 : 1;
    this.printSequence(e.directives, e, {
      trailingCommentsLineOffset: a
    }), (i = e.directives[s - 1].trailingComments) != null && i.length || this.newline(a);
  }
  this.printSequence(e.body, e);
}
function BlockStatement(e) {
  var t;
  this.tokenChar(123);
  const s = (t = e.directives) == null ? void 0 : t.length;
  if (s) {
    var i;
    const a = e.body.length ? 2 : 1;
    this.printSequence(e.directives, e, {
      indent: !0,
      trailingCommentsLineOffset: a
    }), (i = e.directives[s - 1].trailingComments) != null && i.length || this.newline(a);
  }
  this.printSequence(e.body, e, {
    indent: !0
  }), this.rightBrace(e);
}
function Directive(e) {
  this.print(e.value, e), this.semicolon();
}
const unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/, unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
function DirectiveLiteral(e) {
  const t = this.getPossibleRaw(e);
  if (!this.format.minified && t !== void 0) {
    this.token(t);
    return;
  }
  const {
    value: s
  } = e;
  if (!unescapedDoubleQuoteRE.test(s))
    this.token(`"${s}"`);
  else if (!unescapedSingleQuoteRE.test(s))
    this.token(`'${s}'`);
  else
    throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
}
function InterpreterDirective(e) {
  this.token(`#!${e.value}`), this.newline(1, !0);
}
function Placeholder(e) {
  this.token("%%"), this.print(e.name), this.token("%%"), e.expectedNode === "Statement" && this.semicolon();
}
var jsx$1 = {};
Object.defineProperty(jsx$1, "__esModule", {
  value: !0
});
jsx$1.JSXAttribute = JSXAttribute;
jsx$1.JSXClosingElement = JSXClosingElement;
jsx$1.JSXClosingFragment = JSXClosingFragment;
jsx$1.JSXElement = JSXElement;
jsx$1.JSXEmptyExpression = JSXEmptyExpression;
jsx$1.JSXExpressionContainer = JSXExpressionContainer;
jsx$1.JSXFragment = JSXFragment;
jsx$1.JSXIdentifier = JSXIdentifier;
jsx$1.JSXMemberExpression = JSXMemberExpression;
jsx$1.JSXNamespacedName = JSXNamespacedName;
jsx$1.JSXOpeningElement = JSXOpeningElement;
jsx$1.JSXOpeningFragment = JSXOpeningFragment;
jsx$1.JSXSpreadAttribute = JSXSpreadAttribute;
jsx$1.JSXSpreadChild = JSXSpreadChild;
jsx$1.JSXText = JSXText;
function JSXAttribute(e) {
  this.print(e.name, e), e.value && (this.tokenChar(61), this.print(e.value, e));
}
function JSXIdentifier(e) {
  this.word(e.name);
}
function JSXNamespacedName(e) {
  this.print(e.namespace, e), this.tokenChar(58), this.print(e.name, e);
}
function JSXMemberExpression(e) {
  this.print(e.object, e), this.tokenChar(46), this.print(e.property, e);
}
function JSXSpreadAttribute(e) {
  this.tokenChar(123), this.token("..."), this.print(e.argument, e), this.tokenChar(125);
}
function JSXExpressionContainer(e) {
  this.tokenChar(123), this.print(e.expression, e), this.tokenChar(125);
}
function JSXSpreadChild(e) {
  this.tokenChar(123), this.token("..."), this.print(e.expression, e), this.tokenChar(125);
}
function JSXText(e) {
  const t = this.getPossibleRaw(e);
  t !== void 0 ? this.token(t, !0) : this.token(e.value, !0);
}
function JSXElement(e) {
  const t = e.openingElement;
  if (this.print(t, e), !t.selfClosing) {
    this.indent();
    for (const s of e.children)
      this.print(s, e);
    this.dedent(), this.print(e.closingElement, e);
  }
}
function spaceSeparator() {
  this.space();
}
function JSXOpeningElement(e) {
  this.tokenChar(60), this.print(e.name, e), this.print(e.typeParameters, e), e.attributes.length > 0 && (this.space(), this.printJoin(e.attributes, e, {
    separator: spaceSeparator
  })), e.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
}
function JSXClosingElement(e) {
  this.token("</"), this.print(e.name, e), this.tokenChar(62);
}
function JSXEmptyExpression() {
  this.printInnerComments();
}
function JSXFragment(e) {
  this.print(e.openingFragment, e), this.indent();
  for (const t of e.children)
    this.print(t, e);
  this.dedent(), this.print(e.closingFragment, e);
}
function JSXOpeningFragment() {
  this.tokenChar(60), this.tokenChar(62);
}
function JSXClosingFragment() {
  this.token("</"), this.tokenChar(62);
}
var typescript$2 = {};
Object.defineProperty(typescript$2, "__esModule", {
  value: !0
});
typescript$2.TSAnyKeyword = TSAnyKeyword;
typescript$2.TSArrayType = TSArrayType;
typescript$2.TSSatisfiesExpression = typescript$2.TSAsExpression = TSTypeExpression;
typescript$2.TSBigIntKeyword = TSBigIntKeyword;
typescript$2.TSBooleanKeyword = TSBooleanKeyword;
typescript$2.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
typescript$2.TSConditionalType = TSConditionalType;
typescript$2.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
typescript$2.TSConstructorType = TSConstructorType;
typescript$2.TSDeclareFunction = TSDeclareFunction;
typescript$2.TSDeclareMethod = TSDeclareMethod;
typescript$2.TSEnumDeclaration = TSEnumDeclaration;
typescript$2.TSEnumMember = TSEnumMember;
typescript$2.TSExportAssignment = TSExportAssignment;
typescript$2.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;
typescript$2.TSExternalModuleReference = TSExternalModuleReference;
typescript$2.TSFunctionType = TSFunctionType;
typescript$2.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
typescript$2.TSImportType = TSImportType;
typescript$2.TSIndexSignature = TSIndexSignature;
typescript$2.TSIndexedAccessType = TSIndexedAccessType;
typescript$2.TSInferType = TSInferType;
typescript$2.TSInstantiationExpression = TSInstantiationExpression;
typescript$2.TSInterfaceBody = TSInterfaceBody;
typescript$2.TSInterfaceDeclaration = TSInterfaceDeclaration;
typescript$2.TSIntersectionType = TSIntersectionType;
typescript$2.TSIntrinsicKeyword = TSIntrinsicKeyword;
typescript$2.TSLiteralType = TSLiteralType;
typescript$2.TSMappedType = TSMappedType;
typescript$2.TSMethodSignature = TSMethodSignature;
typescript$2.TSModuleBlock = TSModuleBlock;
typescript$2.TSModuleDeclaration = TSModuleDeclaration;
typescript$2.TSNamedTupleMember = TSNamedTupleMember;
typescript$2.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
typescript$2.TSNeverKeyword = TSNeverKeyword;
typescript$2.TSNonNullExpression = TSNonNullExpression;
typescript$2.TSNullKeyword = TSNullKeyword;
typescript$2.TSNumberKeyword = TSNumberKeyword;
typescript$2.TSObjectKeyword = TSObjectKeyword;
typescript$2.TSOptionalType = TSOptionalType;
typescript$2.TSParameterProperty = TSParameterProperty;
typescript$2.TSParenthesizedType = TSParenthesizedType;
typescript$2.TSPropertySignature = TSPropertySignature;
typescript$2.TSQualifiedName = TSQualifiedName;
typescript$2.TSRestType = TSRestType;
typescript$2.TSStringKeyword = TSStringKeyword;
typescript$2.TSSymbolKeyword = TSSymbolKeyword;
typescript$2.TSThisType = TSThisType;
typescript$2.TSTupleType = TSTupleType;
typescript$2.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
typescript$2.TSTypeAnnotation = TSTypeAnnotation;
typescript$2.TSTypeAssertion = TSTypeAssertion;
typescript$2.TSTypeLiteral = TSTypeLiteral;
typescript$2.TSTypeOperator = TSTypeOperator;
typescript$2.TSTypeParameter = TSTypeParameter;
typescript$2.TSTypeParameterDeclaration = typescript$2.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
typescript$2.TSTypePredicate = TSTypePredicate;
typescript$2.TSTypeQuery = TSTypeQuery;
typescript$2.TSTypeReference = TSTypeReference;
typescript$2.TSUndefinedKeyword = TSUndefinedKeyword;
typescript$2.TSUnionType = TSUnionType;
typescript$2.TSUnknownKeyword = TSUnknownKeyword;
typescript$2.TSVoidKeyword = TSVoidKeyword;
typescript$2.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
typescript$2.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
typescript$2.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
typescript$2.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
typescript$2.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;
function TSTypeAnnotation(e) {
  this.tokenChar(58), this.space(), e.optional && this.tokenChar(63), this.print(e.typeAnnotation, e);
}
function TSTypeParameterInstantiation(e, t) {
  this.tokenChar(60), this.printList(e.params, e, {}), t.type === "ArrowFunctionExpression" && e.params.length === 1 && this.tokenChar(44), this.tokenChar(62);
}
function TSTypeParameter(e) {
  e.in && (this.word("in"), this.space()), e.out && (this.word("out"), this.space()), this.word(e.name), e.constraint && (this.space(), this.word("extends"), this.space(), this.print(e.constraint, e)), e.default && (this.space(), this.tokenChar(61), this.space(), this.print(e.default, e));
}
function TSParameterProperty(e) {
  e.accessibility && (this.word(e.accessibility), this.space()), e.readonly && (this.word("readonly"), this.space()), this._param(e.parameter);
}
function TSDeclareFunction(e, t) {
  e.declare && (this.word("declare"), this.space()), this._functionHead(e, t), this.tokenChar(59);
}
function TSDeclareMethod(e) {
  this._classMethodHead(e), this.tokenChar(59);
}
function TSQualifiedName(e) {
  this.print(e.left, e), this.tokenChar(46), this.print(e.right, e);
}
function TSCallSignatureDeclaration(e) {
  this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
}
function TSConstructSignatureDeclaration(e) {
  this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
}
function TSPropertySignature(e) {
  const {
    readonly: t,
    initializer: s
  } = e;
  t && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e), this.print(e.typeAnnotation, e), s && (this.space(), this.tokenChar(61), this.space(), this.print(s, e)), this.tokenChar(59);
}
function tsPrintPropertyOrMethodName(e) {
  e.computed && this.tokenChar(91), this.print(e.key, e), e.computed && this.tokenChar(93), e.optional && this.tokenChar(63);
}
function TSMethodSignature(e) {
  const {
    kind: t
  } = e;
  (t === "set" || t === "get") && (this.word(t), this.space()), this.tsPrintPropertyOrMethodName(e), this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
}
function TSIndexSignature(e) {
  const {
    readonly: t,
    static: s
  } = e;
  s && (this.word("static"), this.space()), t && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(e.parameters, e), this.tokenChar(93), this.print(e.typeAnnotation, e), this.tokenChar(59);
}
function TSAnyKeyword() {
  this.word("any");
}
function TSBigIntKeyword() {
  this.word("bigint");
}
function TSUnknownKeyword() {
  this.word("unknown");
}
function TSNumberKeyword() {
  this.word("number");
}
function TSObjectKeyword() {
  this.word("object");
}
function TSBooleanKeyword() {
  this.word("boolean");
}
function TSStringKeyword() {
  this.word("string");
}
function TSSymbolKeyword() {
  this.word("symbol");
}
function TSVoidKeyword() {
  this.word("void");
}
function TSUndefinedKeyword() {
  this.word("undefined");
}
function TSNullKeyword() {
  this.word("null");
}
function TSNeverKeyword() {
  this.word("never");
}
function TSIntrinsicKeyword() {
  this.word("intrinsic");
}
function TSThisType() {
  this.word("this");
}
function TSFunctionType(e) {
  this.tsPrintFunctionOrConstructorType(e);
}
function TSConstructorType(e) {
  e.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e);
}
function tsPrintFunctionOrConstructorType(e) {
  const {
    typeParameters: t
  } = e, s = e.parameters;
  this.print(t, e), this.tokenChar(40), this._parameters(s, e), this.tokenChar(41), this.space(), this.token("=>"), this.space();
  const i = e.typeAnnotation;
  this.print(i.typeAnnotation, e);
}
function TSTypeReference(e) {
  this.print(e.typeName, e, !0), this.print(e.typeParameters, e, !0);
}
function TSTypePredicate(e) {
  e.asserts && (this.word("asserts"), this.space()), this.print(e.parameterName), e.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(e.typeAnnotation.typeAnnotation));
}
function TSTypeQuery(e) {
  this.word("typeof"), this.space(), this.print(e.exprName), e.typeParameters && this.print(e.typeParameters, e);
}
function TSTypeLiteral(e) {
  this.tsPrintTypeLiteralOrInterfaceBody(e.members, e);
}
function tsPrintTypeLiteralOrInterfaceBody(e, t) {
  tsPrintBraced(this, e, t);
}
function tsPrintBraced(e, t, s) {
  if (e.token("{"), t.length) {
    e.indent(), e.newline();
    for (const i of t)
      e.print(i, s), e.newline();
    e.dedent();
  }
  e.rightBrace(s);
}
function TSArrayType(e) {
  this.print(e.elementType, e, !0), this.token("[]");
}
function TSTupleType(e) {
  this.tokenChar(91), this.printList(e.elementTypes, e), this.tokenChar(93);
}
function TSOptionalType(e) {
  this.print(e.typeAnnotation, e), this.tokenChar(63);
}
function TSRestType(e) {
  this.token("..."), this.print(e.typeAnnotation, e);
}
function TSNamedTupleMember(e) {
  this.print(e.label, e), e.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(e.elementType, e);
}
function TSUnionType(e) {
  tsPrintUnionOrIntersectionType(this, e, "|");
}
function TSIntersectionType(e) {
  tsPrintUnionOrIntersectionType(this, e, "&");
}
function tsPrintUnionOrIntersectionType(e, t, s) {
  e.printJoin(t.types, t, {
    separator() {
      this.space(), this.token(s), this.space();
    }
  });
}
function TSConditionalType(e) {
  this.print(e.checkType), this.space(), this.word("extends"), this.space(), this.print(e.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(e.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e.falseType);
}
function TSInferType(e) {
  this.token("infer"), this.space(), this.print(e.typeParameter);
}
function TSParenthesizedType(e) {
  this.tokenChar(40), this.print(e.typeAnnotation, e), this.tokenChar(41);
}
function TSTypeOperator(e) {
  this.word(e.operator), this.space(), this.print(e.typeAnnotation, e);
}
function TSIndexedAccessType(e) {
  this.print(e.objectType, e, !0), this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
}
function TSMappedType(e) {
  const {
    nameType: t,
    optional: s,
    readonly: i,
    typeParameter: a
  } = e;
  this.tokenChar(123), this.space(), i && (tokenIfPlusMinus(this, i), this.word("readonly"), this.space()), this.tokenChar(91), this.word(a.name), this.space(), this.word("in"), this.space(), this.print(a.constraint, a), t && (this.space(), this.word("as"), this.space(), this.print(t, e)), this.tokenChar(93), s && (tokenIfPlusMinus(this, s), this.tokenChar(63)), this.tokenChar(58), this.space(), this.print(e.typeAnnotation, e), this.space(), this.tokenChar(125);
}
function tokenIfPlusMinus(e, t) {
  t !== !0 && e.token(t);
}
function TSLiteralType(e) {
  this.print(e.literal, e);
}
function TSExpressionWithTypeArguments(e) {
  this.print(e.expression, e), this.print(e.typeParameters, e);
}
function TSInterfaceDeclaration(e) {
  const {
    declare: t,
    id: s,
    typeParameters: i,
    extends: a,
    body: o
  } = e;
  t && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(s, e), this.print(i, e), a != null && a.length && (this.space(), this.word("extends"), this.space(), this.printList(a, e)), this.space(), this.print(o, e);
}
function TSInterfaceBody(e) {
  this.tsPrintTypeLiteralOrInterfaceBody(e.body, e);
}
function TSTypeAliasDeclaration(e) {
  const {
    declare: t,
    id: s,
    typeParameters: i,
    typeAnnotation: a
  } = e;
  t && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(s, e), this.print(i, e), this.space(), this.tokenChar(61), this.space(), this.print(a, e), this.tokenChar(59);
}
function TSTypeExpression(e) {
  var t;
  const {
    type: s,
    expression: i,
    typeAnnotation: a
  } = e, o = !!((t = i.trailingComments) != null && t.length);
  this.print(i, e, !0, void 0, o), this.space(), this.word(s === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(a, e);
}
function TSTypeAssertion(e) {
  const {
    typeAnnotation: t,
    expression: s
  } = e;
  this.tokenChar(60), this.print(t, e), this.tokenChar(62), this.space(), this.print(s, e);
}
function TSInstantiationExpression(e) {
  this.print(e.expression, e), this.print(e.typeParameters, e);
}
function TSEnumDeclaration(e) {
  const {
    declare: t,
    const: s,
    id: i,
    members: a
  } = e;
  t && (this.word("declare"), this.space()), s && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(i, e), this.space(), tsPrintBraced(this, a, e);
}
function TSEnumMember(e) {
  const {
    id: t,
    initializer: s
  } = e;
  this.print(t, e), s && (this.space(), this.tokenChar(61), this.space(), this.print(s, e)), this.tokenChar(44);
}
function TSModuleDeclaration(e) {
  const {
    declare: t,
    id: s
  } = e;
  if (t && (this.word("declare"), this.space()), e.global || (this.word(s.type === "Identifier" ? "namespace" : "module"), this.space()), this.print(s, e), !e.body) {
    this.tokenChar(59);
    return;
  }
  let i = e.body;
  for (; i.type === "TSModuleDeclaration"; )
    this.tokenChar(46), this.print(i.id, i), i = i.body;
  this.space(), this.print(i, e);
}
function TSModuleBlock(e) {
  tsPrintBraced(this, e.body, e);
}
function TSImportType(e) {
  const {
    argument: t,
    qualifier: s,
    typeParameters: i
  } = e;
  this.word("import"), this.tokenChar(40), this.print(t, e), this.tokenChar(41), s && (this.tokenChar(46), this.print(s, e)), i && this.print(i, e);
}
function TSImportEqualsDeclaration(e) {
  const {
    isExport: t,
    id: s,
    moduleReference: i
  } = e;
  t && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(s, e), this.space(), this.tokenChar(61), this.space(), this.print(i, e), this.tokenChar(59);
}
function TSExternalModuleReference(e) {
  this.token("require("), this.print(e.expression, e), this.tokenChar(41);
}
function TSNonNullExpression(e) {
  this.print(e.expression, e), this.tokenChar(33);
}
function TSExportAssignment(e) {
  this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e.expression, e), this.tokenChar(59);
}
function TSNamespaceExportDeclaration(e) {
  this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e.id, e);
}
function tsPrintSignatureDeclarationBase(e) {
  const {
    typeParameters: t
  } = e, s = e.parameters;
  this.print(t, e), this.tokenChar(40), this._parameters(s, e), this.tokenChar(41);
  const i = e.typeAnnotation;
  this.print(i, e);
}
function tsPrintClassMemberModifiers(e) {
  const t = e.type === "ClassAccessorProperty" || e.type === "ClassProperty";
  t && e.declare && (this.word("declare"), this.space()), e.accessibility && (this.word(e.accessibility), this.space()), e.static && (this.word("static"), this.space()), e.override && (this.word("override"), this.space()), e.abstract && (this.word("abstract"), this.space()), t && e.readonly && (this.word("readonly"), this.space());
}
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  });
  var t = templateLiterals;
  Object.keys(t).forEach(function(b) {
    b === "default" || b === "__esModule" || b in e && e[b] === t[b] || Object.defineProperty(e, b, {
      enumerable: !0,
      get: function() {
        return t[b];
      }
    });
  });
  var s = expressions;
  Object.keys(s).forEach(function(b) {
    b === "default" || b === "__esModule" || b in e && e[b] === s[b] || Object.defineProperty(e, b, {
      enumerable: !0,
      get: function() {
        return s[b];
      }
    });
  });
  var i = statements$2;
  Object.keys(i).forEach(function(b) {
    b === "default" || b === "__esModule" || b in e && e[b] === i[b] || Object.defineProperty(e, b, {
      enumerable: !0,
      get: function() {
        return i[b];
      }
    });
  });
  var a = classes;
  Object.keys(a).forEach(function(b) {
    b === "default" || b === "__esModule" || b in e && e[b] === a[b] || Object.defineProperty(e, b, {
      enumerable: !0,
      get: function() {
        return a[b];
      }
    });
  });
  var o = methods;
  Object.keys(o).forEach(function(b) {
    b === "default" || b === "__esModule" || b in e && e[b] === o[b] || Object.defineProperty(e, b, {
      enumerable: !0,
      get: function() {
        return o[b];
      }
    });
  });
  var l = modules;
  Object.keys(l).forEach(function(b) {
    b === "default" || b === "__esModule" || b in e && e[b] === l[b] || Object.defineProperty(e, b, {
      enumerable: !0,
      get: function() {
        return l[b];
      }
    });
  });
  var f = types$1;
  Object.keys(f).forEach(function(b) {
    b === "default" || b === "__esModule" || b in e && e[b] === f[b] || Object.defineProperty(e, b, {
      enumerable: !0,
      get: function() {
        return f[b];
      }
    });
  });
  var y = flow$1;
  Object.keys(y).forEach(function(b) {
    b === "default" || b === "__esModule" || b in e && e[b] === y[b] || Object.defineProperty(e, b, {
      enumerable: !0,
      get: function() {
        return y[b];
      }
    });
  });
  var g = base;
  Object.keys(g).forEach(function(b) {
    b === "default" || b === "__esModule" || b in e && e[b] === g[b] || Object.defineProperty(e, b, {
      enumerable: !0,
      get: function() {
        return g[b];
      }
    });
  });
  var T = jsx$1;
  Object.keys(T).forEach(function(b) {
    b === "default" || b === "__esModule" || b in e && e[b] === T[b] || Object.defineProperty(e, b, {
      enumerable: !0,
      get: function() {
        return T[b];
      }
    });
  });
  var S = typescript$2;
  Object.keys(S).forEach(function(b) {
    b === "default" || b === "__esModule" || b in e && e[b] === S[b] || Object.defineProperty(e, b, {
      enumerable: !0,
      get: function() {
        return S[b];
      }
    });
  });
})(generators);
Object.defineProperty(printer, "__esModule", {
  value: !0
});
printer.default = void 0;
var _buffer = buffer, n = node, _t$d = requireLib$1(), generatorFunctions = generators;
const {
  isFunction: isFunction$2,
  isStatement: isStatement$2,
  isClassBody,
  isTSInterfaceBody,
  isTSEnumDeclaration
} = _t$d, SCIENTIFIC_NOTATION = /e/i, ZERO_DECIMAL_INTEGER = /\.0+$/, HAS_NEWLINE = /[\n\r\u2028\u2029]/, HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//, {
  needsParens
} = n;
class Printer {
  constructor(t, s) {
    this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._indentRepeat = 0, this._insideAux = !1, this._parenPushNewlineState = null, this._noLineTerminator = !1, this._printAuxAfterOnNextUserNode = !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = !1, this._endsWithWord = !1, this._lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.format = t, this._indentRepeat = t.indent.style.length, this._inputMap = s == null ? void 0 : s._inputMap, this._buf = new _buffer.default(s, t.indent.style[0]);
  }
  generate(t) {
    return this.print(t), this._maybeAddAuxComment(), this._buf.get();
  }
  indent() {
    this.format.compact || this.format.concise || this._indent++;
  }
  dedent() {
    this.format.compact || this.format.concise || this._indent--;
  }
  semicolon(t = !1) {
    this._maybeAddAuxComment(), t ? this._appendChar(59) : this._queue(59), this._noLineTerminator = !1;
  }
  rightBrace(t) {
    this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
  }
  rightParens(t) {
    this.sourceWithOffset("end", t.loc, -1), this.tokenChar(41);
  }
  space(t = !1) {
    if (!this.format.compact) {
      if (t)
        this._space();
      else if (this._buf.hasContent()) {
        const s = this.getLastChar();
        s !== 32 && s !== 10 && this._space();
      }
    }
  }
  word(t, s = !1) {
    this._maybePrintInnerComments(), (this._endsWithWord || t.charCodeAt(0) === 47 && this.endsWith(47)) && this._space(), this._maybeAddAuxComment(), this._append(t, !1), this._endsWithWord = !0, this._noLineTerminator = s;
  }
  number(t, s) {
    function i(a) {
      if (a.length > 2 && a.charCodeAt(0) === 48) {
        const o = a.charCodeAt(1);
        return o === 98 || o === 111 || o === 120;
      }
      return !1;
    }
    this.word(t), this._endsWithInteger = Number.isInteger(s) && !i(t) && !SCIENTIFIC_NOTATION.test(t) && !ZERO_DECIMAL_INTEGER.test(t) && t.charCodeAt(t.length - 1) !== 46;
  }
  token(t, s = !1) {
    this._maybePrintInnerComments();
    const i = this.getLastChar(), a = t.charCodeAt(0);
    (i === 33 && (t === "--" || a === 61) || a === 43 && i === 43 || a === 45 && i === 45 || a === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._append(t, s), this._noLineTerminator = !1;
  }
  tokenChar(t) {
    this._maybePrintInnerComments();
    const s = this.getLastChar();
    (t === 43 && s === 43 || t === 45 && s === 45 || t === 46 && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._appendChar(t), this._noLineTerminator = !1;
  }
  newline(t = 1, s) {
    if (!(t <= 0)) {
      if (!s) {
        if (this.format.retainLines || this.format.compact)
          return;
        if (this.format.concise) {
          this.space();
          return;
        }
      }
      t > 2 && (t = 2), t -= this._buf.getNewlineCount();
      for (let i = 0; i < t; i++)
        this._newline();
    }
  }
  endsWith(t) {
    return this.getLastChar() === t;
  }
  getLastChar() {
    return this._buf.getLastChar();
  }
  endsWithCharAndNewline() {
    return this._buf.endsWithCharAndNewline();
  }
  removeTrailingNewline() {
    this._buf.removeTrailingNewline();
  }
  exactSource(t, s) {
    if (!t) {
      s();
      return;
    }
    this._catchUp("start", t), this._buf.exactSource(t, s);
  }
  source(t, s) {
    s && (this._catchUp(t, s), this._buf.source(t, s));
  }
  sourceWithOffset(t, s, i) {
    s && (this._catchUp(t, s), this._buf.sourceWithOffset(t, s, i));
  }
  withSource(t, s, i) {
    if (!s) {
      i();
      return;
    }
    this._catchUp(t, s), this._buf.withSource(t, s, i);
  }
  sourceIdentifierName(t, s) {
    if (!this._buf._canMarkIdName)
      return;
    const i = this._buf._sourcePosition;
    i.identifierNamePos = s, i.identifierName = t;
  }
  _space() {
    this._queue(32);
  }
  _newline() {
    this._queue(10);
  }
  _append(t, s) {
    this._maybeAddParen(t), this._maybeIndent(t.charCodeAt(0)), this._buf.append(t, s), this._endsWithWord = !1, this._endsWithInteger = !1;
  }
  _appendChar(t) {
    this._maybeAddParenChar(t), this._maybeIndent(t), this._buf.appendChar(t), this._endsWithWord = !1, this._endsWithInteger = !1;
  }
  _queue(t) {
    this._maybeAddParenChar(t), this._maybeIndent(t), this._buf.queue(t), this._endsWithWord = !1, this._endsWithInteger = !1;
  }
  _maybeIndent(t) {
    this._indent && t !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
  }
  _shouldIndent(t) {
    if (this._indent && t !== 10 && this.endsWith(10))
      return !0;
  }
  _maybeAddParenChar(t) {
    const s = this._parenPushNewlineState;
    if (s && t !== 32) {
      if (t !== 10) {
        this._parenPushNewlineState = null;
        return;
      }
      this.tokenChar(40), this.indent(), s.printed = !0;
    }
  }
  _maybeAddParen(t) {
    const s = this._parenPushNewlineState;
    if (!s)
      return;
    const i = t.length;
    let a;
    for (a = 0; a < i && t.charCodeAt(a) === 32; a++)
      ;
    if (a === i)
      return;
    const o = t.charCodeAt(a);
    if (o !== 10) {
      if (o !== 47 || a + 1 === i) {
        this._parenPushNewlineState = null;
        return;
      }
      const l = t.charCodeAt(a + 1);
      if (l === 42)
        return;
      if (l !== 47) {
        this._parenPushNewlineState = null;
        return;
      }
    }
    this.tokenChar(40), this.indent(), s.printed = !0;
  }
  catchUp(t) {
    if (!this.format.retainLines)
      return;
    const s = t - this._buf.getCurrentLine();
    for (let i = 0; i < s; i++)
      this._newline();
  }
  _catchUp(t, s) {
    var i;
    if (!this.format.retainLines)
      return;
    const a = s == null || (i = s[t]) == null ? void 0 : i.line;
    if (a != null) {
      const o = a - this._buf.getCurrentLine();
      for (let l = 0; l < o; l++)
        this._newline();
    }
  }
  _getIndent() {
    return this._indentRepeat * this._indent;
  }
  printTerminatorless(t, s, i) {
    if (i)
      this._noLineTerminator = !0, this.print(t, s);
    else {
      const a = {
        printed: !1
      };
      this._parenPushNewlineState = a, this.print(t, s), a.printed && (this.dedent(), this.newline(), this.tokenChar(41));
    }
  }
  print(t, s, i, a, o) {
    var l, f;
    if (!t)
      return;
    this._endsWithInnerRaw = !1;
    const y = t.type, g = this.format, T = g.concise;
    t._compact && (g.concise = !0);
    const S = this[y];
    if (S === void 0)
      throw new ReferenceError(`unknown node of type ${JSON.stringify(y)} with constructor ${JSON.stringify(t.constructor.name)}`);
    this._printStack.push(t);
    const b = this._insideAux;
    this._insideAux = t.loc == null, this._maybeAddAuxComment(this._insideAux && !b);
    const v = (l = t.extra) == null ? void 0 : l.parenthesized;
    let $ = o || v && g.retainFunctionParens && y === "FunctionExpression" || needsParens(t, s, this._printStack);
    if (!$ && v && (f = t.leadingComments) != null && f.length && t.leadingComments[0].type === "CommentBlock")
      switch (s == null ? void 0 : s.type) {
        case "ExpressionStatement":
        case "VariableDeclarator":
        case "AssignmentExpression":
        case "ReturnStatement":
          break;
        case "CallExpression":
        case "OptionalCallExpression":
        case "NewExpression":
          if (s.callee !== t)
            break;
        default:
          $ = !0;
      }
    $ && (this.tokenChar(40), this._endsWithInnerRaw = !1), this._lastCommentLine = 0, this._printLeadingComments(t, s);
    const U = y === "Program" || y === "File" ? null : t.loc;
    this.exactSource(U, S.bind(this, t, s)), $ ? (this._printTrailingComments(t, s), this.tokenChar(41), this._noLineTerminator = i) : i && !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(t, s)) : this._printTrailingComments(t, s, a), this._printStack.pop(), g.concise = T, this._insideAux = b, this._endsWithInnerRaw = !1;
  }
  _maybeAddAuxComment(t) {
    t && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
  }
  _printAuxBeforeComment() {
    if (this._printAuxAfterOnNextUserNode)
      return;
    this._printAuxAfterOnNextUserNode = !0;
    const t = this.format.auxiliaryCommentBefore;
    t && this._printComment({
      type: "CommentBlock",
      value: t
    }, 0);
  }
  _printAuxAfterComment() {
    if (!this._printAuxAfterOnNextUserNode)
      return;
    this._printAuxAfterOnNextUserNode = !1;
    const t = this.format.auxiliaryCommentAfter;
    t && this._printComment({
      type: "CommentBlock",
      value: t
    }, 0);
  }
  getPossibleRaw(t) {
    const s = t.extra;
    if ((s == null ? void 0 : s.raw) != null && s.rawValue != null && t.value === s.rawValue)
      return s.raw;
  }
  printJoin(t, s, i = {}) {
    if (!(t != null && t.length))
      return;
    let {
      indent: a
    } = i;
    if (a == null && this.format.retainLines) {
      var o;
      const S = (o = t[0].loc) == null ? void 0 : o.start.line;
      S != null && S !== this._buf.getCurrentLine() && (a = !0);
    }
    a && this.indent();
    const l = {
      addNewlines: i.addNewlines,
      nextNodeStartLine: 0
    }, f = i.separator ? i.separator.bind(this) : null, y = t.length;
    for (let S = 0; S < y; S++) {
      const b = t[S];
      if (b && (i.statement && this._printNewline(S === 0, l), this.print(b, s, void 0, i.trailingCommentsLineOffset || 0), i.iterator == null || i.iterator(b, S), S < y - 1 && (f == null || f()), i.statement)) {
        var g;
        if ((g = b.trailingComments) != null && g.length || (this._lastCommentLine = 0), S + 1 === y)
          this.newline(1);
        else {
          var T;
          const v = t[S + 1];
          l.nextNodeStartLine = ((T = v.loc) == null ? void 0 : T.start.line) || 0, this._printNewline(!0, l);
        }
      }
    }
    a && this.dedent();
  }
  printAndIndentOnComments(t, s) {
    const i = t.leadingComments && t.leadingComments.length > 0;
    i && this.indent(), this.print(t, s), i && this.dedent();
  }
  printBlock(t) {
    const s = t.body;
    s.type !== "EmptyStatement" && this.space(), this.print(s, t);
  }
  _printTrailingComments(t, s, i) {
    const {
      innerComments: a,
      trailingComments: o
    } = t;
    a != null && a.length && this._printComments(2, a, t, s, i), o != null && o.length && this._printComments(2, o, t, s, i);
  }
  _printLeadingComments(t, s) {
    const i = t.leadingComments;
    i != null && i.length && this._printComments(0, i, t, s);
  }
  _maybePrintInnerComments() {
    this._endsWithInnerRaw && this.printInnerComments(), this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
  }
  printInnerComments() {
    const t = this._printStack[this._printStack.length - 1], s = t.innerComments;
    if (!(s != null && s.length))
      return;
    const i = this.endsWith(32), a = this._indentInnerComments, o = this._printedComments.size;
    a && this.indent(), this._printComments(1, s, t), i && o !== this._printedComments.size && this.space(), a && this.dedent();
  }
  noIndentInnerCommentsHere() {
    this._indentInnerComments = !1;
  }
  printSequence(t, s, i = {}) {
    var a;
    i.statement = !0, (a = i.indent) != null || (i.indent = !1), this.printJoin(t, s, i);
  }
  printList(t, s, i = {}) {
    i.separator == null && (i.separator = commaSeparator), this.printJoin(t, s, i);
  }
  _printNewline(t, s) {
    const i = this.format;
    if (i.retainLines || i.compact)
      return;
    if (i.concise) {
      this.space();
      return;
    }
    if (!t)
      return;
    const a = s.nextNodeStartLine, o = this._lastCommentLine;
    if (a > 0 && o > 0) {
      const l = a - o;
      if (l >= 0) {
        this.newline(l || 1);
        return;
      }
    }
    this._buf.hasContent() && this.newline(1);
  }
  _shouldPrintComment(t) {
    return t.ignore || this._printedComments.has(t) ? 0 : this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(t.value) ? 2 : (this._printedComments.add(t), this.format.shouldPrintComment(t.value) ? 1 : 0);
  }
  _printComment(t, s) {
    const i = this._noLineTerminator, a = t.type === "CommentBlock", o = a && s !== 1 && !this._noLineTerminator;
    o && this._buf.hasContent() && s !== 2 && this.newline(1);
    const l = this.getLastChar();
    l !== 91 && l !== 123 && this.space();
    let f;
    if (a) {
      const {
        _parenPushNewlineState: g
      } = this;
      if ((g == null ? void 0 : g.printed) === !1 && HAS_NEWLINE.test(t.value) && (this.tokenChar(40), g.printed = !0), f = `/*${t.value}*/`, this.format.indent.adjustMultilineComment) {
        var y;
        const T = (y = t.loc) == null ? void 0 : y.start.column;
        if (T) {
          const S = new RegExp("\\n\\s{1," + T + "}", "g");
          f = f.replace(S, `
`);
        }
        if (this.format.concise)
          f = f.replace(/\n(?!$)/g, `
`);
        else {
          let S = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
          (this._shouldIndent(47) || this.format.retainLines) && (S += this._getIndent()), f = f.replace(/\n(?!$)/g, `
${" ".repeat(S)}`);
        }
      }
    } else
      i ? f = `/*${t.value}*/` : f = `//${t.value}`;
    this.endsWith(47) && this._space(), this.source("start", t.loc), this._append(f, a), !a && !i && this.newline(1, !0), o && s !== 3 && this.newline(1);
  }
  _printComments(t, s, i, a, o = 0) {
    const l = i.loc, f = s.length;
    let y = !!l;
    const g = y ? l.start.line : 0, T = y ? l.end.line : 0;
    let S = 0, b = 0;
    const v = this._noLineTerminator ? function() {
    } : this.newline.bind(this);
    for (let $ = 0; $ < f; $++) {
      const U = s[$], X = this._shouldPrintComment(U);
      if (X === 2) {
        y = !1;
        break;
      }
      if (y && U.loc && X === 1) {
        const k = U.loc.start.line, D = U.loc.end.line;
        if (t === 0) {
          let B = 0;
          $ === 0 ? this._buf.hasContent() && (U.type === "CommentLine" || k != D) && (B = b = 1) : B = k - S, S = D, v(B), this._printComment(U, 1), $ + 1 === f && (v(Math.max(g - S, b)), S = g);
        } else if (t === 1) {
          const B = k - ($ === 0 ? g : S);
          S = D, v(B), this._printComment(U, 1), $ + 1 === f && (v(Math.min(1, T - S)), S = T);
        } else {
          const B = k - ($ === 0 ? T - o : S);
          S = D, v(B), this._printComment(U, 1);
        }
      } else {
        if (y = !1, X !== 1)
          continue;
        if (f === 1) {
          const k = U.loc ? U.loc.start.line === U.loc.end.line : !HAS_NEWLINE.test(U.value), D = k && !isStatement$2(i) && !isClassBody(a) && !isTSInterfaceBody(a) && !isTSEnumDeclaration(a);
          t === 0 ? this._printComment(U, D && i.type !== "ObjectExpression" || k && isFunction$2(a, {
            body: i
          }) ? 1 : 0) : D && t === 2 ? this._printComment(U, 1) : this._printComment(U, 0);
        } else
          t === 1 && !(i.type === "ObjectExpression" && i.properties.length > 1) && i.type !== "ClassBody" && i.type !== "TSInterfaceBody" ? this._printComment(U, $ === 0 ? 2 : $ === f - 1 ? 3 : 0) : this._printComment(U, 0);
      }
    }
    t === 2 && y && S && (this._lastCommentLine = S);
  }
}
Object.assign(Printer.prototype, generatorFunctions);
Printer.prototype.Noop = function() {
};
printer.default = Printer;
function commaSeparator() {
  this.tokenChar(44), this.space();
}
Object.defineProperty(lib$6, "__esModule", {
  value: !0
});
lib$6.CodeGenerator = void 0;
var _default$4 = lib$6.default = generate, _sourceMap = sourceMap, _printer = printer;
class Generator extends _printer.default {
  constructor(t, s = {}, i) {
    const a = normalizeOptions(i, s), o = s.sourceMaps ? new _sourceMap.default(s, i) : null;
    super(a, o), this.ast = void 0, this.ast = t;
  }
  generate() {
    return super.generate(this.ast);
  }
}
function normalizeOptions(e, t) {
  var s;
  const i = {
    auxiliaryCommentBefore: t.auxiliaryCommentBefore,
    auxiliaryCommentAfter: t.auxiliaryCommentAfter,
    shouldPrintComment: t.shouldPrintComment,
    retainLines: t.retainLines,
    retainFunctionParens: t.retainFunctionParens,
    comments: t.comments == null || t.comments,
    compact: t.compact,
    minified: t.minified,
    concise: t.concise,
    indent: {
      adjustMultilineComment: !0,
      style: "  "
    },
    jsescOption: Object.assign({
      quotes: "double",
      wrap: !0,
      minimal: !1
    }, t.jsescOption),
    recordAndTupleSyntaxType: (s = t.recordAndTupleSyntaxType) != null ? s : "hash",
    topicToken: t.topicToken,
    importAttributesKeyword: t.importAttributesKeyword
  };
  i.decoratorsBeforeExport = t.decoratorsBeforeExport, i.jsescOption.json = t.jsonCompatibleStrings, i.minified ? (i.compact = !0, i.shouldPrintComment = i.shouldPrintComment || (() => i.comments)) : i.shouldPrintComment = i.shouldPrintComment || ((f) => i.comments || f.includes("@license") || f.includes("@preserve")), i.compact === "auto" && (i.compact = typeof e == "string" && e.length > 5e5, i.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${t.filename} as it exceeds the max of 500KB.`)), i.compact && (i.indent.adjustMultilineComment = !1);
  const {
    auxiliaryCommentBefore: a,
    auxiliaryCommentAfter: o,
    shouldPrintComment: l
  } = i;
  return a && !l(a) && (i.auxiliaryCommentBefore = void 0), o && !l(o) && (i.auxiliaryCommentAfter = void 0), i;
}
class CodeGenerator {
  constructor(t, s, i) {
    this._generator = void 0, this._generator = new Generator(t, s, i);
  }
  generate() {
    return this._generator.generate();
  }
}
lib$6.CodeGenerator = CodeGenerator;
function generate(e, t, s) {
  return new Generator(e, t, s).generate();
}
var ancestry = {};
Object.defineProperty(ancestry, "__esModule", {
  value: !0
});
ancestry.find = find;
ancestry.findParent = findParent;
ancestry.getAncestry = getAncestry;
ancestry.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
ancestry.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
ancestry.getFunctionParent = getFunctionParent;
ancestry.getStatementParent = getStatementParent;
ancestry.inType = inType;
ancestry.isAncestor = isAncestor;
ancestry.isDescendant = isDescendant;
var _t$c = requireLib$1();
const {
  VISITOR_KEYS: VISITOR_KEYS$1
} = _t$c;
function findParent(e) {
  let t = this;
  for (; t = t.parentPath; )
    if (e(t))
      return t;
  return null;
}
function find(e) {
  let t = this;
  do
    if (e(t))
      return t;
  while (t = t.parentPath);
  return null;
}
function getFunctionParent() {
  return this.findParent((e) => e.isFunction());
}
function getStatementParent() {
  let e = this;
  do {
    if (!e.parentPath || Array.isArray(e.container) && e.isStatement())
      break;
    e = e.parentPath;
  } while (e);
  if (e && (e.isProgram() || e.isFile()))
    throw new Error("File/Program node, we can't possibly find a statement parent to this");
  return e;
}
function getEarliestCommonAncestorFrom(e) {
  return this.getDeepestCommonAncestorFrom(e, function(t, s, i) {
    let a;
    const o = VISITOR_KEYS$1[t.type];
    for (const l of i) {
      const f = l[s + 1];
      if (!a) {
        a = f;
        continue;
      }
      if (f.listKey && a.listKey === f.listKey && f.key < a.key) {
        a = f;
        continue;
      }
      const y = o.indexOf(a.parentKey), g = o.indexOf(f.parentKey);
      y > g && (a = f);
    }
    return a;
  });
}
function getDeepestCommonAncestorFrom(e, t) {
  if (!e.length)
    return this;
  if (e.length === 1)
    return e[0];
  let s = 1 / 0, i, a;
  const o = e.map((f) => {
    const y = [];
    do
      y.unshift(f);
    while ((f = f.parentPath) && f !== this);
    return y.length < s && (s = y.length), y;
  }), l = o[0];
  e:
    for (let f = 0; f < s; f++) {
      const y = l[f];
      for (const g of o)
        if (g[f] !== y)
          break e;
      i = f, a = y;
    }
  if (a)
    return t ? t(a, i, o) : a;
  throw new Error("Couldn't find intersection");
}
function getAncestry() {
  let e = this;
  const t = [];
  do
    t.push(e);
  while (e = e.parentPath);
  return t;
}
function isAncestor(e) {
  return e.isDescendant(this);
}
function isDescendant(e) {
  return !!this.findParent((t) => t === e);
}
function inType(...e) {
  let t = this;
  for (; t; ) {
    for (const s of e)
      if (t.node.type === s)
        return !0;
    t = t.parentPath;
  }
  return !1;
}
var inference = {}, inferers$1 = {}, infererReference = {}, util = {};
Object.defineProperty(util, "__esModule", {
  value: !0
});
util.createUnionType = createUnionType;
var _t$b = requireLib$1();
const {
  createFlowUnionType,
  createTSUnionType,
  createUnionTypeAnnotation,
  isFlowType,
  isTSType
} = _t$b;
function createUnionType(e) {
  {
    if (isFlowType(e[0]))
      return createFlowUnionType ? createFlowUnionType(e) : createUnionTypeAnnotation(e);
    if (createTSUnionType)
      return createTSUnionType(e);
  }
}
Object.defineProperty(infererReference, "__esModule", {
  value: !0
});
infererReference.default = _default$3;
var _t$a = requireLib$1(), _util = util;
const {
  BOOLEAN_NUMBER_BINARY_OPERATORS,
  createTypeAnnotationBasedOnTypeof,
  numberTypeAnnotation,
  voidTypeAnnotation: voidTypeAnnotation$1
} = _t$a;
function _default$3(e) {
  if (!this.isReferenced())
    return;
  const t = this.scope.getBinding(e.name);
  if (t)
    return t.identifier.typeAnnotation ? t.identifier.typeAnnotation : getTypeAnnotationBindingConstantViolations(t, this, e.name);
  if (e.name === "undefined")
    return voidTypeAnnotation$1();
  if (e.name === "NaN" || e.name === "Infinity")
    return numberTypeAnnotation();
  e.name;
}
function getTypeAnnotationBindingConstantViolations(e, t, s) {
  const i = [], a = [];
  let o = getConstantViolationsBefore(e, t, a);
  const l = getConditionalAnnotation(e, t, s);
  if (l) {
    const f = getConstantViolationsBefore(e, l.ifStatement);
    o = o.filter((y) => f.indexOf(y) < 0), i.push(l.typeAnnotation);
  }
  if (o.length) {
    o.push(...a);
    for (const f of o)
      i.push(f.getTypeAnnotation());
  }
  if (i.length)
    return (0, _util.createUnionType)(i);
}
function getConstantViolationsBefore(e, t, s) {
  const i = e.constantViolations.slice();
  return i.unshift(e.path), i.filter((a) => {
    a = a.resolve();
    const o = a._guessExecutionStatusRelativeTo(t);
    return s && o === "unknown" && s.push(a), o === "before";
  });
}
function inferAnnotationFromBinaryExpression(e, t) {
  const s = t.node.operator, i = t.get("right").resolve(), a = t.get("left").resolve();
  let o;
  if (a.isIdentifier({
    name: e
  }) ? o = i : i.isIdentifier({
    name: e
  }) && (o = a), o)
    return s === "===" ? o.getTypeAnnotation() : BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(s) >= 0 ? numberTypeAnnotation() : void 0;
  if (s !== "===" && s !== "==")
    return;
  let l, f;
  if (a.isUnaryExpression({
    operator: "typeof"
  }) ? (l = a, f = i) : i.isUnaryExpression({
    operator: "typeof"
  }) && (l = i, f = a), !l || !l.get("argument").isIdentifier({
    name: e
  }) || (f = f.resolve(), !f.isLiteral()))
    return;
  const y = f.node.value;
  if (typeof y == "string")
    return createTypeAnnotationBasedOnTypeof(y);
}
function getParentConditionalPath(e, t, s) {
  let i;
  for (; i = t.parentPath; ) {
    if (i.isIfStatement() || i.isConditionalExpression())
      return t.key === "test" ? void 0 : i;
    if (i.isFunction() && i.parentPath.scope.getBinding(s) !== e)
      return;
    t = i;
  }
}
function getConditionalAnnotation(e, t, s) {
  const i = getParentConditionalPath(e, t, s);
  if (!i)
    return;
  const o = [i.get("test")], l = [];
  for (let f = 0; f < o.length; f++) {
    const y = o[f];
    if (y.isLogicalExpression())
      y.node.operator === "&&" && (o.push(y.get("left")), o.push(y.get("right")));
    else if (y.isBinaryExpression()) {
      const g = inferAnnotationFromBinaryExpression(s, y);
      g && l.push(g);
    }
  }
  return l.length ? {
    typeAnnotation: (0, _util.createUnionType)(l),
    ifStatement: i
  } : getConditionalAnnotation(e, i, s);
}
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.ArrayExpression = ge, e.AssignmentExpression = z, e.BinaryExpression = be, e.BooleanLiteral = ce, e.CallExpression = me, e.ConditionalExpression = F, e.ClassDeclaration = e.ClassExpression = e.FunctionDeclaration = e.ArrowFunctionExpression = e.FunctionExpression = we, Object.defineProperty(e, "Identifier", {
    enumerable: !0,
    get: function() {
      return s.default;
    }
  }), e.LogicalExpression = ve, e.NewExpression = ue, e.NullLiteral = Pe, e.NumericLiteral = fe, e.ObjectExpression = _e, e.ParenthesizedExpression = K, e.RegExpLiteral = Ce, e.RestElement = xe, e.SequenceExpression = R, e.StringLiteral = ie, e.TSAsExpression = j, e.TSNonNullExpression = V, e.TaggedTemplateExpression = pe, e.TemplateLiteral = ee, e.TypeCastExpression = _, e.UnaryExpression = se, e.UpdateExpression = re, e.VariableDeclarator = q;
  var t = requireLib$1(), s = infererReference, i = util;
  const {
    BOOLEAN_BINARY_OPERATORS: a,
    BOOLEAN_UNARY_OPERATORS: o,
    NUMBER_BINARY_OPERATORS: l,
    NUMBER_UNARY_OPERATORS: f,
    STRING_UNARY_OPERATORS: y,
    anyTypeAnnotation: g,
    arrayTypeAnnotation: T,
    booleanTypeAnnotation: S,
    buildMatchMemberExpression: b,
    genericTypeAnnotation: v,
    identifier: $,
    nullLiteralTypeAnnotation: U,
    numberTypeAnnotation: X,
    stringTypeAnnotation: k,
    tupleTypeAnnotation: D,
    unionTypeAnnotation: B,
    voidTypeAnnotation: Z,
    isIdentifier: H
  } = t;
  function q() {
    if (this.get("id").isIdentifier())
      return this.get("init").getTypeAnnotation();
  }
  function _(le) {
    return le.typeAnnotation;
  }
  _.validParent = !0;
  function j(le) {
    return le.typeAnnotation;
  }
  j.validParent = !0;
  function V() {
    return this.get("expression").getTypeAnnotation();
  }
  function ue(le) {
    if (le.callee.type === "Identifier")
      return v(le.callee);
  }
  function ee() {
    return k();
  }
  function se(le) {
    const he = le.operator;
    if (he === "void")
      return Z();
    if (f.indexOf(he) >= 0)
      return X();
    if (y.indexOf(he) >= 0)
      return k();
    if (o.indexOf(he) >= 0)
      return S();
  }
  function be(le) {
    const he = le.operator;
    if (l.indexOf(he) >= 0)
      return X();
    if (a.indexOf(he) >= 0)
      return S();
    if (he === "+") {
      const Se = this.get("right"), Ie = this.get("left");
      return Ie.isBaseType("number") && Se.isBaseType("number") ? X() : Ie.isBaseType("string") || Se.isBaseType("string") ? k() : B([k(), X()]);
    }
  }
  function ve() {
    const le = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, i.createUnionType)(le);
  }
  function F() {
    const le = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, i.createUnionType)(le);
  }
  function R() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  function K() {
    return this.get("expression").getTypeAnnotation();
  }
  function z() {
    return this.get("right").getTypeAnnotation();
  }
  function re(le) {
    const he = le.operator;
    if (he === "++" || he === "--")
      return X();
  }
  function ie() {
    return k();
  }
  function fe() {
    return X();
  }
  function ce() {
    return S();
  }
  function Pe() {
    return U();
  }
  function Ce() {
    return v($("RegExp"));
  }
  function _e() {
    return v($("Object"));
  }
  function ge() {
    return v($("Array"));
  }
  function xe() {
    return ge();
  }
  xe.validParent = !0;
  function we() {
    return v($("Function"));
  }
  const G = b("Array.from"), W = b("Object.keys"), te = b("Object.values"), oe = b("Object.entries");
  function me() {
    const {
      callee: le
    } = this.node;
    return W(le) ? T(k()) : G(le) || te(le) || H(le, {
      name: "Array"
    }) ? T(g()) : oe(le) ? T(D([k(), g()])) : ye(this.get("callee"));
  }
  function pe() {
    return ye(this.get("tag"));
  }
  function ye(le) {
    if (le = le.resolve(), le.isFunction()) {
      const {
        node: he
      } = le;
      if (he.async)
        return he.generator ? v($("AsyncIterator")) : v($("Promise"));
      if (he.generator)
        return v($("Iterator"));
      if (le.node.returnType)
        return le.node.returnType;
    }
  }
})(inferers$1);
Object.defineProperty(inference, "__esModule", {
  value: !0
});
inference._getTypeAnnotation = _getTypeAnnotation;
inference.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
inference.couldBeBaseType = couldBeBaseType;
inference.getTypeAnnotation = getTypeAnnotation;
inference.isBaseType = isBaseType;
inference.isGenericType = isGenericType;
var inferers = inferers$1, _t$9 = requireLib$1();
const {
  anyTypeAnnotation,
  isAnyTypeAnnotation,
  isArrayTypeAnnotation,
  isBooleanTypeAnnotation,
  isEmptyTypeAnnotation,
  isFlowBaseAnnotation,
  isGenericTypeAnnotation,
  isIdentifier: isIdentifier$4,
  isMixedTypeAnnotation,
  isNumberTypeAnnotation,
  isStringTypeAnnotation,
  isTSArrayType,
  isTSTypeAnnotation,
  isTSTypeReference,
  isTupleTypeAnnotation,
  isTypeAnnotation,
  isUnionTypeAnnotation,
  isVoidTypeAnnotation,
  stringTypeAnnotation,
  voidTypeAnnotation
} = _t$9;
function getTypeAnnotation() {
  let e = this.getData("typeAnnotation");
  return e != null || (e = this._getTypeAnnotation() || anyTypeAnnotation(), (isTypeAnnotation(e) || isTSTypeAnnotation(e)) && (e = e.typeAnnotation), this.setData("typeAnnotation", e)), e;
}
const typeAnnotationInferringNodes = /* @__PURE__ */ new WeakSet();
function _getTypeAnnotation() {
  const e = this.node;
  if (!e)
    if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
      const s = this.parentPath.parentPath, i = s.parentPath;
      return s.key === "left" && i.isForInStatement() ? stringTypeAnnotation() : s.key === "left" && i.isForOfStatement() ? anyTypeAnnotation() : voidTypeAnnotation();
    } else
      return;
  if (e.typeAnnotation)
    return e.typeAnnotation;
  if (!typeAnnotationInferringNodes.has(e)) {
    typeAnnotationInferringNodes.add(e);
    try {
      var t;
      let s = inferers[e.type];
      if (s)
        return s.call(this, e);
      if (s = inferers[this.parentPath.type], (t = s) != null && t.validParent)
        return this.parentPath.getTypeAnnotation();
    } finally {
      typeAnnotationInferringNodes.delete(e);
    }
  }
}
function isBaseType(e, t) {
  return _isBaseType(e, this.getTypeAnnotation(), t);
}
function _isBaseType(e, t, s) {
  if (e === "string")
    return isStringTypeAnnotation(t);
  if (e === "number")
    return isNumberTypeAnnotation(t);
  if (e === "boolean")
    return isBooleanTypeAnnotation(t);
  if (e === "any")
    return isAnyTypeAnnotation(t);
  if (e === "mixed")
    return isMixedTypeAnnotation(t);
  if (e === "empty")
    return isEmptyTypeAnnotation(t);
  if (e === "void")
    return isVoidTypeAnnotation(t);
  if (s)
    return !1;
  throw new Error(`Unknown base type ${e}`);
}
function couldBeBaseType(e) {
  const t = this.getTypeAnnotation();
  if (isAnyTypeAnnotation(t))
    return !0;
  if (isUnionTypeAnnotation(t)) {
    for (const s of t.types)
      if (isAnyTypeAnnotation(s) || _isBaseType(e, s, !0))
        return !0;
    return !1;
  } else
    return _isBaseType(e, t, !0);
}
function baseTypeStrictlyMatches(e) {
  const t = this.getTypeAnnotation(), s = e.getTypeAnnotation();
  return !isAnyTypeAnnotation(t) && isFlowBaseAnnotation(t) ? s.type === t.type : !1;
}
function isGenericType(e) {
  const t = this.getTypeAnnotation();
  return e === "Array" && (isTSArrayType(t) || isArrayTypeAnnotation(t) || isTupleTypeAnnotation(t)) ? !0 : isGenericTypeAnnotation(t) && isIdentifier$4(t.id, {
    name: e
  }) || isTSTypeReference(t) && isIdentifier$4(t.typeName, {
    name: e
  });
}
var replacement = {}, lib$5 = {}, lib$4 = {}, jsTokens = {};
Object.defineProperty(jsTokens, "__esModule", {
  value: !0
});
jsTokens.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
jsTokens.matchToToken = function(e) {
  var t = { type: "invalid", value: e[0], closed: void 0 };
  return e[1] ? (t.type = "string", t.closed = !!(e[3] || e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) : e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "whitespace"), t;
};
Object.defineProperty(lib$4, "__esModule", {
  value: !0
});
lib$4.default = highlight;
lib$4.shouldHighlight = shouldHighlight;
var _jsTokens = jsTokens, _helperValidatorIdentifier = lib$a, _chalk$1 = _interopRequireWildcard$1(require$$2, !0);
function _getRequireWildcardCache$1(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache$1 = function(i) {
    return i ? s : t;
  })(e);
}
function _interopRequireWildcard$1(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var s = _getRequireWildcardCache$1(t);
  if (s && s.has(e))
    return s.get(e);
  var i = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var o in e)
    if (o !== "default" && Object.prototype.hasOwnProperty.call(e, o)) {
      var l = a ? Object.getOwnPropertyDescriptor(e, o) : null;
      l && (l.get || l.set) ? Object.defineProperty(i, o, l) : i[o] = e[o];
    }
  return i.default = e, s && s.set(e, i), i;
}
const sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
function getDefs$1(e) {
  return {
    keyword: e.cyan,
    capitalized: e.yellow,
    jsxIdentifier: e.yellow,
    punctuator: e.yellow,
    number: e.magenta,
    string: e.green,
    regex: e.magenta,
    comment: e.grey,
    invalid: e.white.bgRed.bold
  };
}
const NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/, BRACKET = /^[()[\]{}]$/;
let tokenize;
{
  const e = /^[a-z][\w-]*$/i, t = function(s, i, a) {
    if (s.type === "name") {
      if ((0, _helperValidatorIdentifier.isKeyword)(s.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(s.value, !0) || sometimesKeywords.has(s.value))
        return "keyword";
      if (e.test(s.value) && (a[i - 1] === "<" || a.slice(i - 2, i) == "</"))
        return "jsxIdentifier";
      if (s.value[0] !== s.value[0].toLowerCase())
        return "capitalized";
    }
    return s.type === "punctuator" && BRACKET.test(s.value) ? "bracket" : s.type === "invalid" && (s.value === "@" || s.value === "#") ? "punctuator" : s.type;
  };
  tokenize = function* (s) {
    let i;
    for (; i = _jsTokens.default.exec(s); ) {
      const a = _jsTokens.matchToToken(i);
      yield {
        type: t(a, i.index, s),
        value: a.value
      };
    }
  };
}
function highlightTokens(e, t) {
  let s = "";
  for (const {
    type: i,
    value: a
  } of tokenize(t)) {
    const o = e[i];
    o ? s += a.split(NEWLINE$1).map((l) => o(l)).join(`
`) : s += a;
  }
  return s;
}
function shouldHighlight(e) {
  return _chalk$1.default.level > 0 || e.forceColor;
}
let chalkWithForcedColor$1;
function getChalk$1(e) {
  if (e) {
    var t;
    return (t = chalkWithForcedColor$1) != null || (chalkWithForcedColor$1 = new _chalk$1.default.constructor({
      enabled: !0,
      level: 1
    })), chalkWithForcedColor$1;
  }
  return _chalk$1.default;
}
lib$4.getChalk = (e) => getChalk$1(e.forceColor);
function highlight(e, t = {}) {
  if (e !== "" && shouldHighlight(t)) {
    const s = getDefs$1(getChalk$1(t.forceColor));
    return highlightTokens(s, e);
  } else
    return e;
}
Object.defineProperty(lib$5, "__esModule", {
  value: !0
});
lib$5.codeFrameColumns = codeFrameColumns;
lib$5.default = _default$2;
var _highlight = lib$4, _chalk = _interopRequireWildcard(require$$2, !0);
function _getRequireWildcardCache(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache = function(i) {
    return i ? s : t;
  })(e);
}
function _interopRequireWildcard(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var s = _getRequireWildcardCache(t);
  if (s && s.has(e))
    return s.get(e);
  var i = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var o in e)
    if (o !== "default" && Object.prototype.hasOwnProperty.call(e, o)) {
      var l = a ? Object.getOwnPropertyDescriptor(e, o) : null;
      l && (l.get || l.set) ? Object.defineProperty(i, o, l) : i[o] = e[o];
    }
  return i.default = e, s && s.set(e, i), i;
}
let chalkWithForcedColor;
function getChalk(e) {
  if (e) {
    var t;
    return (t = chalkWithForcedColor) != null || (chalkWithForcedColor = new _chalk.default.constructor({
      enabled: !0,
      level: 1
    })), chalkWithForcedColor;
  }
  return _chalk.default;
}
let deprecationWarningShown = !1;
function getDefs(e) {
  return {
    gutter: e.grey,
    marker: e.red.bold,
    message: e.red.bold
  };
}
const NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
function getMarkerLines(e, t, s) {
  const i = Object.assign({
    column: 0,
    line: -1
  }, e.start), a = Object.assign({}, i, e.end), {
    linesAbove: o = 2,
    linesBelow: l = 3
  } = s || {}, f = i.line, y = i.column, g = a.line, T = a.column;
  let S = Math.max(f - (o + 1), 0), b = Math.min(t.length, g + l);
  f === -1 && (S = 0), g === -1 && (b = t.length);
  const v = g - f, $ = {};
  if (v)
    for (let U = 0; U <= v; U++) {
      const X = U + f;
      if (!y)
        $[X] = !0;
      else if (U === 0) {
        const k = t[X - 1].length;
        $[X] = [y, k - y + 1];
      } else if (U === v)
        $[X] = [0, T];
      else {
        const k = t[X - U].length;
        $[X] = [0, k];
      }
    }
  else
    y === T ? y ? $[f] = [y, 0] : $[f] = !0 : $[f] = [y, T - y];
  return {
    start: S,
    end: b,
    markerLines: $
  };
}
function codeFrameColumns(e, t, s = {}) {
  const i = (s.highlightCode || s.forceColor) && (0, _highlight.shouldHighlight)(s), a = getChalk(s.forceColor), o = getDefs(a), l = (U, X) => i ? U(X) : X, f = e.split(NEWLINE), {
    start: y,
    end: g,
    markerLines: T
  } = getMarkerLines(t, f, s), S = t.start && typeof t.start.column == "number", b = String(g).length;
  let $ = (i ? (0, _highlight.default)(e, s) : e).split(NEWLINE, g).slice(y, g).map((U, X) => {
    const k = y + 1 + X, B = ` ${` ${k}`.slice(-b)} |`, Z = T[k], H = !T[k + 1];
    if (Z) {
      let q = "";
      if (Array.isArray(Z)) {
        const _ = U.slice(0, Math.max(Z[0] - 1, 0)).replace(/[^\t]/g, " "), j = Z[1] || 1;
        q = [`
 `, l(o.gutter, B.replace(/\d/g, " ")), " ", _, l(o.marker, "^").repeat(j)].join(""), H && s.message && (q += " " + l(o.message, s.message));
      }
      return [l(o.marker, ">"), l(o.gutter, B), U.length > 0 ? ` ${U}` : "", q].join("");
    } else
      return ` ${l(o.gutter, B)}${U.length > 0 ? ` ${U}` : ""}`;
  }).join(`
`);
  return s.message && !S && ($ = `${" ".repeat(b + 1)}${s.message}
${$}`), i ? a.reset($) : $;
}
function _default$2(e, t, s, i = {}) {
  if (!deprecationWarningShown) {
    deprecationWarningShown = !0;
    const o = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
    if (process.emitWarning)
      process.emitWarning(o, "DeprecationWarning");
    else {
      const l = new Error(o);
      l.name = "DeprecationWarning", console.warn(new Error(o));
    }
  }
  return s = Math.max(s, 0), codeFrameColumns(e, {
    start: {
      column: s,
      line: t
    }
  }, i);
}
var lib$3 = {};
Object.defineProperty(lib$3, "__esModule", {
  value: !0
});
function _objectWithoutPropertiesLoose$1(e, t) {
  if (e == null)
    return {};
  var s = {}, i = Object.keys(e), a, o;
  for (o = 0; o < i.length; o++)
    a = i[o], !(t.indexOf(a) >= 0) && (s[a] = e[a]);
  return s;
}
class Position {
  constructor(t, s, i) {
    this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = s, this.index = i;
  }
}
class SourceLocation {
  constructor(t, s) {
    this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = s;
  }
}
function createPositionWithColumnOffset(e, t) {
  const {
    line: s,
    column: i,
    index: a
  } = e;
  return new Position(s, i + t, a + t);
}
const code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
var ModuleErrors = {
  ImportMetaOutsideModule: {
    message: `import.meta may appear only with 'sourceType: "module"'`,
    code
  },
  ImportOutsideModule: {
    message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
    code
  }
};
const NodeDescriptions = {
  ArrayPattern: "array destructuring pattern",
  AssignmentExpression: "assignment expression",
  AssignmentPattern: "assignment expression",
  ArrowFunctionExpression: "arrow function expression",
  ConditionalExpression: "conditional expression",
  CatchClause: "catch clause",
  ForOfStatement: "for-of statement",
  ForInStatement: "for-in statement",
  ForStatement: "for-loop",
  FormalParameters: "function parameter list",
  Identifier: "identifier",
  ImportSpecifier: "import specifier",
  ImportDefaultSpecifier: "import default specifier",
  ImportNamespaceSpecifier: "import namespace specifier",
  ObjectPattern: "object destructuring pattern",
  ParenthesizedExpression: "parenthesized expression",
  RestElement: "rest element",
  UpdateExpression: {
    true: "prefix operation",
    false: "postfix operation"
  },
  VariableDeclarator: "variable declaration",
  YieldExpression: "yield expression"
}, toNodeDescription = ({
  type: e,
  prefix: t
}) => e === "UpdateExpression" ? NodeDescriptions.UpdateExpression[String(t)] : NodeDescriptions[e];
var StandardErrors = {
  AccessorIsGenerator: ({
    kind: e
  }) => `A ${e}ter cannot be a generator.`,
  ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
  AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
  AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
  AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
  AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
  AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
  AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
  AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
  BadGetterArity: "A 'get' accessor must not have any formal parameters.",
  BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
  BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
  ConstructorClassField: "Classes may not have a field named 'constructor'.",
  ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
  ConstructorIsAccessor: "Class constructor may not be an accessor.",
  ConstructorIsAsync: "Constructor can't be an async function.",
  ConstructorIsGenerator: "Constructor can't be a generator.",
  DeclarationMissingInitializer: ({
    kind: e
  }) => `Missing initializer in ${e} declaration.`,
  DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
  DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
  DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
  DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
  DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
  DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
  DecoratorStaticBlock: "Decorators can't be used with a static block.",
  DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
  DeletePrivateField: "Deleting a private field is not allowed.",
  DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
  DuplicateConstructor: "Duplicate constructor in the same class.",
  DuplicateDefaultExport: "Only one default export allowed per module.",
  DuplicateExport: ({
    exportName: e
  }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`,
  DuplicateProto: "Redefinition of __proto__ property.",
  DuplicateRegExpFlags: "Duplicate regular expression flag.",
  DynamicImportPhaseRequiresImportExpressions: ({
    phase: e
  }) => `'import.${e}(...)' can only be parsed when using the 'createImportExpressions' option.`,
  ElementAfterRest: "Rest element must be last element.",
  EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
  ExportBindingIsString: ({
    localName: e,
    exportName: t
  }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`,
  ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
  ForInOfLoopInitializer: ({
    type: e
  }) => `'${e === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
  ForInUsing: "For-in loop may not start with 'using' declaration.",
  ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
  ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
  GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
  IllegalBreakContinue: ({
    type: e
  }) => `Unsyntactic ${e === "BreakStatement" ? "break" : "continue"}.`,
  IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
  IllegalReturn: "'return' outside of function.",
  ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
  ImportBindingIsString: ({
    importName: e
  }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`,
  ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
  ImportCallArity: ({
    maxArgumentCount: e
  }) => `\`import()\` requires exactly ${e === 1 ? "one argument" : "one or two arguments"}.`,
  ImportCallNotNewExpression: "Cannot use new with import(...).",
  ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
  ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
  ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
  ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
  IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
  InvalidBigIntLiteral: "Invalid BigIntLiteral.",
  InvalidCodePoint: "Code point out of bounds.",
  InvalidCoverInitializedName: "Invalid shorthand property initializer.",
  InvalidDecimal: "Invalid decimal.",
  InvalidDigit: ({
    radix: e
  }) => `Expected number in radix ${e}.`,
  InvalidEscapeSequence: "Bad character escape sequence.",
  InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
  InvalidEscapedReservedWord: ({
    reservedWord: e
  }) => `Escape sequence in keyword ${e}.`,
  InvalidIdentifier: ({
    identifierName: e
  }) => `Invalid identifier ${e}.`,
  InvalidLhs: ({
    ancestor: e
  }) => `Invalid left-hand side in ${toNodeDescription(e)}.`,
  InvalidLhsBinding: ({
    ancestor: e
  }) => `Binding invalid left-hand side in ${toNodeDescription(e)}.`,
  InvalidLhsOptionalChaining: ({
    ancestor: e
  }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(e)}.`,
  InvalidNumber: "Invalid number.",
  InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
  InvalidOrUnexpectedToken: ({
    unexpected: e
  }) => `Unexpected character '${e}'.`,
  InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
  InvalidPrivateFieldResolution: ({
    identifierName: e
  }) => `Private name #${e} is not defined.`,
  InvalidPropertyBindingPattern: "Binding member expression.",
  InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
  InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
  LabelRedeclaration: ({
    labelName: e
  }) => `Label '${e}' is already declared.`,
  LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
  LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
  MalformedRegExpFlags: "Invalid regular expression flag.",
  MissingClassName: "A class name is required.",
  MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
  MissingSemicolon: "Missing semicolon.",
  MissingPlugin: ({
    missingPlugin: e
  }) => `This experimental syntax requires enabling the parser plugin: ${e.map((t) => JSON.stringify(t)).join(", ")}.`,
  MissingOneOfPlugins: ({
    missingPlugin: e
  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((t) => JSON.stringify(t)).join(", ")}.`,
  MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
  MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
  ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
  ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
  ModuleAttributesWithDuplicateKeys: ({
    key: e
  }) => `Duplicate key "${e}" is not allowed in module attributes.`,
  ModuleExportNameHasLoneSurrogate: ({
    surrogateCharCode: e
  }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`,
  ModuleExportUndefined: ({
    localName: e
  }) => `Export '${e}' is not defined.`,
  MultipleDefaultsInSwitch: "Multiple default clauses.",
  NewlineAfterThrow: "Illegal newline after throw.",
  NoCatchOrFinally: "Missing catch or finally clause.",
  NumberIdentifier: "Identifier directly after number.",
  NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
  ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
  OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
  OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
  OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
  ParamDupe: "Argument name clash.",
  PatternHasAccessor: "Object pattern can't contain getter or setter.",
  PatternHasMethod: "Object pattern can't contain methods.",
  PrivateInExpectedIn: ({
    identifierName: e
  }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`,
  PrivateNameRedeclaration: ({
    identifierName: e
  }) => `Duplicate private name #${e}.`,
  RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  RecordNoProto: "'__proto__' is not allowed in Record expressions.",
  RestTrailingComma: "Unexpected trailing comma after rest element.",
  SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
  SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
  SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
  StaticPrototype: "Classes may not have static property named prototype.",
  SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
  SuperPrivateField: "Private fields can't be accessed on super.",
  TrailingDecorator: "Decorators must be attached to a class element.",
  TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
  TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
  UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
  UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
  UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
  UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
  UnexpectedKeyword: ({
    keyword: e
  }) => `Unexpected keyword '${e}'.`,
  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
  UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
  UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
  UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
  UnexpectedPrivateField: "Unexpected private name.",
  UnexpectedReservedWord: ({
    reservedWord: e
  }) => `Unexpected reserved word '${e}'.`,
  UnexpectedSuper: "'super' is only allowed in object methods and classes.",
  UnexpectedToken: ({
    expected: e,
    unexpected: t
  }) => `Unexpected token${t ? ` '${t}'.` : ""}${e ? `, expected "${e}"` : ""}`,
  UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
  UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
  UnsupportedBind: "Binding should be performed on object property.",
  UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
  UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
  UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
  UnsupportedMetaProperty: ({
    target: e,
    onlyValidPropertyName: t
  }) => `The only valid meta property for ${e} is ${e}.${t}.`,
  UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
  UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
  UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
  UnterminatedComment: "Unterminated comment.",
  UnterminatedRegExp: "Unterminated regular expression.",
  UnterminatedString: "Unterminated string constant.",
  UnterminatedTemplate: "Unterminated template.",
  UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
  VarRedeclaration: ({
    identifierName: e
  }) => `Identifier '${e}' has already been declared.`,
  YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
  YieldInParameter: "Yield expression is not allowed in formal parameters.",
  ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
}, StrictModeErrors = {
  StrictDelete: "Deleting local variable in strict mode.",
  StrictEvalArguments: ({
    referenceName: e
  }) => `Assigning to '${e}' in strict mode.`,
  StrictEvalArgumentsBinding: ({
    bindingName: e
  }) => `Binding '${e}' in strict mode.`,
  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
  StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
  StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
  StrictWith: "'with' in strict mode."
};
const UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
var PipelineOperatorErrors = {
  PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
  PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
  PipeTopicUnconfiguredToken: ({
    token: e
  }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e}" }.`,
  PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
  PipeUnparenthesizedBody: ({
    type: e
  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
    type: e
  })}; please wrap it in parentheses.`,
  PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
  PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
  PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
  PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
  PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
};
const _excluded$1 = ["toMessage"], _excluded2$1 = ["message"];
function defineHidden(e, t, s) {
  Object.defineProperty(e, t, {
    enumerable: !1,
    configurable: !0,
    value: s
  });
}
function toParseErrorConstructor(e) {
  let {
    toMessage: t
  } = e, s = _objectWithoutPropertiesLoose$1(e, _excluded$1);
  return function i({
    loc: a,
    details: o
  }) {
    const l = new SyntaxError();
    return Object.assign(l, s, {
      loc: a,
      pos: a.index
    }), "missingPlugin" in o && Object.assign(l, {
      missingPlugin: o.missingPlugin
    }), defineHidden(l, "clone", function(y = {}) {
      var g;
      const {
        line: T,
        column: S,
        index: b
      } = (g = y.loc) != null ? g : a;
      return i({
        loc: new Position(T, S, b),
        details: Object.assign({}, o, y.details)
      });
    }), defineHidden(l, "details", o), Object.defineProperty(l, "message", {
      configurable: !0,
      get() {
        const f = `${t(o)} (${a.line}:${a.column})`;
        return this.message = f, f;
      },
      set(f) {
        Object.defineProperty(this, "message", {
          value: f,
          writable: !0
        });
      }
    }), l;
  };
}
function ParseErrorEnum(e, t) {
  if (Array.isArray(e))
    return (i) => ParseErrorEnum(i, e[0]);
  const s = {};
  for (const i of Object.keys(e)) {
    const a = e[i], o = typeof a == "string" ? {
      message: () => a
    } : typeof a == "function" ? {
      message: a
    } : a, {
      message: l
    } = o, f = _objectWithoutPropertiesLoose$1(o, _excluded2$1), y = typeof l == "string" ? () => l : l;
    s[i] = toParseErrorConstructor(Object.assign({
      code: "BABEL_PARSER_SYNTAX_ERROR",
      reasonCode: i,
      toMessage: y
    }, t ? {
      syntaxPlugin: t
    } : {}, f));
  }
  return s;
}
const Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors)), {
  defineProperty
} = Object, toUnenumerable = (e, t) => defineProperty(e, t, {
  enumerable: !1,
  value: e[t]
});
function toESTreeLocation(e) {
  return e.loc.start && toUnenumerable(e.loc.start, "index"), e.loc.end && toUnenumerable(e.loc.end, "index"), e;
}
var estree = (e) => class extends e {
  parse() {
    const s = toESTreeLocation(super.parse());
    return this.options.tokens && (s.tokens = s.tokens.map(toESTreeLocation)), s;
  }
  parseRegExpLiteral({
    pattern: s,
    flags: i
  }) {
    let a = null;
    try {
      a = new RegExp(s, i);
    } catch {
    }
    const o = this.estreeParseLiteral(a);
    return o.regex = {
      pattern: s,
      flags: i
    }, o;
  }
  parseBigIntLiteral(s) {
    let i;
    try {
      i = BigInt(s);
    } catch {
      i = null;
    }
    const a = this.estreeParseLiteral(i);
    return a.bigint = String(a.value || s), a;
  }
  parseDecimalLiteral(s) {
    const a = this.estreeParseLiteral(null);
    return a.decimal = String(a.value || s), a;
  }
  estreeParseLiteral(s) {
    return this.parseLiteral(s, "Literal");
  }
  parseStringLiteral(s) {
    return this.estreeParseLiteral(s);
  }
  parseNumericLiteral(s) {
    return this.estreeParseLiteral(s);
  }
  parseNullLiteral() {
    return this.estreeParseLiteral(null);
  }
  parseBooleanLiteral(s) {
    return this.estreeParseLiteral(s);
  }
  directiveToStmt(s) {
    const i = s.value;
    delete s.value, i.type = "Literal", i.raw = i.extra.raw, i.value = i.extra.expressionValue;
    const a = s;
    return a.type = "ExpressionStatement", a.expression = i, a.directive = i.extra.rawValue, delete i.extra, a;
  }
  initFunction(s, i) {
    super.initFunction(s, i), s.expression = !1;
  }
  checkDeclaration(s) {
    s != null && this.isObjectProperty(s) ? this.checkDeclaration(s.value) : super.checkDeclaration(s);
  }
  getObjectOrClassMethodParams(s) {
    return s.value.params;
  }
  isValidDirective(s) {
    var i;
    return s.type === "ExpressionStatement" && s.expression.type === "Literal" && typeof s.expression.value == "string" && !((i = s.expression.extra) != null && i.parenthesized);
  }
  parseBlockBody(s, i, a, o, l) {
    super.parseBlockBody(s, i, a, o, l);
    const f = s.directives.map((y) => this.directiveToStmt(y));
    s.body = f.concat(s.body), delete s.directives;
  }
  pushClassMethod(s, i, a, o, l, f) {
    this.parseMethod(i, a, o, l, f, "ClassMethod", !0), i.typeParameters && (i.value.typeParameters = i.typeParameters, delete i.typeParameters), s.body.push(i);
  }
  parsePrivateName() {
    const s = super.parsePrivateName();
    return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(s) : s;
  }
  convertPrivateNameToPrivateIdentifier(s) {
    const i = super.getPrivateNameSV(s);
    return s = s, delete s.id, s.name = i, s.type = "PrivateIdentifier", s;
  }
  isPrivateName(s) {
    return this.getPluginOption("estree", "classFeatures") ? s.type === "PrivateIdentifier" : super.isPrivateName(s);
  }
  getPrivateNameSV(s) {
    return this.getPluginOption("estree", "classFeatures") ? s.name : super.getPrivateNameSV(s);
  }
  parseLiteral(s, i) {
    const a = super.parseLiteral(s, i);
    return a.raw = a.extra.raw, delete a.extra, a;
  }
  parseFunctionBody(s, i, a = !1) {
    super.parseFunctionBody(s, i, a), s.expression = s.body.type !== "BlockStatement";
  }
  parseMethod(s, i, a, o, l, f, y = !1) {
    let g = this.startNode();
    return g.kind = s.kind, g = super.parseMethod(g, i, a, o, l, f, y), g.type = "FunctionExpression", delete g.kind, s.value = g, f === "ClassPrivateMethod" && (s.computed = !1), this.finishNode(s, "MethodDefinition");
  }
  parseClassProperty(...s) {
    const i = super.parseClassProperty(...s);
    return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition"), i;
  }
  parseClassPrivateProperty(...s) {
    const i = super.parseClassPrivateProperty(...s);
    return this.getPluginOption("estree", "classFeatures") && (i.type = "PropertyDefinition", i.computed = !1), i;
  }
  parseObjectMethod(s, i, a, o, l) {
    const f = super.parseObjectMethod(s, i, a, o, l);
    return f && (f.type = "Property", f.kind === "method" && (f.kind = "init"), f.shorthand = !1), f;
  }
  parseObjectProperty(s, i, a, o) {
    const l = super.parseObjectProperty(s, i, a, o);
    return l && (l.kind = "init", l.type = "Property"), l;
  }
  isValidLVal(s, i, a) {
    return s === "Property" ? "value" : super.isValidLVal(s, i, a);
  }
  isAssignable(s, i) {
    return s != null && this.isObjectProperty(s) ? this.isAssignable(s.value, i) : super.isAssignable(s, i);
  }
  toAssignable(s, i = !1) {
    if (s != null && this.isObjectProperty(s)) {
      const {
        key: a,
        value: o
      } = s;
      this.isPrivateName(a) && this.classScope.usePrivateName(this.getPrivateNameSV(a), a.loc.start), this.toAssignable(o, i);
    } else
      super.toAssignable(s, i);
  }
  toAssignableObjectExpressionProp(s, i, a) {
    s.kind === "get" || s.kind === "set" ? this.raise(Errors.PatternHasAccessor, {
      at: s.key
    }) : s.method ? this.raise(Errors.PatternHasMethod, {
      at: s.key
    }) : super.toAssignableObjectExpressionProp(s, i, a);
  }
  finishCallExpression(s, i) {
    const a = super.finishCallExpression(s, i);
    if (a.callee.type === "Import") {
      if (a.type = "ImportExpression", a.source = a.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
        var o, l;
        a.options = (o = a.arguments[1]) != null ? o : null, a.attributes = (l = a.arguments[1]) != null ? l : null;
      }
      delete a.arguments, delete a.callee;
    }
    return a;
  }
  toReferencedArguments(s) {
    s.type !== "ImportExpression" && super.toReferencedArguments(s);
  }
  parseExport(s, i) {
    const a = this.state.lastTokStartLoc, o = super.parseExport(s, i);
    switch (o.type) {
      case "ExportAllDeclaration":
        o.exported = null;
        break;
      case "ExportNamedDeclaration":
        o.specifiers.length === 1 && o.specifiers[0].type === "ExportNamespaceSpecifier" && (o.type = "ExportAllDeclaration", o.exported = o.specifiers[0].exported, delete o.specifiers);
      case "ExportDefaultDeclaration":
        {
          var l;
          const {
            declaration: f
          } = o;
          (f == null ? void 0 : f.type) === "ClassDeclaration" && ((l = f.decorators) == null ? void 0 : l.length) > 0 && f.start === o.start && this.resetStartLocation(o, a);
        }
        break;
    }
    return o;
  }
  parseSubscript(s, i, a, o) {
    const l = super.parseSubscript(s, i, a, o);
    if (o.optionalChainMember) {
      if ((l.type === "OptionalMemberExpression" || l.type === "OptionalCallExpression") && (l.type = l.type.substring(8)), o.stop) {
        const f = this.startNodeAtNode(l);
        return f.expression = l, this.finishNode(f, "ChainExpression");
      }
    } else
      (l.type === "MemberExpression" || l.type === "CallExpression") && (l.optional = !1);
    return l;
  }
  isOptionalMemberExpression(s) {
    return s.type === "ChainExpression" ? s.expression.type === "MemberExpression" : super.isOptionalMemberExpression(s);
  }
  hasPropertyAsPrivateName(s) {
    return s.type === "ChainExpression" && (s = s.expression), super.hasPropertyAsPrivateName(s);
  }
  isObjectProperty(s) {
    return s.type === "Property" && s.kind === "init" && !s.method;
  }
  isObjectMethod(s) {
    return s.method || s.kind === "get" || s.kind === "set";
  }
  finishNodeAt(s, i, a) {
    return toESTreeLocation(super.finishNodeAt(s, i, a));
  }
  resetStartLocation(s, i) {
    super.resetStartLocation(s, i), toESTreeLocation(s);
  }
  resetEndLocation(s, i = this.state.lastTokEndLoc) {
    super.resetEndLocation(s, i), toESTreeLocation(s);
  }
};
class TokContext {
  constructor(t, s) {
    this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!s;
  }
}
const types = {
  brace: new TokContext("{"),
  j_oTag: new TokContext("<tag"),
  j_cTag: new TokContext("</tag"),
  j_expr: new TokContext("<tag>...</tag>", !0)
};
types.template = new TokContext("`", !0);
const beforeExpr = !0, startsExpr = !0, isLoop = !0, isAssign = !0, prefix = !0, postfix = !0;
class ExportedTokenType {
  constructor(t, s = {}) {
    this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = s.keyword, this.beforeExpr = !!s.beforeExpr, this.startsExpr = !!s.startsExpr, this.rightAssociative = !!s.rightAssociative, this.isLoop = !!s.isLoop, this.isAssign = !!s.isAssign, this.prefix = !!s.prefix, this.postfix = !!s.postfix, this.binop = s.binop != null ? s.binop : null, this.updateContext = null;
  }
}
const keywords$1 = /* @__PURE__ */ new Map();
function createKeyword(e, t = {}) {
  t.keyword = e;
  const s = createToken(e, t);
  return keywords$1.set(e, s), s;
}
function createBinop(e, t) {
  return createToken(e, {
    beforeExpr,
    binop: t
  });
}
let tokenTypeCounter = -1;
const tokenTypes = [], tokenLabels = [], tokenBinops = [], tokenBeforeExprs = [], tokenStartsExprs = [], tokenPrefixes = [];
function createToken(e, t = {}) {
  var s, i, a, o;
  return ++tokenTypeCounter, tokenLabels.push(e), tokenBinops.push((s = t.binop) != null ? s : -1), tokenBeforeExprs.push((i = t.beforeExpr) != null ? i : !1), tokenStartsExprs.push((a = t.startsExpr) != null ? a : !1), tokenPrefixes.push((o = t.prefix) != null ? o : !1), tokenTypes.push(new ExportedTokenType(e, t)), tokenTypeCounter;
}
function createKeywordLike(e, t = {}) {
  var s, i, a, o;
  return ++tokenTypeCounter, keywords$1.set(e, tokenTypeCounter), tokenLabels.push(e), tokenBinops.push((s = t.binop) != null ? s : -1), tokenBeforeExprs.push((i = t.beforeExpr) != null ? i : !1), tokenStartsExprs.push((a = t.startsExpr) != null ? a : !1), tokenPrefixes.push((o = t.prefix) != null ? o : !1), tokenTypes.push(new ExportedTokenType("name", t)), tokenTypeCounter;
}
const tt = {
  bracketL: createToken("[", {
    beforeExpr,
    startsExpr
  }),
  bracketHashL: createToken("#[", {
    beforeExpr,
    startsExpr
  }),
  bracketBarL: createToken("[|", {
    beforeExpr,
    startsExpr
  }),
  bracketR: createToken("]"),
  bracketBarR: createToken("|]"),
  braceL: createToken("{", {
    beforeExpr,
    startsExpr
  }),
  braceBarL: createToken("{|", {
    beforeExpr,
    startsExpr
  }),
  braceHashL: createToken("#{", {
    beforeExpr,
    startsExpr
  }),
  braceR: createToken("}"),
  braceBarR: createToken("|}"),
  parenL: createToken("(", {
    beforeExpr,
    startsExpr
  }),
  parenR: createToken(")"),
  comma: createToken(",", {
    beforeExpr
  }),
  semi: createToken(";", {
    beforeExpr
  }),
  colon: createToken(":", {
    beforeExpr
  }),
  doubleColon: createToken("::", {
    beforeExpr
  }),
  dot: createToken("."),
  question: createToken("?", {
    beforeExpr
  }),
  questionDot: createToken("?."),
  arrow: createToken("=>", {
    beforeExpr
  }),
  template: createToken("template"),
  ellipsis: createToken("...", {
    beforeExpr
  }),
  backQuote: createToken("`", {
    startsExpr
  }),
  dollarBraceL: createToken("${", {
    beforeExpr,
    startsExpr
  }),
  templateTail: createToken("...`", {
    startsExpr
  }),
  templateNonTail: createToken("...${", {
    beforeExpr,
    startsExpr
  }),
  at: createToken("@"),
  hash: createToken("#", {
    startsExpr
  }),
  interpreterDirective: createToken("#!..."),
  eq: createToken("=", {
    beforeExpr,
    isAssign
  }),
  assign: createToken("_=", {
    beforeExpr,
    isAssign
  }),
  slashAssign: createToken("_=", {
    beforeExpr,
    isAssign
  }),
  xorAssign: createToken("_=", {
    beforeExpr,
    isAssign
  }),
  moduloAssign: createToken("_=", {
    beforeExpr,
    isAssign
  }),
  incDec: createToken("++/--", {
    prefix,
    postfix,
    startsExpr
  }),
  bang: createToken("!", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  tilde: createToken("~", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  doubleCaret: createToken("^^", {
    startsExpr
  }),
  doubleAt: createToken("@@", {
    startsExpr
  }),
  pipeline: createBinop("|>", 0),
  nullishCoalescing: createBinop("??", 1),
  logicalOR: createBinop("||", 1),
  logicalAND: createBinop("&&", 2),
  bitwiseOR: createBinop("|", 3),
  bitwiseXOR: createBinop("^", 4),
  bitwiseAND: createBinop("&", 5),
  equality: createBinop("==/!=/===/!==", 6),
  lt: createBinop("</>/<=/>=", 7),
  gt: createBinop("</>/<=/>=", 7),
  relational: createBinop("</>/<=/>=", 7),
  bitShift: createBinop("<</>>/>>>", 8),
  bitShiftL: createBinop("<</>>/>>>", 8),
  bitShiftR: createBinop("<</>>/>>>", 8),
  plusMin: createToken("+/-", {
    beforeExpr,
    binop: 9,
    prefix,
    startsExpr
  }),
  modulo: createToken("%", {
    binop: 10,
    startsExpr
  }),
  star: createToken("*", {
    binop: 10
  }),
  slash: createBinop("/", 10),
  exponent: createToken("**", {
    beforeExpr,
    binop: 11,
    rightAssociative: !0
  }),
  _in: createKeyword("in", {
    beforeExpr,
    binop: 7
  }),
  _instanceof: createKeyword("instanceof", {
    beforeExpr,
    binop: 7
  }),
  _break: createKeyword("break"),
  _case: createKeyword("case", {
    beforeExpr
  }),
  _catch: createKeyword("catch"),
  _continue: createKeyword("continue"),
  _debugger: createKeyword("debugger"),
  _default: createKeyword("default", {
    beforeExpr
  }),
  _else: createKeyword("else", {
    beforeExpr
  }),
  _finally: createKeyword("finally"),
  _function: createKeyword("function", {
    startsExpr
  }),
  _if: createKeyword("if"),
  _return: createKeyword("return", {
    beforeExpr
  }),
  _switch: createKeyword("switch"),
  _throw: createKeyword("throw", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  _try: createKeyword("try"),
  _var: createKeyword("var"),
  _const: createKeyword("const"),
  _with: createKeyword("with"),
  _new: createKeyword("new", {
    beforeExpr,
    startsExpr
  }),
  _this: createKeyword("this", {
    startsExpr
  }),
  _super: createKeyword("super", {
    startsExpr
  }),
  _class: createKeyword("class", {
    startsExpr
  }),
  _extends: createKeyword("extends", {
    beforeExpr
  }),
  _export: createKeyword("export"),
  _import: createKeyword("import", {
    startsExpr
  }),
  _null: createKeyword("null", {
    startsExpr
  }),
  _true: createKeyword("true", {
    startsExpr
  }),
  _false: createKeyword("false", {
    startsExpr
  }),
  _typeof: createKeyword("typeof", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  _void: createKeyword("void", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  _delete: createKeyword("delete", {
    beforeExpr,
    prefix,
    startsExpr
  }),
  _do: createKeyword("do", {
    isLoop,
    beforeExpr
  }),
  _for: createKeyword("for", {
    isLoop
  }),
  _while: createKeyword("while", {
    isLoop
  }),
  _as: createKeywordLike("as", {
    startsExpr
  }),
  _assert: createKeywordLike("assert", {
    startsExpr
  }),
  _async: createKeywordLike("async", {
    startsExpr
  }),
  _await: createKeywordLike("await", {
    startsExpr
  }),
  _defer: createKeywordLike("defer", {
    startsExpr
  }),
  _from: createKeywordLike("from", {
    startsExpr
  }),
  _get: createKeywordLike("get", {
    startsExpr
  }),
  _let: createKeywordLike("let", {
    startsExpr
  }),
  _meta: createKeywordLike("meta", {
    startsExpr
  }),
  _of: createKeywordLike("of", {
    startsExpr
  }),
  _sent: createKeywordLike("sent", {
    startsExpr
  }),
  _set: createKeywordLike("set", {
    startsExpr
  }),
  _source: createKeywordLike("source", {
    startsExpr
  }),
  _static: createKeywordLike("static", {
    startsExpr
  }),
  _using: createKeywordLike("using", {
    startsExpr
  }),
  _yield: createKeywordLike("yield", {
    startsExpr
  }),
  _asserts: createKeywordLike("asserts", {
    startsExpr
  }),
  _checks: createKeywordLike("checks", {
    startsExpr
  }),
  _exports: createKeywordLike("exports", {
    startsExpr
  }),
  _global: createKeywordLike("global", {
    startsExpr
  }),
  _implements: createKeywordLike("implements", {
    startsExpr
  }),
  _intrinsic: createKeywordLike("intrinsic", {
    startsExpr
  }),
  _infer: createKeywordLike("infer", {
    startsExpr
  }),
  _is: createKeywordLike("is", {
    startsExpr
  }),
  _mixins: createKeywordLike("mixins", {
    startsExpr
  }),
  _proto: createKeywordLike("proto", {
    startsExpr
  }),
  _require: createKeywordLike("require", {
    startsExpr
  }),
  _satisfies: createKeywordLike("satisfies", {
    startsExpr
  }),
  _keyof: createKeywordLike("keyof", {
    startsExpr
  }),
  _readonly: createKeywordLike("readonly", {
    startsExpr
  }),
  _unique: createKeywordLike("unique", {
    startsExpr
  }),
  _abstract: createKeywordLike("abstract", {
    startsExpr
  }),
  _declare: createKeywordLike("declare", {
    startsExpr
  }),
  _enum: createKeywordLike("enum", {
    startsExpr
  }),
  _module: createKeywordLike("module", {
    startsExpr
  }),
  _namespace: createKeywordLike("namespace", {
    startsExpr
  }),
  _interface: createKeywordLike("interface", {
    startsExpr
  }),
  _type: createKeywordLike("type", {
    startsExpr
  }),
  _opaque: createKeywordLike("opaque", {
    startsExpr
  }),
  name: createToken("name", {
    startsExpr
  }),
  string: createToken("string", {
    startsExpr
  }),
  num: createToken("num", {
    startsExpr
  }),
  bigint: createToken("bigint", {
    startsExpr
  }),
  decimal: createToken("decimal", {
    startsExpr
  }),
  regexp: createToken("regexp", {
    startsExpr
  }),
  privateName: createToken("#name", {
    startsExpr
  }),
  eof: createToken("eof"),
  jsxName: createToken("jsxName"),
  jsxText: createToken("jsxText", {
    beforeExpr: !0
  }),
  jsxTagStart: createToken("jsxTagStart", {
    startsExpr: !0
  }),
  jsxTagEnd: createToken("jsxTagEnd"),
  placeholder: createToken("%%", {
    startsExpr: !0
  })
};
function tokenIsIdentifier(e) {
  return e >= 93 && e <= 132;
}
function tokenKeywordOrIdentifierIsKeyword(e) {
  return e <= 92;
}
function tokenIsKeywordOrIdentifier(e) {
  return e >= 58 && e <= 132;
}
function tokenIsLiteralPropertyName(e) {
  return e >= 58 && e <= 136;
}
function tokenComesBeforeExpression(e) {
  return tokenBeforeExprs[e];
}
function tokenCanStartExpression(e) {
  return tokenStartsExprs[e];
}
function tokenIsAssignment(e) {
  return e >= 29 && e <= 33;
}
function tokenIsFlowInterfaceOrTypeOrOpaque(e) {
  return e >= 129 && e <= 131;
}
function tokenIsLoop(e) {
  return e >= 90 && e <= 92;
}
function tokenIsKeyword(e) {
  return e >= 58 && e <= 92;
}
function tokenIsOperator(e) {
  return e >= 39 && e <= 59;
}
function tokenIsPostfix(e) {
  return e === 34;
}
function tokenIsPrefix(e) {
  return tokenPrefixes[e];
}
function tokenIsTSTypeOperator(e) {
  return e >= 121 && e <= 123;
}
function tokenIsTSDeclarationStart(e) {
  return e >= 124 && e <= 130;
}
function tokenLabelName(e) {
  return tokenLabels[e];
}
function tokenOperatorPrecedence(e) {
  return tokenBinops[e];
}
function tokenIsRightAssociative(e) {
  return e === 57;
}
function tokenIsTemplate(e) {
  return e >= 24 && e <= 25;
}
function getExportedToken(e) {
  return tokenTypes[e];
}
tokenTypes[8].updateContext = (e) => {
  e.pop();
}, tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (e) => {
  e.push(types.brace);
}, tokenTypes[22].updateContext = (e) => {
  e[e.length - 1] === types.template ? e.pop() : e.push(types.template);
}, tokenTypes[142].updateContext = (e) => {
  e.push(types.j_expr, types.j_oTag);
};
let nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
const nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
const astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function isInAstralSet(e, t) {
  let s = 65536;
  for (let i = 0, a = t.length; i < a; i += 2) {
    if (s += t[i], s > e)
      return !1;
    if (s += t[i + 1], s >= e)
      return !0;
  }
  return !1;
}
function isIdentifierStart(e) {
  return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(e)) : isInAstralSet(e, astralIdentifierStartCodes);
}
function isIdentifierChar(e) {
  return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && nonASCIIidentifier.test(String.fromCharCode(e)) : isInAstralSet(e, astralIdentifierStartCodes) || isInAstralSet(e, astralIdentifierCodes);
}
const reservedWords = {
  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
  strictBind: ["eval", "arguments"]
}, keywords = new Set(reservedWords.keyword), reservedWordsStrictSet = new Set(reservedWords.strict), reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
function isReservedWord(e, t) {
  return t && e === "await" || e === "enum";
}
function isStrictReservedWord(e, t) {
  return isReservedWord(e, t) || reservedWordsStrictSet.has(e);
}
function isStrictBindOnlyReservedWord(e) {
  return reservedWordsStrictBindSet.has(e);
}
function isStrictBindReservedWord(e, t) {
  return isStrictReservedWord(e, t) || isStrictBindOnlyReservedWord(e);
}
function isKeyword(e) {
  return keywords.has(e);
}
function isIteratorStart(e, t, s) {
  return e === 64 && t === 64 && isIdentifierStart(s);
}
const reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
function canBeReservedWord(e) {
  return reservedWordLikeSet.has(e);
}
class Scope {
  constructor(t) {
    this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = t;
  }
}
class ScopeHandler {
  constructor(t, s) {
    this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t, this.inModule = s;
  }
  get inTopLevel() {
    return (this.currentScope().flags & 1) > 0;
  }
  get inFunction() {
    return (this.currentVarScopeFlags() & 2) > 0;
  }
  get allowSuper() {
    return (this.currentThisScopeFlags() & 16) > 0;
  }
  get allowDirectSuper() {
    return (this.currentThisScopeFlags() & 32) > 0;
  }
  get inClass() {
    return (this.currentThisScopeFlags() & 64) > 0;
  }
  get inClassAndNotInNonArrowFunction() {
    const t = this.currentThisScopeFlags();
    return (t & 64) > 0 && (t & 2) === 0;
  }
  get inStaticBlock() {
    for (let t = this.scopeStack.length - 1; ; t--) {
      const {
        flags: s
      } = this.scopeStack[t];
      if (s & 128)
        return !0;
      if (s & 451)
        return !1;
    }
  }
  get inNonArrowFunction() {
    return (this.currentThisScopeFlags() & 2) > 0;
  }
  get treatFunctionsAsVar() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  }
  createScope(t) {
    return new Scope(t);
  }
  enter(t) {
    this.scopeStack.push(this.createScope(t));
  }
  exit() {
    return this.scopeStack.pop().flags;
  }
  treatFunctionsAsVarInScope(t) {
    return !!(t.flags & 130 || !this.parser.inModule && t.flags & 1);
  }
  declareName(t, s, i) {
    let a = this.currentScope();
    if (s & 8 || s & 16)
      this.checkRedeclarationInScope(a, t, s, i), s & 16 ? a.functions.add(t) : a.lexical.add(t), s & 8 && this.maybeExportDefined(a, t);
    else if (s & 4)
      for (let o = this.scopeStack.length - 1; o >= 0 && (a = this.scopeStack[o], this.checkRedeclarationInScope(a, t, s, i), a.var.add(t), this.maybeExportDefined(a, t), !(a.flags & 387)); --o)
        ;
    this.parser.inModule && a.flags & 1 && this.undefinedExports.delete(t);
  }
  maybeExportDefined(t, s) {
    this.parser.inModule && t.flags & 1 && this.undefinedExports.delete(s);
  }
  checkRedeclarationInScope(t, s, i, a) {
    this.isRedeclaredInScope(t, s, i) && this.parser.raise(Errors.VarRedeclaration, {
      at: a,
      identifierName: s
    });
  }
  isRedeclaredInScope(t, s, i) {
    return i & 1 ? i & 8 ? t.lexical.has(s) || t.functions.has(s) || t.var.has(s) : i & 16 ? t.lexical.has(s) || !this.treatFunctionsAsVarInScope(t) && t.var.has(s) : t.lexical.has(s) && !(t.flags & 8 && t.lexical.values().next().value === s) || !this.treatFunctionsAsVarInScope(t) && t.functions.has(s) : !1;
  }
  checkLocalExport(t) {
    const {
      name: s
    } = t, i = this.scopeStack[0];
    !i.lexical.has(s) && !i.var.has(s) && !i.functions.has(s) && this.undefinedExports.set(s, t.loc.start);
  }
  currentScope() {
    return this.scopeStack[this.scopeStack.length - 1];
  }
  currentVarScopeFlags() {
    for (let t = this.scopeStack.length - 1; ; t--) {
      const {
        flags: s
      } = this.scopeStack[t];
      if (s & 387)
        return s;
    }
  }
  currentThisScopeFlags() {
    for (let t = this.scopeStack.length - 1; ; t--) {
      const {
        flags: s
      } = this.scopeStack[t];
      if (s & 451 && !(s & 4))
        return s;
    }
  }
}
class FlowScope extends Scope {
  constructor(...t) {
    super(...t), this.declareFunctions = /* @__PURE__ */ new Set();
  }
}
class FlowScopeHandler extends ScopeHandler {
  createScope(t) {
    return new FlowScope(t);
  }
  declareName(t, s, i) {
    const a = this.currentScope();
    if (s & 2048) {
      this.checkRedeclarationInScope(a, t, s, i), this.maybeExportDefined(a, t), a.declareFunctions.add(t);
      return;
    }
    super.declareName(t, s, i);
  }
  isRedeclaredInScope(t, s, i) {
    return super.isRedeclaredInScope(t, s, i) ? !0 : i & 2048 ? !t.declareFunctions.has(s) && (t.lexical.has(s) || t.functions.has(s)) : !1;
  }
  checkLocalExport(t) {
    this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
  }
}
class BaseParser {
  constructor() {
    this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
  }
  hasPlugin(t) {
    if (typeof t == "string")
      return this.plugins.has(t);
    {
      const [s, i] = t;
      if (!this.hasPlugin(s))
        return !1;
      const a = this.plugins.get(s);
      for (const o of Object.keys(i))
        if ((a == null ? void 0 : a[o]) !== i[o])
          return !1;
      return !0;
    }
  }
  getPluginOption(t, s) {
    var i;
    return (i = this.plugins.get(t)) == null ? void 0 : i[s];
  }
}
function setTrailingComments(e, t) {
  e.trailingComments === void 0 ? e.trailingComments = t : e.trailingComments.unshift(...t);
}
function setLeadingComments(e, t) {
  e.leadingComments === void 0 ? e.leadingComments = t : e.leadingComments.unshift(...t);
}
function setInnerComments(e, t) {
  e.innerComments === void 0 ? e.innerComments = t : e.innerComments.unshift(...t);
}
function adjustInnerComments(e, t, s) {
  let i = null, a = t.length;
  for (; i === null && a > 0; )
    i = t[--a];
  i === null || i.start > s.start ? setInnerComments(e, s.comments) : setTrailingComments(i, s.comments);
}
class CommentsParser extends BaseParser {
  addComment(t) {
    this.filename && (t.loc.filename = this.filename), this.state.comments.push(t);
  }
  processComment(t) {
    const {
      commentStack: s
    } = this.state, i = s.length;
    if (i === 0)
      return;
    let a = i - 1;
    const o = s[a];
    o.start === t.end && (o.leadingNode = t, a--);
    const {
      start: l
    } = t;
    for (; a >= 0; a--) {
      const f = s[a], y = f.end;
      if (y > l)
        f.containingNode = t, this.finalizeComment(f), s.splice(a, 1);
      else {
        y === l && (f.trailingNode = t);
        break;
      }
    }
  }
  finalizeComment(t) {
    const {
      comments: s
    } = t;
    if (t.leadingNode !== null || t.trailingNode !== null)
      t.leadingNode !== null && setTrailingComments(t.leadingNode, s), t.trailingNode !== null && setLeadingComments(t.trailingNode, s);
    else {
      const {
        containingNode: i,
        start: a
      } = t;
      if (this.input.charCodeAt(a - 1) === 44)
        switch (i.type) {
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            adjustInnerComments(i, i.properties, t);
            break;
          case "CallExpression":
          case "OptionalCallExpression":
            adjustInnerComments(i, i.arguments, t);
            break;
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
          case "ObjectMethod":
          case "ClassMethod":
          case "ClassPrivateMethod":
            adjustInnerComments(i, i.params, t);
            break;
          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            adjustInnerComments(i, i.elements, t);
            break;
          case "ExportNamedDeclaration":
          case "ImportDeclaration":
            adjustInnerComments(i, i.specifiers, t);
            break;
          default:
            setInnerComments(i, s);
        }
      else
        setInnerComments(i, s);
    }
  }
  finalizeRemainingComments() {
    const {
      commentStack: t
    } = this.state;
    for (let s = t.length - 1; s >= 0; s--)
      this.finalizeComment(t[s]);
    this.state.commentStack = [];
  }
  resetPreviousNodeTrailingComments(t) {
    const {
      commentStack: s
    } = this.state, {
      length: i
    } = s;
    if (i === 0)
      return;
    const a = s[i - 1];
    a.leadingNode === t && (a.leadingNode = null);
  }
  resetPreviousIdentifierLeadingComments(t) {
    const {
      commentStack: s
    } = this.state, {
      length: i
    } = s;
    i !== 0 && (s[i - 1].trailingNode === t ? s[i - 1].trailingNode = null : i >= 2 && s[i - 2].trailingNode === t && (s[i - 2].trailingNode = null));
  }
  takeSurroundingComments(t, s, i) {
    const {
      commentStack: a
    } = this.state, o = a.length;
    if (o === 0)
      return;
    let l = o - 1;
    for (; l >= 0; l--) {
      const f = a[l], y = f.end;
      if (f.start === i)
        f.leadingNode = t;
      else if (y === s)
        f.trailingNode = t;
      else if (y < s)
        break;
    }
  }
}
const lineBreak = /\r\n?|[\n\u2028\u2029]/, lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(e) {
  switch (e) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return !0;
    default:
      return !1;
  }
}
const skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
function isWhitespace(e) {
  switch (e) {
    case 9:
    case 11:
    case 12:
    case 32:
    case 160:
    case 5760:
    case 8192:
    case 8193:
    case 8194:
    case 8195:
    case 8196:
    case 8197:
    case 8198:
    case 8199:
    case 8200:
    case 8201:
    case 8202:
    case 8239:
    case 8287:
    case 12288:
    case 65279:
      return !0;
    default:
      return !1;
  }
}
class State {
  constructor() {
    this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = !1, this.inType = !1, this.noAnonFunctionType = !1, this.hasFlowComment = !1, this.isAmbientContext = !1, this.inAbstractClass = !1, this.inDisallowConditionalTypesContext = !1, this.topicContext = {
      maxNumOfResolvableTopics: 0,
      maxTopicIndex: null
    }, this.soloAwait = !1, this.inFSharpPipelineDirectBody = !1, this.labels = [], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [types.brace], this.canStartJSXElement = !0, this.containsEsc = !1, this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
  }
  init({
    strictMode: t,
    sourceType: s,
    startLine: i,
    startColumn: a
  }) {
    this.strict = t === !1 ? !1 : t === !0 ? !0 : s === "module", this.curLine = i, this.lineStart = -a, this.startLoc = this.endLoc = new Position(i, a, 0);
  }
  curPosition() {
    return new Position(this.curLine, this.pos - this.lineStart, this.pos);
  }
  clone(t) {
    const s = new State(), i = Object.keys(this);
    for (let a = 0, o = i.length; a < o; a++) {
      const l = i[a];
      let f = this[l];
      !t && Array.isArray(f) && (f = f.slice()), s[l] = f;
    }
    return s;
  }
}
var _isDigit = function(t) {
  return t >= 48 && t <= 57;
};
const forbiddenNumericSeparatorSiblings = {
  decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
  hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
}, isAllowedNumericSeparatorSibling = {
  bin: (e) => e === 48 || e === 49,
  oct: (e) => e >= 48 && e <= 55,
  dec: (e) => e >= 48 && e <= 57,
  hex: (e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102
};
function readStringContents(e, t, s, i, a, o) {
  const l = s, f = i, y = a;
  let g = "", T = null, S = s;
  const {
    length: b
  } = t;
  for (; ; ) {
    if (s >= b) {
      o.unterminated(l, f, y), g += t.slice(S, s);
      break;
    }
    const v = t.charCodeAt(s);
    if (isStringEnd(e, v, t, s)) {
      g += t.slice(S, s);
      break;
    }
    if (v === 92) {
      g += t.slice(S, s);
      const $ = readEscapedChar(t, s, i, a, e === "template", o);
      $.ch === null && !T ? T = {
        pos: s,
        lineStart: i,
        curLine: a
      } : g += $.ch, {
        pos: s,
        lineStart: i,
        curLine: a
      } = $, S = s;
    } else
      v === 8232 || v === 8233 ? (++s, ++a, i = s) : v === 10 || v === 13 ? e === "template" ? (g += t.slice(S, s) + `
`, ++s, v === 13 && t.charCodeAt(s) === 10 && ++s, ++a, S = i = s) : o.unterminated(l, f, y) : ++s;
  }
  return {
    pos: s,
    str: g,
    firstInvalidLoc: T,
    lineStart: i,
    curLine: a,
    containsInvalid: !!T
  };
}
function isStringEnd(e, t, s, i) {
  return e === "template" ? t === 96 || t === 36 && s.charCodeAt(i + 1) === 123 : t === (e === "double" ? 34 : 39);
}
function readEscapedChar(e, t, s, i, a, o) {
  const l = !a;
  t++;
  const f = (g) => ({
    pos: t,
    ch: g,
    lineStart: s,
    curLine: i
  }), y = e.charCodeAt(t++);
  switch (y) {
    case 110:
      return f(`
`);
    case 114:
      return f("\r");
    case 120: {
      let g;
      return {
        code: g,
        pos: t
      } = readHexChar(e, t, s, i, 2, !1, l, o), f(g === null ? null : String.fromCharCode(g));
    }
    case 117: {
      let g;
      return {
        code: g,
        pos: t
      } = readCodePoint(e, t, s, i, l, o), f(g === null ? null : String.fromCodePoint(g));
    }
    case 116:
      return f("	");
    case 98:
      return f("\b");
    case 118:
      return f("\v");
    case 102:
      return f("\f");
    case 13:
      e.charCodeAt(t) === 10 && ++t;
    case 10:
      s = t, ++i;
    case 8232:
    case 8233:
      return f("");
    case 56:
    case 57:
      if (a)
        return f(null);
      o.strictNumericEscape(t - 1, s, i);
    default:
      if (y >= 48 && y <= 55) {
        const g = t - 1;
        let S = e.slice(g, t + 2).match(/^[0-7]+/)[0], b = parseInt(S, 8);
        b > 255 && (S = S.slice(0, -1), b = parseInt(S, 8)), t += S.length - 1;
        const v = e.charCodeAt(t);
        if (S !== "0" || v === 56 || v === 57) {
          if (a)
            return f(null);
          o.strictNumericEscape(g, s, i);
        }
        return f(String.fromCharCode(b));
      }
      return f(String.fromCharCode(y));
  }
}
function readHexChar(e, t, s, i, a, o, l, f) {
  const y = t;
  let g;
  return {
    n: g,
    pos: t
  } = readInt(e, t, s, i, 16, a, o, !1, f, !l), g === null && (l ? f.invalidEscapeSequence(y, s, i) : t = y - 1), {
    code: g,
    pos: t
  };
}
function readInt(e, t, s, i, a, o, l, f, y, g) {
  const T = t, S = a === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct, b = a === 16 ? isAllowedNumericSeparatorSibling.hex : a === 10 ? isAllowedNumericSeparatorSibling.dec : a === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
  let v = !1, $ = 0;
  for (let U = 0, X = o ?? 1 / 0; U < X; ++U) {
    const k = e.charCodeAt(t);
    let D;
    if (k === 95 && f !== "bail") {
      const B = e.charCodeAt(t - 1), Z = e.charCodeAt(t + 1);
      if (f) {
        if (Number.isNaN(Z) || !b(Z) || S.has(B) || S.has(Z)) {
          if (g)
            return {
              n: null,
              pos: t
            };
          y.unexpectedNumericSeparator(t, s, i);
        }
      } else {
        if (g)
          return {
            n: null,
            pos: t
          };
        y.numericSeparatorInEscapeSequence(t, s, i);
      }
      ++t;
      continue;
    }
    if (k >= 97 ? D = k - 97 + 10 : k >= 65 ? D = k - 65 + 10 : _isDigit(k) ? D = k - 48 : D = 1 / 0, D >= a) {
      if (D <= 9 && g)
        return {
          n: null,
          pos: t
        };
      if (D <= 9 && y.invalidDigit(t, s, i, a))
        D = 0;
      else if (l)
        D = 0, v = !0;
      else
        break;
    }
    ++t, $ = $ * a + D;
  }
  return t === T || o != null && t - T !== o || v ? {
    n: null,
    pos: t
  } : {
    n: $,
    pos: t
  };
}
function readCodePoint(e, t, s, i, a, o) {
  const l = e.charCodeAt(t);
  let f;
  if (l === 123) {
    if (++t, {
      code: f,
      pos: t
    } = readHexChar(e, t, s, i, e.indexOf("}", t) - t, !0, a, o), ++t, f !== null && f > 1114111)
      if (a)
        o.invalidCodePoint(t, s, i);
      else
        return {
          code: null,
          pos: t
        };
  } else
    ({
      code: f,
      pos: t
    } = readHexChar(e, t, s, i, 4, !1, a, o));
  return {
    code: f,
    pos: t
  };
}
const _excluded$2 = ["at"], _excluded2 = ["at"];
function buildPosition(e, t, s) {
  return new Position(s, e - t, e);
}
const VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
class Token {
  constructor(t) {
    this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new SourceLocation(t.startLoc, t.endLoc);
  }
}
class Tokenizer extends CommentsParser {
  constructor(t, s) {
    super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
      invalidDigit: (i, a, o, l) => this.options.errorRecovery ? (this.raise(Errors.InvalidDigit, {
        at: buildPosition(i, a, o),
        radix: l
      }), !0) : !1,
      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
    }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
    }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
      strictNumericEscape: (i, a, o) => {
        this.recordStrictModeErrors(Errors.StrictNumericEscape, {
          at: buildPosition(i, a, o)
        });
      },
      unterminated: (i, a, o) => {
        throw this.raise(Errors.UnterminatedString, {
          at: buildPosition(i - 1, a, o)
        });
      }
    }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
      unterminated: (i, a, o) => {
        throw this.raise(Errors.UnterminatedTemplate, {
          at: buildPosition(i, a, o)
        });
      }
    }), this.state = new State(), this.state.init(t), this.input = s, this.length = s.length, this.isLookahead = !1;
  }
  pushToken(t) {
    this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
  }
  next() {
    this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Token(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
  }
  eat(t) {
    return this.match(t) ? (this.next(), !0) : !1;
  }
  match(t) {
    return this.state.type === t;
  }
  createLookaheadState(t) {
    return {
      pos: t.pos,
      value: null,
      type: t.type,
      start: t.start,
      end: t.end,
      context: [this.curContext()],
      inType: t.inType,
      startLoc: t.startLoc,
      lastTokEndLoc: t.lastTokEndLoc,
      curLine: t.curLine,
      lineStart: t.lineStart,
      curPosition: t.curPosition
    };
  }
  lookahead() {
    const t = this.state;
    this.state = this.createLookaheadState(t), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
    const s = this.state;
    return this.state = t, s;
  }
  nextTokenStart() {
    return this.nextTokenStartSince(this.state.pos);
  }
  nextTokenStartSince(t) {
    return skipWhiteSpace.lastIndex = t, skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : t;
  }
  lookaheadCharCode() {
    return this.input.charCodeAt(this.nextTokenStart());
  }
  nextTokenInLineStart() {
    return this.nextTokenInLineStartSince(this.state.pos);
  }
  nextTokenInLineStartSince(t) {
    return skipWhiteSpaceInLine.lastIndex = t, skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : t;
  }
  lookaheadInLineCharCode() {
    return this.input.charCodeAt(this.nextTokenInLineStart());
  }
  codePointAtPos(t) {
    let s = this.input.charCodeAt(t);
    if ((s & 64512) === 55296 && ++t < this.input.length) {
      const i = this.input.charCodeAt(t);
      (i & 64512) === 56320 && (s = 65536 + ((s & 1023) << 10) + (i & 1023));
    }
    return s;
  }
  setStrict(t) {
    this.state.strict = t, t && (this.state.strictErrors.forEach(([s, i]) => this.raise(s, {
      at: i
    })), this.state.strictErrors.clear());
  }
  curContext() {
    return this.state.context[this.state.context.length - 1];
  }
  nextToken() {
    if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
      this.finishToken(139);
      return;
    }
    this.getTokenFromCode(this.codePointAtPos(this.state.pos));
  }
  skipBlockComment(t) {
    let s;
    this.isLookahead || (s = this.state.curPosition());
    const i = this.state.pos, a = this.input.indexOf(t, i + 2);
    if (a === -1)
      throw this.raise(Errors.UnterminatedComment, {
        at: this.state.curPosition()
      });
    for (this.state.pos = a + t.length, lineBreakG.lastIndex = i + 2; lineBreakG.test(this.input) && lineBreakG.lastIndex <= a; )
      ++this.state.curLine, this.state.lineStart = lineBreakG.lastIndex;
    if (this.isLookahead)
      return;
    const o = {
      type: "CommentBlock",
      value: this.input.slice(i + 2, a),
      start: i,
      end: a + t.length,
      loc: new SourceLocation(s, this.state.curPosition())
    };
    return this.options.tokens && this.pushToken(o), o;
  }
  skipLineComment(t) {
    const s = this.state.pos;
    let i;
    this.isLookahead || (i = this.state.curPosition());
    let a = this.input.charCodeAt(this.state.pos += t);
    if (this.state.pos < this.length)
      for (; !isNewLine(a) && ++this.state.pos < this.length; )
        a = this.input.charCodeAt(this.state.pos);
    if (this.isLookahead)
      return;
    const o = this.state.pos, f = {
      type: "CommentLine",
      value: this.input.slice(s + t, o),
      start: s,
      end: o,
      loc: new SourceLocation(i, this.state.curPosition())
    };
    return this.options.tokens && this.pushToken(f), f;
  }
  skipSpace() {
    const t = this.state.pos, s = [];
    e:
      for (; this.state.pos < this.length; ) {
        const i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                const a = this.skipBlockComment("*/");
                a !== void 0 && (this.addComment(a), this.options.attachComment && s.push(a));
                break;
              }
              case 47: {
                const a = this.skipLineComment(2);
                a !== void 0 && (this.addComment(a), this.options.attachComment && s.push(a));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (isWhitespace(i))
              ++this.state.pos;
            else if (i === 45 && !this.inModule && this.options.annexB) {
              const a = this.state.pos;
              if (this.input.charCodeAt(a + 1) === 45 && this.input.charCodeAt(a + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                const o = this.skipLineComment(3);
                o !== void 0 && (this.addComment(o), this.options.attachComment && s.push(o));
              } else
                break e;
            } else if (i === 60 && !this.inModule && this.options.annexB) {
              const a = this.state.pos;
              if (this.input.charCodeAt(a + 1) === 33 && this.input.charCodeAt(a + 2) === 45 && this.input.charCodeAt(a + 3) === 45) {
                const o = this.skipLineComment(4);
                o !== void 0 && (this.addComment(o), this.options.attachComment && s.push(o));
              } else
                break e;
            } else
              break e;
        }
      }
    if (s.length > 0) {
      const i = this.state.pos, a = {
        start: t,
        end: i,
        comments: s,
        leadingNode: null,
        trailingNode: null,
        containingNode: null
      };
      this.state.commentStack.push(a);
    }
  }
  finishToken(t, s) {
    this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
    const i = this.state.type;
    this.state.type = t, this.state.value = s, this.isLookahead || this.updateContext(i);
  }
  replaceToken(t) {
    this.state.type = t, this.updateContext();
  }
  readToken_numberSign() {
    if (this.state.pos === 0 && this.readToken_interpreter())
      return;
    const t = this.state.pos + 1, s = this.codePointAtPos(t);
    if (s >= 48 && s <= 57)
      throw this.raise(Errors.UnexpectedDigitAfterHash, {
        at: this.state.curPosition()
      });
    if (s === 123 || s === 91 && this.hasPlugin("recordAndTuple")) {
      if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
        throw this.raise(s === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, {
          at: this.state.curPosition()
        });
      this.state.pos += 2, s === 123 ? this.finishToken(7) : this.finishToken(1);
    } else
      isIdentifierStart(s) ? (++this.state.pos, this.finishToken(138, this.readWord1(s))) : s === 92 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
  }
  readToken_dot() {
    const t = this.input.charCodeAt(this.state.pos + 1);
    if (t >= 48 && t <= 57) {
      this.readNumber(!0);
      return;
    }
    t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
  }
  readToken_slash() {
    this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
  }
  readToken_interpreter() {
    if (this.state.pos !== 0 || this.length < 2)
      return !1;
    let t = this.input.charCodeAt(this.state.pos + 1);
    if (t !== 33)
      return !1;
    const s = this.state.pos;
    for (this.state.pos += 1; !isNewLine(t) && ++this.state.pos < this.length; )
      t = this.input.charCodeAt(this.state.pos);
    const i = this.input.slice(s + 2, this.state.pos);
    return this.finishToken(28, i), !0;
  }
  readToken_mult_modulo(t) {
    let s = t === 42 ? 55 : 54, i = 1, a = this.input.charCodeAt(this.state.pos + 1);
    t === 42 && a === 42 && (i++, a = this.input.charCodeAt(this.state.pos + 2), s = 57), a === 61 && !this.state.inType && (i++, s = t === 37 ? 33 : 30), this.finishOp(s, i);
  }
  readToken_pipe_amp(t) {
    const s = this.input.charCodeAt(this.state.pos + 1);
    if (s === t) {
      this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
      return;
    }
    if (t === 124) {
      if (s === 62) {
        this.finishOp(39, 2);
        return;
      }
      if (this.hasPlugin("recordAndTuple") && s === 125) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, {
            at: this.state.curPosition()
          });
        this.state.pos += 2, this.finishToken(9);
        return;
      }
      if (this.hasPlugin("recordAndTuple") && s === 93) {
        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, {
            at: this.state.curPosition()
          });
        this.state.pos += 2, this.finishToken(4);
        return;
      }
    }
    if (s === 61) {
      this.finishOp(30, 2);
      return;
    }
    this.finishOp(t === 124 ? 43 : 45, 1);
  }
  readToken_caret() {
    const t = this.input.charCodeAt(this.state.pos + 1);
    t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", {
      proposal: "hack",
      topicToken: "^^"
    }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
  }
  readToken_atSign() {
    this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
      proposal: "hack",
      topicToken: "@@"
    }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
  }
  readToken_plus_min(t) {
    const s = this.input.charCodeAt(this.state.pos + 1);
    if (s === t) {
      this.finishOp(34, 2);
      return;
    }
    s === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
  }
  readToken_lt() {
    const {
      pos: t
    } = this.state, s = this.input.charCodeAt(t + 1);
    if (s === 60) {
      if (this.input.charCodeAt(t + 2) === 61) {
        this.finishOp(30, 3);
        return;
      }
      this.finishOp(51, 2);
      return;
    }
    if (s === 61) {
      this.finishOp(49, 2);
      return;
    }
    this.finishOp(47, 1);
  }
  readToken_gt() {
    const {
      pos: t
    } = this.state, s = this.input.charCodeAt(t + 1);
    if (s === 62) {
      const i = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(t + i) === 61) {
        this.finishOp(30, i + 1);
        return;
      }
      this.finishOp(52, i);
      return;
    }
    if (s === 61) {
      this.finishOp(49, 2);
      return;
    }
    this.finishOp(48, 1);
  }
  readToken_eq_excl(t) {
    const s = this.input.charCodeAt(this.state.pos + 1);
    if (s === 61) {
      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
      return;
    }
    if (t === 61 && s === 62) {
      this.state.pos += 2, this.finishToken(19);
      return;
    }
    this.finishOp(t === 61 ? 29 : 35, 1);
  }
  readToken_question() {
    const t = this.input.charCodeAt(this.state.pos + 1), s = this.input.charCodeAt(this.state.pos + 2);
    t === 63 ? s === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(s >= 48 && s <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
  }
  getTokenFromCode(t) {
    switch (t) {
      case 46:
        this.readToken_dot();
        return;
      case 40:
        ++this.state.pos, this.finishToken(10);
        return;
      case 41:
        ++this.state.pos, this.finishToken(11);
        return;
      case 59:
        ++this.state.pos, this.finishToken(13);
        return;
      case 44:
        ++this.state.pos, this.finishToken(12);
        return;
      case 91:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, {
              at: this.state.curPosition()
            });
          this.state.pos += 2, this.finishToken(2);
        } else
          ++this.state.pos, this.finishToken(0);
        return;
      case 93:
        ++this.state.pos, this.finishToken(3);
        return;
      case 123:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, {
              at: this.state.curPosition()
            });
          this.state.pos += 2, this.finishToken(6);
        } else
          ++this.state.pos, this.finishToken(5);
        return;
      case 125:
        ++this.state.pos, this.finishToken(8);
        return;
      case 58:
        this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
        return;
      case 63:
        this.readToken_question();
        return;
      case 96:
        this.readTemplateToken();
        return;
      case 48: {
        const s = this.input.charCodeAt(this.state.pos + 1);
        if (s === 120 || s === 88) {
          this.readRadixNumber(16);
          return;
        }
        if (s === 111 || s === 79) {
          this.readRadixNumber(8);
          return;
        }
        if (s === 98 || s === 66) {
          this.readRadixNumber(2);
          return;
        }
      }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        this.readNumber(!1);
        return;
      case 34:
      case 39:
        this.readString(t);
        return;
      case 47:
        this.readToken_slash();
        return;
      case 37:
      case 42:
        this.readToken_mult_modulo(t);
        return;
      case 124:
      case 38:
        this.readToken_pipe_amp(t);
        return;
      case 94:
        this.readToken_caret();
        return;
      case 43:
      case 45:
        this.readToken_plus_min(t);
        return;
      case 60:
        this.readToken_lt();
        return;
      case 62:
        this.readToken_gt();
        return;
      case 61:
      case 33:
        this.readToken_eq_excl(t);
        return;
      case 126:
        this.finishOp(36, 1);
        return;
      case 64:
        this.readToken_atSign();
        return;
      case 35:
        this.readToken_numberSign();
        return;
      case 92:
        this.readWord();
        return;
      default:
        if (isIdentifierStart(t)) {
          this.readWord(t);
          return;
        }
    }
    throw this.raise(Errors.InvalidOrUnexpectedToken, {
      at: this.state.curPosition(),
      unexpected: String.fromCodePoint(t)
    });
  }
  finishOp(t, s) {
    const i = this.input.slice(this.state.pos, this.state.pos + s);
    this.state.pos += s, this.finishToken(t, i);
  }
  readRegexp() {
    const t = this.state.startLoc, s = this.state.start + 1;
    let i, a, {
      pos: o
    } = this.state;
    for (; ; ++o) {
      if (o >= this.length)
        throw this.raise(Errors.UnterminatedRegExp, {
          at: createPositionWithColumnOffset(t, 1)
        });
      const g = this.input.charCodeAt(o);
      if (isNewLine(g))
        throw this.raise(Errors.UnterminatedRegExp, {
          at: createPositionWithColumnOffset(t, 1)
        });
      if (i)
        i = !1;
      else {
        if (g === 91)
          a = !0;
        else if (g === 93 && a)
          a = !1;
        else if (g === 47 && !a)
          break;
        i = g === 92;
      }
    }
    const l = this.input.slice(s, o);
    ++o;
    let f = "";
    const y = () => createPositionWithColumnOffset(t, o + 2 - s);
    for (; o < this.length; ) {
      const g = this.codePointAtPos(o), T = String.fromCharCode(g);
      if (VALID_REGEX_FLAGS.has(g))
        g === 118 ? f.includes("u") && this.raise(Errors.IncompatibleRegExpUVFlags, {
          at: y()
        }) : g === 117 && f.includes("v") && this.raise(Errors.IncompatibleRegExpUVFlags, {
          at: y()
        }), f.includes(T) && this.raise(Errors.DuplicateRegExpFlags, {
          at: y()
        });
      else if (isIdentifierChar(g) || g === 92)
        this.raise(Errors.MalformedRegExpFlags, {
          at: y()
        });
      else
        break;
      ++o, f += T;
    }
    this.state.pos = o, this.finishToken(137, {
      pattern: l,
      flags: f
    });
  }
  readInt(t, s, i = !1, a = !0) {
    const {
      n: o,
      pos: l
    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, s, i, a, this.errorHandlers_readInt, !1);
    return this.state.pos = l, o;
  }
  readRadixNumber(t) {
    const s = this.state.curPosition();
    let i = !1;
    this.state.pos += 2;
    const a = this.readInt(t);
    a == null && this.raise(Errors.InvalidDigit, {
      at: createPositionWithColumnOffset(s, 2),
      radix: t
    });
    const o = this.input.charCodeAt(this.state.pos);
    if (o === 110)
      ++this.state.pos, i = !0;
    else if (o === 109)
      throw this.raise(Errors.InvalidDecimal, {
        at: s
      });
    if (isIdentifierStart(this.codePointAtPos(this.state.pos)))
      throw this.raise(Errors.NumberIdentifier, {
        at: this.state.curPosition()
      });
    if (i) {
      const l = this.input.slice(s.index, this.state.pos).replace(/[_n]/g, "");
      this.finishToken(135, l);
      return;
    }
    this.finishToken(134, a);
  }
  readNumber(t) {
    const s = this.state.pos, i = this.state.curPosition();
    let a = !1, o = !1, l = !1, f = !1, y = !1;
    !t && this.readInt(10) === null && this.raise(Errors.InvalidNumber, {
      at: this.state.curPosition()
    });
    const g = this.state.pos - s >= 2 && this.input.charCodeAt(s) === 48;
    if (g) {
      const v = this.input.slice(s, this.state.pos);
      if (this.recordStrictModeErrors(Errors.StrictOctalLiteral, {
        at: i
      }), !this.state.strict) {
        const $ = v.indexOf("_");
        $ > 0 && this.raise(Errors.ZeroDigitNumericSeparator, {
          at: createPositionWithColumnOffset(i, $)
        });
      }
      y = g && !/[89]/.test(v);
    }
    let T = this.input.charCodeAt(this.state.pos);
    if (T === 46 && !y && (++this.state.pos, this.readInt(10), a = !0, T = this.input.charCodeAt(this.state.pos)), (T === 69 || T === 101) && !y && (T = this.input.charCodeAt(++this.state.pos), (T === 43 || T === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(Errors.InvalidOrMissingExponent, {
      at: i
    }), a = !0, f = !0, T = this.input.charCodeAt(this.state.pos)), T === 110 && ((a || g) && this.raise(Errors.InvalidBigIntLiteral, {
      at: i
    }), ++this.state.pos, o = !0), T === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (f || g) && this.raise(Errors.InvalidDecimal, {
      at: i
    }), ++this.state.pos, l = !0), isIdentifierStart(this.codePointAtPos(this.state.pos)))
      throw this.raise(Errors.NumberIdentifier, {
        at: this.state.curPosition()
      });
    const S = this.input.slice(s, this.state.pos).replace(/[_mn]/g, "");
    if (o) {
      this.finishToken(135, S);
      return;
    }
    if (l) {
      this.finishToken(136, S);
      return;
    }
    const b = y ? parseInt(S, 8) : parseFloat(S);
    this.finishToken(134, b);
  }
  readCodePoint(t) {
    const {
      code: s,
      pos: i
    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
    return this.state.pos = i, s;
  }
  readString(t) {
    const {
      str: s,
      pos: i,
      curLine: a,
      lineStart: o
    } = readStringContents(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
    this.state.pos = i + 1, this.state.lineStart = o, this.state.curLine = a, this.finishToken(133, s);
  }
  readTemplateContinuation() {
    this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
  }
  readTemplateToken() {
    const t = this.input[this.state.pos], {
      str: s,
      firstInvalidLoc: i,
      pos: a,
      curLine: o,
      lineStart: l
    } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
    this.state.pos = a + 1, this.state.lineStart = l, this.state.curLine = o, i && (this.state.firstInvalidTemplateEscapePos = new Position(i.curLine, i.pos - i.lineStart, i.pos)), this.input.codePointAt(a) === 96 ? this.finishToken(24, i ? null : t + s + "`") : (this.state.pos++, this.finishToken(25, i ? null : t + s + "${"));
  }
  recordStrictModeErrors(t, {
    at: s
  }) {
    const i = s.index;
    this.state.strict && !this.state.strictErrors.has(i) ? this.raise(t, {
      at: s
    }) : this.state.strictErrors.set(i, [t, s]);
  }
  readWord1(t) {
    this.state.containsEsc = !1;
    let s = "";
    const i = this.state.pos;
    let a = this.state.pos;
    for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
      const o = this.codePointAtPos(this.state.pos);
      if (isIdentifierChar(o))
        this.state.pos += o <= 65535 ? 1 : 2;
      else if (o === 92) {
        this.state.containsEsc = !0, s += this.input.slice(a, this.state.pos);
        const l = this.state.curPosition(), f = this.state.pos === i ? isIdentifierStart : isIdentifierChar;
        if (this.input.charCodeAt(++this.state.pos) !== 117) {
          this.raise(Errors.MissingUnicodeEscape, {
            at: this.state.curPosition()
          }), a = this.state.pos - 1;
          continue;
        }
        ++this.state.pos;
        const y = this.readCodePoint(!0);
        y !== null && (f(y) || this.raise(Errors.EscapedCharNotAnIdentifier, {
          at: l
        }), s += String.fromCodePoint(y)), a = this.state.pos;
      } else
        break;
    }
    return s + this.input.slice(a, this.state.pos);
  }
  readWord(t) {
    const s = this.readWord1(t), i = keywords$1.get(s);
    i !== void 0 ? this.finishToken(i, tokenLabelName(i)) : this.finishToken(132, s);
  }
  checkKeywordEscapes() {
    const {
      type: t
    } = this.state;
    tokenIsKeyword(t) && this.state.containsEsc && this.raise(Errors.InvalidEscapedReservedWord, {
      at: this.state.startLoc,
      reservedWord: tokenLabelName(t)
    });
  }
  raise(t, s) {
    const {
      at: i
    } = s, a = _objectWithoutPropertiesLoose$1(s, _excluded$2), o = i instanceof Position ? i : i.loc.start, l = t({
      loc: o,
      details: a
    });
    if (!this.options.errorRecovery)
      throw l;
    return this.isLookahead || this.state.errors.push(l), l;
  }
  raiseOverwrite(t, s) {
    const {
      at: i
    } = s, a = _objectWithoutPropertiesLoose$1(s, _excluded2), o = i instanceof Position ? i : i.loc.start, l = o.index, f = this.state.errors;
    for (let y = f.length - 1; y >= 0; y--) {
      const g = f[y];
      if (g.loc.index === l)
        return f[y] = t({
          loc: o,
          details: a
        });
      if (g.loc.index < l)
        break;
    }
    return this.raise(t, s);
  }
  updateContext(t) {
  }
  unexpected(t, s) {
    throw this.raise(Errors.UnexpectedToken, {
      expected: s ? tokenLabelName(s) : null,
      at: t ?? this.state.startLoc
    });
  }
  expectPlugin(t, s) {
    if (this.hasPlugin(t))
      return !0;
    throw this.raise(Errors.MissingPlugin, {
      at: s ?? this.state.startLoc,
      missingPlugin: [t]
    });
  }
  expectOnePlugin(t) {
    if (!t.some((s) => this.hasPlugin(s)))
      throw this.raise(Errors.MissingOneOfPlugins, {
        at: this.state.startLoc,
        missingPlugin: t
      });
  }
  errorBuilder(t) {
    return (s, i, a) => {
      this.raise(t, {
        at: buildPosition(s, i, a)
      });
    };
  }
}
class ClassScope {
  constructor() {
    this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
  }
}
class ClassScopeHandler {
  constructor(t) {
    this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  enter() {
    this.stack.push(new ClassScope());
  }
  exit() {
    const t = this.stack.pop(), s = this.current();
    for (const [i, a] of Array.from(t.undefinedPrivateNames))
      s ? s.undefinedPrivateNames.has(i) || s.undefinedPrivateNames.set(i, a) : this.parser.raise(Errors.InvalidPrivateFieldResolution, {
        at: a,
        identifierName: i
      });
  }
  declarePrivateName(t, s, i) {
    const {
      privateNames: a,
      loneAccessors: o,
      undefinedPrivateNames: l
    } = this.current();
    let f = a.has(t);
    if (s & 3) {
      const y = f && o.get(t);
      if (y) {
        const g = y & 4, T = s & 4, S = y & 3, b = s & 3;
        f = S === b || g !== T, f || o.delete(t);
      } else
        f || o.set(t, s);
    }
    f && this.parser.raise(Errors.PrivateNameRedeclaration, {
      at: i,
      identifierName: t
    }), a.add(t), l.delete(t);
  }
  usePrivateName(t, s) {
    let i;
    for (i of this.stack)
      if (i.privateNames.has(t))
        return;
    i ? i.undefinedPrivateNames.set(t, s) : this.parser.raise(Errors.InvalidPrivateFieldResolution, {
      at: s,
      identifierName: t
    });
  }
}
class ExpressionScope {
  constructor(t = 0) {
    this.type = t;
  }
  canBeArrowParameterDeclaration() {
    return this.type === 2 || this.type === 1;
  }
  isCertainlyParameterDeclaration() {
    return this.type === 3;
  }
}
class ArrowHeadParsingScope extends ExpressionScope {
  constructor(t) {
    super(t), this.declarationErrors = /* @__PURE__ */ new Map();
  }
  recordDeclarationError(t, {
    at: s
  }) {
    const i = s.index;
    this.declarationErrors.set(i, [t, s]);
  }
  clearDeclarationError(t) {
    this.declarationErrors.delete(t);
  }
  iterateErrors(t) {
    this.declarationErrors.forEach(t);
  }
}
class ExpressionScopeHandler {
  constructor(t) {
    this.parser = void 0, this.stack = [new ExpressionScope()], this.parser = t;
  }
  enter(t) {
    this.stack.push(t);
  }
  exit() {
    this.stack.pop();
  }
  recordParameterInitializerError(t, {
    at: s
  }) {
    const i = {
      at: s.loc.start
    }, {
      stack: a
    } = this;
    let o = a.length - 1, l = a[o];
    for (; !l.isCertainlyParameterDeclaration(); ) {
      if (l.canBeArrowParameterDeclaration())
        l.recordDeclarationError(t, i);
      else
        return;
      l = a[--o];
    }
    this.parser.raise(t, i);
  }
  recordArrowParameterBindingError(t, {
    at: s
  }) {
    const {
      stack: i
    } = this, a = i[i.length - 1], o = {
      at: s.loc.start
    };
    if (a.isCertainlyParameterDeclaration())
      this.parser.raise(t, o);
    else if (a.canBeArrowParameterDeclaration())
      a.recordDeclarationError(t, o);
    else
      return;
  }
  recordAsyncArrowParametersError({
    at: t
  }) {
    const {
      stack: s
    } = this;
    let i = s.length - 1, a = s[i];
    for (; a.canBeArrowParameterDeclaration(); )
      a.type === 2 && a.recordDeclarationError(Errors.AwaitBindingIdentifier, {
        at: t
      }), a = s[--i];
  }
  validateAsPattern() {
    const {
      stack: t
    } = this, s = t[t.length - 1];
    s.canBeArrowParameterDeclaration() && s.iterateErrors(([i, a]) => {
      this.parser.raise(i, {
        at: a
      });
      let o = t.length - 2, l = t[o];
      for (; l.canBeArrowParameterDeclaration(); )
        l.clearDeclarationError(a.index), l = t[--o];
    });
  }
}
function newParameterDeclarationScope() {
  return new ExpressionScope(3);
}
function newArrowHeadScope() {
  return new ArrowHeadParsingScope(1);
}
function newAsyncArrowScope() {
  return new ArrowHeadParsingScope(2);
}
function newExpressionScope() {
  return new ExpressionScope();
}
class ProductionParameterHandler {
  constructor() {
    this.stacks = [];
  }
  enter(t) {
    this.stacks.push(t);
  }
  exit() {
    this.stacks.pop();
  }
  currentFlags() {
    return this.stacks[this.stacks.length - 1];
  }
  get hasAwait() {
    return (this.currentFlags() & 2) > 0;
  }
  get hasYield() {
    return (this.currentFlags() & 1) > 0;
  }
  get hasReturn() {
    return (this.currentFlags() & 4) > 0;
  }
  get hasIn() {
    return (this.currentFlags() & 8) > 0;
  }
}
function functionFlags(e, t) {
  return (e ? 2 : 0) | (t ? 1 : 0);
}
class UtilParser extends Tokenizer {
  addExtra(t, s, i, a = !0) {
    if (!t)
      return;
    const o = t.extra = t.extra || {};
    a ? o[s] = i : Object.defineProperty(o, s, {
      enumerable: a,
      value: i
    });
  }
  isContextual(t) {
    return this.state.type === t && !this.state.containsEsc;
  }
  isUnparsedContextual(t, s) {
    const i = t + s.length;
    if (this.input.slice(t, i) === s) {
      const a = this.input.charCodeAt(i);
      return !(isIdentifierChar(a) || (a & 64512) === 55296);
    }
    return !1;
  }
  isLookaheadContextual(t) {
    const s = this.nextTokenStart();
    return this.isUnparsedContextual(s, t);
  }
  eatContextual(t) {
    return this.isContextual(t) ? (this.next(), !0) : !1;
  }
  expectContextual(t, s) {
    if (!this.eatContextual(t)) {
      if (s != null)
        throw this.raise(s, {
          at: this.state.startLoc
        });
      this.unexpected(null, t);
    }
  }
  canInsertSemicolon() {
    return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
  }
  hasPrecedingLineBreak() {
    return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
  }
  hasFollowingLineBreak() {
    return skipWhiteSpaceToLineBreak.lastIndex = this.state.end, skipWhiteSpaceToLineBreak.test(this.input);
  }
  isLineTerminator() {
    return this.eat(13) || this.canInsertSemicolon();
  }
  semicolon(t = !0) {
    (t ? this.isLineTerminator() : this.eat(13)) || this.raise(Errors.MissingSemicolon, {
      at: this.state.lastTokEndLoc
    });
  }
  expect(t, s) {
    this.eat(t) || this.unexpected(s, t);
  }
  tryParse(t, s = this.state.clone()) {
    const i = {
      node: null
    };
    try {
      const a = t((o = null) => {
        throw i.node = o, i;
      });
      if (this.state.errors.length > s.errors.length) {
        const o = this.state;
        return this.state = s, this.state.tokensLength = o.tokensLength, {
          node: a,
          error: o.errors[s.errors.length],
          thrown: !1,
          aborted: !1,
          failState: o
        };
      }
      return {
        node: a,
        error: null,
        thrown: !1,
        aborted: !1,
        failState: null
      };
    } catch (a) {
      const o = this.state;
      if (this.state = s, a instanceof SyntaxError)
        return {
          node: null,
          error: a,
          thrown: !0,
          aborted: !1,
          failState: o
        };
      if (a === i)
        return {
          node: i.node,
          error: null,
          thrown: !1,
          aborted: !0,
          failState: o
        };
      throw a;
    }
  }
  checkExpressionErrors(t, s) {
    if (!t)
      return !1;
    const {
      shorthandAssignLoc: i,
      doubleProtoLoc: a,
      privateKeyLoc: o,
      optionalParametersLoc: l
    } = t, f = !!i || !!a || !!l || !!o;
    if (!s)
      return f;
    i != null && this.raise(Errors.InvalidCoverInitializedName, {
      at: i
    }), a != null && this.raise(Errors.DuplicateProto, {
      at: a
    }), o != null && this.raise(Errors.UnexpectedPrivateField, {
      at: o
    }), l != null && this.unexpected(l);
  }
  isLiteralPropertyName() {
    return tokenIsLiteralPropertyName(this.state.type);
  }
  isPrivateName(t) {
    return t.type === "PrivateName";
  }
  getPrivateNameSV(t) {
    return t.id.name;
  }
  hasPropertyAsPrivateName(t) {
    return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
  }
  isObjectProperty(t) {
    return t.type === "ObjectProperty";
  }
  isObjectMethod(t) {
    return t.type === "ObjectMethod";
  }
  initializeScopes(t = this.options.sourceType === "module") {
    const s = this.state.labels;
    this.state.labels = [];
    const i = this.exportedIdentifiers;
    this.exportedIdentifiers = /* @__PURE__ */ new Set();
    const a = this.inModule;
    this.inModule = t;
    const o = this.scope, l = this.getScopeHandler();
    this.scope = new l(this, t);
    const f = this.prodParam;
    this.prodParam = new ProductionParameterHandler();
    const y = this.classScope;
    this.classScope = new ClassScopeHandler(this);
    const g = this.expressionScope;
    return this.expressionScope = new ExpressionScopeHandler(this), () => {
      this.state.labels = s, this.exportedIdentifiers = i, this.inModule = a, this.scope = o, this.prodParam = f, this.classScope = y, this.expressionScope = g;
    };
  }
  enterInitialScopes() {
    let t = 0;
    this.inModule && (t |= 2), this.scope.enter(1), this.prodParam.enter(t);
  }
  checkDestructuringPrivate(t) {
    const {
      privateKeyLoc: s
    } = t;
    s !== null && this.expectPlugin("destructuringPrivate", s);
  }
}
class ExpressionErrors {
  constructor() {
    this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
  }
}
class Node {
  constructor(t, s, i) {
    this.type = "", this.start = s, this.end = 0, this.loc = new SourceLocation(i), t != null && t.options.ranges && (this.range = [s, 0]), t != null && t.filename && (this.loc.filename = t.filename);
  }
}
const NodePrototype = Node.prototype;
NodePrototype.__clone = function() {
  const e = new Node(void 0, this.start, this.loc.start), t = Object.keys(this);
  for (let s = 0, i = t.length; s < i; s++) {
    const a = t[s];
    a !== "leadingComments" && a !== "trailingComments" && a !== "innerComments" && (e[a] = this[a]);
  }
  return e;
};
function clonePlaceholder(e) {
  return cloneIdentifier(e);
}
function cloneIdentifier(e) {
  const {
    type: t,
    start: s,
    end: i,
    loc: a,
    range: o,
    extra: l,
    name: f
  } = e, y = Object.create(NodePrototype);
  return y.type = t, y.start = s, y.end = i, y.loc = a, y.range = o, y.extra = l, y.name = f, t === "Placeholder" && (y.expectedNode = e.expectedNode), y;
}
function cloneStringLiteral(e) {
  const {
    type: t,
    start: s,
    end: i,
    loc: a,
    range: o,
    extra: l
  } = e;
  if (t === "Placeholder")
    return clonePlaceholder(e);
  const f = Object.create(NodePrototype);
  return f.type = t, f.start = s, f.end = i, f.loc = a, f.range = o, e.raw !== void 0 ? f.raw = e.raw : f.extra = l, f.value = e.value, f;
}
class NodeUtils extends UtilParser {
  startNode() {
    return new Node(this, this.state.start, this.state.startLoc);
  }
  startNodeAt(t) {
    return new Node(this, t.index, t);
  }
  startNodeAtNode(t) {
    return this.startNodeAt(t.loc.start);
  }
  finishNode(t, s) {
    return this.finishNodeAt(t, s, this.state.lastTokEndLoc);
  }
  finishNodeAt(t, s, i) {
    return t.type = s, t.end = i.index, t.loc.end = i, this.options.ranges && (t.range[1] = i.index), this.options.attachComment && this.processComment(t), t;
  }
  resetStartLocation(t, s) {
    t.start = s.index, t.loc.start = s, this.options.ranges && (t.range[0] = s.index);
  }
  resetEndLocation(t, s = this.state.lastTokEndLoc) {
    t.end = s.index, t.loc.end = s, this.options.ranges && (t.range[1] = s.index);
  }
  resetStartLocationFromNode(t, s) {
    this.resetStartLocation(t, s.loc.start);
  }
}
const reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), FlowErrors = ParseErrorEnum`flow`({
  AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
  AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
  AssignReservedType: ({
    reservedType: e
  }) => `Cannot overwrite reserved type ${e}.`,
  DeclareClassElement: "The `declare` modifier can only appear on class fields.",
  DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
  DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
  EnumBooleanMemberNotInitialized: ({
    memberName: e,
    enumName: t
  }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`,
  EnumDuplicateMemberName: ({
    memberName: e,
    enumName: t
  }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`,
  EnumInconsistentMemberValues: ({
    enumName: e
  }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
  EnumInvalidExplicitType: ({
    invalidEnumType: e,
    enumName: t
  }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`,
  EnumInvalidExplicitTypeUnknownSupplied: ({
    enumName: e
  }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`,
  EnumInvalidMemberInitializerPrimaryType: ({
    enumName: e,
    memberName: t,
    explicitType: s
  }) => `Enum \`${e}\` has type \`${s}\`, so the initializer of \`${t}\` needs to be a ${s} literal.`,
  EnumInvalidMemberInitializerSymbolType: ({
    enumName: e,
    memberName: t
  }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`,
  EnumInvalidMemberInitializerUnknownType: ({
    enumName: e,
    memberName: t
  }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`,
  EnumInvalidMemberName: ({
    enumName: e,
    memberName: t,
    suggestion: s
  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${s}\`, in enum \`${e}\`.`,
  EnumNumberMemberNotInitialized: ({
    enumName: e,
    memberName: t
  }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`,
  EnumStringMemberInconsistentlyInitialized: ({
    enumName: e
  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`,
  GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
  ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
  ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
  InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
  InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
  InexactVariance: "Explicit inexact syntax cannot have variance.",
  InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
  MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
  NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
  NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
  PatternIsOptional: Object.assign({
    message: "A binding pattern parameter cannot be optional in an implementation signature."
  }, {
    reasonCode: "OptionalBindingPattern"
  }),
  SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
  SpreadVariance: "Spread properties cannot have variance.",
  ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
  ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
  ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
  ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
  ThisParamNoDefault: "The `this` parameter may not have a default value.",
  TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
  UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
  UnexpectedReservedType: ({
    reservedType: e
  }) => `Unexpected reserved type ${e}.`,
  UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
  UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
  UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
  UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
  UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
  UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
  UnsupportedDeclareExportKind: ({
    unsupportedExportKind: e,
    suggestion: t
  }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`,
  UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
  UnterminatedFlowComment: "Unterminated flow-comment."
});
function isEsModuleType(e) {
  return e.type === "DeclareExportAllDeclaration" || e.type === "DeclareExportDeclaration" && (!e.declaration || e.declaration.type !== "TypeAlias" && e.declaration.type !== "InterfaceDeclaration");
}
function hasTypeImportKind(e) {
  return e.importKind === "type" || e.importKind === "typeof";
}
const exportSuggestions = {
  const: "declare export var",
  let: "declare export var",
  type: "export type",
  interface: "export interface"
};
function partition(e, t) {
  const s = [], i = [];
  for (let a = 0; a < e.length; a++)
    (t(e[a], a, e) ? s : i).push(e[a]);
  return [s, i];
}
const FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
var flow = (e) => class extends e {
  constructor(...s) {
    super(...s), this.flowPragma = void 0;
  }
  getScopeHandler() {
    return FlowScopeHandler;
  }
  shouldParseTypes() {
    return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
  }
  shouldParseEnums() {
    return !!this.getPluginOption("flow", "enums");
  }
  finishToken(s, i) {
    s !== 133 && s !== 13 && s !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(s, i);
  }
  addComment(s) {
    if (this.flowPragma === void 0) {
      const i = FLOW_PRAGMA_REGEX.exec(s.value);
      if (i)
        if (i[1] === "flow")
          this.flowPragma = "flow";
        else if (i[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
    }
    super.addComment(s);
  }
  flowParseTypeInitialiser(s) {
    const i = this.state.inType;
    this.state.inType = !0, this.expect(s || 14);
    const a = this.flowParseType();
    return this.state.inType = i, a;
  }
  flowParsePredicate() {
    const s = this.startNode(), i = this.state.startLoc;
    return this.next(), this.expectContextual(110), this.state.lastTokStart > i.index + 1 && this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, {
      at: i
    }), this.eat(10) ? (s.value = super.parseExpression(), this.expect(11), this.finishNode(s, "DeclaredPredicate")) : this.finishNode(s, "InferredPredicate");
  }
  flowParseTypeAndPredicateInitialiser() {
    const s = this.state.inType;
    this.state.inType = !0, this.expect(14);
    let i = null, a = null;
    return this.match(54) ? (this.state.inType = s, a = this.flowParsePredicate()) : (i = this.flowParseType(), this.state.inType = s, this.match(54) && (a = this.flowParsePredicate())), [i, a];
  }
  flowParseDeclareClass(s) {
    return this.next(), this.flowParseInterfaceish(s, !0), this.finishNode(s, "DeclareClass");
  }
  flowParseDeclareFunction(s) {
    this.next();
    const i = s.id = this.parseIdentifier(), a = this.startNode(), o = this.startNode();
    this.match(47) ? a.typeParameters = this.flowParseTypeParameterDeclaration() : a.typeParameters = null, this.expect(10);
    const l = this.flowParseFunctionTypeParams();
    return a.params = l.params, a.rest = l.rest, a.this = l._this, this.expect(11), [a.returnType, s.predicate] = this.flowParseTypeAndPredicateInitialiser(), o.typeAnnotation = this.finishNode(a, "FunctionTypeAnnotation"), i.typeAnnotation = this.finishNode(o, "TypeAnnotation"), this.resetEndLocation(i), this.semicolon(), this.scope.declareName(s.id.name, 2048, s.id.loc.start), this.finishNode(s, "DeclareFunction");
  }
  flowParseDeclare(s, i) {
    if (this.match(80))
      return this.flowParseDeclareClass(s);
    if (this.match(68))
      return this.flowParseDeclareFunction(s);
    if (this.match(74))
      return this.flowParseDeclareVariable(s);
    if (this.eatContextual(127))
      return this.match(16) ? this.flowParseDeclareModuleExports(s) : (i && this.raise(FlowErrors.NestedDeclareModule, {
        at: this.state.lastTokStartLoc
      }), this.flowParseDeclareModule(s));
    if (this.isContextual(130))
      return this.flowParseDeclareTypeAlias(s);
    if (this.isContextual(131))
      return this.flowParseDeclareOpaqueType(s);
    if (this.isContextual(129))
      return this.flowParseDeclareInterface(s);
    if (this.match(82))
      return this.flowParseDeclareExportDeclaration(s, i);
    this.unexpected();
  }
  flowParseDeclareVariable(s) {
    return this.next(), s.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(s.id.name, 5, s.id.loc.start), this.semicolon(), this.finishNode(s, "DeclareVariable");
  }
  flowParseDeclareModule(s) {
    this.scope.enter(0), this.match(133) ? s.id = super.parseExprAtom() : s.id = this.parseIdentifier();
    const i = s.body = this.startNode(), a = i.body = [];
    for (this.expect(5); !this.match(8); ) {
      let f = this.startNode();
      this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, {
        at: this.state.lastTokStartLoc
      }), super.parseImport(f)) : (this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule), f = this.flowParseDeclare(f, !0)), a.push(f);
    }
    this.scope.exit(), this.expect(8), this.finishNode(i, "BlockStatement");
    let o = null, l = !1;
    return a.forEach((f) => {
      isEsModuleType(f) ? (o === "CommonJS" && this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
        at: f
      }), o = "ES") : f.type === "DeclareModuleExports" && (l && this.raise(FlowErrors.DuplicateDeclareModuleExports, {
        at: f
      }), o === "ES" && this.raise(FlowErrors.AmbiguousDeclareModuleKind, {
        at: f
      }), o = "CommonJS", l = !0);
    }), s.kind = o || "CommonJS", this.finishNode(s, "DeclareModule");
  }
  flowParseDeclareExportDeclaration(s, i) {
    if (this.expect(82), this.eat(65))
      return this.match(68) || this.match(80) ? s.declaration = this.flowParseDeclare(this.startNode()) : (s.declaration = this.flowParseType(), this.semicolon()), s.default = !0, this.finishNode(s, "DeclareExportDeclaration");
    if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !i) {
      const a = this.state.value;
      throw this.raise(FlowErrors.UnsupportedDeclareExportKind, {
        at: this.state.startLoc,
        unsupportedExportKind: a,
        suggestion: exportSuggestions[a]
      });
    }
    if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
      return s.declaration = this.flowParseDeclare(this.startNode()), s.default = !1, this.finishNode(s, "DeclareExportDeclaration");
    if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
      return s = this.parseExport(s, null), s.type === "ExportNamedDeclaration" && (s.type = "ExportDeclaration", s.default = !1, delete s.exportKind), s.type = "Declare" + s.type, s;
    this.unexpected();
  }
  flowParseDeclareModuleExports(s) {
    return this.next(), this.expectContextual(111), s.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(s, "DeclareModuleExports");
  }
  flowParseDeclareTypeAlias(s) {
    this.next();
    const i = this.flowParseTypeAlias(s);
    return i.type = "DeclareTypeAlias", i;
  }
  flowParseDeclareOpaqueType(s) {
    this.next();
    const i = this.flowParseOpaqueType(s, !0);
    return i.type = "DeclareOpaqueType", i;
  }
  flowParseDeclareInterface(s) {
    return this.next(), this.flowParseInterfaceish(s, !1), this.finishNode(s, "DeclareInterface");
  }
  flowParseInterfaceish(s, i) {
    if (s.id = this.flowParseRestrictedIdentifier(!i, !0), this.scope.declareName(s.id.name, i ? 17 : 8201, s.id.loc.start), this.match(47) ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, s.extends = [], this.eat(81))
      do
        s.extends.push(this.flowParseInterfaceExtends());
      while (!i && this.eat(12));
    if (i) {
      if (s.implements = [], s.mixins = [], this.eatContextual(117))
        do
          s.mixins.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      if (this.eatContextual(113))
        do
          s.implements.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
    }
    s.body = this.flowParseObjectType({
      allowStatic: i,
      allowExact: !1,
      allowSpread: !1,
      allowProto: i,
      allowInexact: !1
    });
  }
  flowParseInterfaceExtends() {
    const s = this.startNode();
    return s.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? s.typeParameters = this.flowParseTypeParameterInstantiation() : s.typeParameters = null, this.finishNode(s, "InterfaceExtends");
  }
  flowParseInterface(s) {
    return this.flowParseInterfaceish(s, !1), this.finishNode(s, "InterfaceDeclaration");
  }
  checkNotUnderscore(s) {
    s === "_" && this.raise(FlowErrors.UnexpectedReservedUnderscore, {
      at: this.state.startLoc
    });
  }
  checkReservedType(s, i, a) {
    reservedTypes.has(s) && this.raise(a ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, {
      at: i,
      reservedType: s
    });
  }
  flowParseRestrictedIdentifier(s, i) {
    return this.checkReservedType(this.state.value, this.state.startLoc, i), this.parseIdentifier(s);
  }
  flowParseTypeAlias(s) {
    return s.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(s.id.name, 8201, s.id.loc.start), this.match(47) ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, s.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(s, "TypeAlias");
  }
  flowParseOpaqueType(s, i) {
    return this.expectContextual(130), s.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(s.id.name, 8201, s.id.loc.start), this.match(47) ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, s.supertype = null, this.match(14) && (s.supertype = this.flowParseTypeInitialiser(14)), s.impltype = null, i || (s.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(s, "OpaqueType");
  }
  flowParseTypeParameter(s = !1) {
    const i = this.state.startLoc, a = this.startNode(), o = this.flowParseVariance(), l = this.flowParseTypeAnnotatableIdentifier();
    return a.name = l.name, a.variance = o, a.bound = l.typeAnnotation, this.match(29) ? (this.eat(29), a.default = this.flowParseType()) : s && this.raise(FlowErrors.MissingTypeParamDefault, {
      at: i
    }), this.finishNode(a, "TypeParameter");
  }
  flowParseTypeParameterDeclaration() {
    const s = this.state.inType, i = this.startNode();
    i.params = [], this.state.inType = !0, this.match(47) || this.match(142) ? this.next() : this.unexpected();
    let a = !1;
    do {
      const o = this.flowParseTypeParameter(a);
      i.params.push(o), o.default && (a = !0), this.match(48) || this.expect(12);
    } while (!this.match(48));
    return this.expect(48), this.state.inType = s, this.finishNode(i, "TypeParameterDeclaration");
  }
  flowParseTypeParameterInstantiation() {
    const s = this.startNode(), i = this.state.inType;
    s.params = [], this.state.inType = !0, this.expect(47);
    const a = this.state.noAnonFunctionType;
    for (this.state.noAnonFunctionType = !1; !this.match(48); )
      s.params.push(this.flowParseType()), this.match(48) || this.expect(12);
    return this.state.noAnonFunctionType = a, this.expect(48), this.state.inType = i, this.finishNode(s, "TypeParameterInstantiation");
  }
  flowParseTypeParameterInstantiationCallOrNew() {
    const s = this.startNode(), i = this.state.inType;
    for (s.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
      s.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
    return this.expect(48), this.state.inType = i, this.finishNode(s, "TypeParameterInstantiation");
  }
  flowParseInterfaceType() {
    const s = this.startNode();
    if (this.expectContextual(129), s.extends = [], this.eat(81))
      do
        s.extends.push(this.flowParseInterfaceExtends());
      while (this.eat(12));
    return s.body = this.flowParseObjectType({
      allowStatic: !1,
      allowExact: !1,
      allowSpread: !1,
      allowProto: !1,
      allowInexact: !1
    }), this.finishNode(s, "InterfaceTypeAnnotation");
  }
  flowParseObjectPropertyKey() {
    return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(!0);
  }
  flowParseObjectTypeIndexer(s, i, a) {
    return s.static = i, this.lookahead().type === 14 ? (s.id = this.flowParseObjectPropertyKey(), s.key = this.flowParseTypeInitialiser()) : (s.id = null, s.key = this.flowParseType()), this.expect(3), s.value = this.flowParseTypeInitialiser(), s.variance = a, this.finishNode(s, "ObjectTypeIndexer");
  }
  flowParseObjectTypeInternalSlot(s, i) {
    return s.static = i, s.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (s.method = !0, s.optional = !1, s.value = this.flowParseObjectTypeMethodish(this.startNodeAt(s.loc.start))) : (s.method = !1, this.eat(17) && (s.optional = !0), s.value = this.flowParseTypeInitialiser()), this.finishNode(s, "ObjectTypeInternalSlot");
  }
  flowParseObjectTypeMethodish(s) {
    for (s.params = [], s.rest = null, s.typeParameters = null, s.this = null, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (s.this = this.flowParseFunctionTypeParam(!0), s.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
      s.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
    return this.eat(21) && (s.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), s.returnType = this.flowParseTypeInitialiser(), this.finishNode(s, "FunctionTypeAnnotation");
  }
  flowParseObjectTypeCallProperty(s, i) {
    const a = this.startNode();
    return s.static = i, s.value = this.flowParseObjectTypeMethodish(a), this.finishNode(s, "ObjectTypeCallProperty");
  }
  flowParseObjectType({
    allowStatic: s,
    allowExact: i,
    allowSpread: a,
    allowProto: o,
    allowInexact: l
  }) {
    const f = this.state.inType;
    this.state.inType = !0;
    const y = this.startNode();
    y.callProperties = [], y.properties = [], y.indexers = [], y.internalSlots = [];
    let g, T, S = !1;
    for (i && this.match(6) ? (this.expect(6), g = 9, T = !0) : (this.expect(5), g = 8, T = !1), y.exact = T; !this.match(g); ) {
      let v = !1, $ = null, U = null;
      const X = this.startNode();
      if (o && this.isContextual(118)) {
        const D = this.lookahead();
        D.type !== 14 && D.type !== 17 && (this.next(), $ = this.state.startLoc, s = !1);
      }
      if (s && this.isContextual(106)) {
        const D = this.lookahead();
        D.type !== 14 && D.type !== 17 && (this.next(), v = !0);
      }
      const k = this.flowParseVariance();
      if (this.eat(0))
        $ != null && this.unexpected($), this.eat(0) ? (k && this.unexpected(k.loc.start), y.internalSlots.push(this.flowParseObjectTypeInternalSlot(X, v))) : y.indexers.push(this.flowParseObjectTypeIndexer(X, v, k));
      else if (this.match(10) || this.match(47))
        $ != null && this.unexpected($), k && this.unexpected(k.loc.start), y.callProperties.push(this.flowParseObjectTypeCallProperty(X, v));
      else {
        let D = "init";
        if (this.isContextual(99) || this.isContextual(104)) {
          const Z = this.lookahead();
          tokenIsLiteralPropertyName(Z.type) && (D = this.state.value, this.next());
        }
        const B = this.flowParseObjectTypeProperty(X, v, $, k, D, a, l ?? !T);
        B === null ? (S = !0, U = this.state.lastTokStartLoc) : y.properties.push(B);
      }
      this.flowObjectTypeSemicolon(), U && !this.match(8) && !this.match(9) && this.raise(FlowErrors.UnexpectedExplicitInexactInObject, {
        at: U
      });
    }
    this.expect(g), a && (y.inexact = S);
    const b = this.finishNode(y, "ObjectTypeAnnotation");
    return this.state.inType = f, b;
  }
  flowParseObjectTypeProperty(s, i, a, o, l, f, y) {
    if (this.eat(21))
      return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (f ? y || this.raise(FlowErrors.InexactInsideExact, {
        at: this.state.lastTokStartLoc
      }) : this.raise(FlowErrors.InexactInsideNonObject, {
        at: this.state.lastTokStartLoc
      }), o && this.raise(FlowErrors.InexactVariance, {
        at: o
      }), null) : (f || this.raise(FlowErrors.UnexpectedSpreadType, {
        at: this.state.lastTokStartLoc
      }), a != null && this.unexpected(a), o && this.raise(FlowErrors.SpreadVariance, {
        at: o
      }), s.argument = this.flowParseType(), this.finishNode(s, "ObjectTypeSpreadProperty"));
    {
      s.key = this.flowParseObjectPropertyKey(), s.static = i, s.proto = a != null, s.kind = l;
      let g = !1;
      return this.match(47) || this.match(10) ? (s.method = !0, a != null && this.unexpected(a), o && this.unexpected(o.loc.start), s.value = this.flowParseObjectTypeMethodish(this.startNodeAt(s.loc.start)), (l === "get" || l === "set") && this.flowCheckGetterSetterParams(s), !f && s.key.name === "constructor" && s.value.this && this.raise(FlowErrors.ThisParamBannedInConstructor, {
        at: s.value.this
      })) : (l !== "init" && this.unexpected(), s.method = !1, this.eat(17) && (g = !0), s.value = this.flowParseTypeInitialiser(), s.variance = o), s.optional = g, this.finishNode(s, "ObjectTypeProperty");
    }
  }
  flowCheckGetterSetterParams(s) {
    const i = s.kind === "get" ? 0 : 1, a = s.value.params.length + (s.value.rest ? 1 : 0);
    s.value.this && this.raise(s.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, {
      at: s.value.this
    }), a !== i && this.raise(s.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
      at: s
    }), s.kind === "set" && s.value.rest && this.raise(Errors.BadSetterRestParameter, {
      at: s
    });
  }
  flowObjectTypeSemicolon() {
    !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
  }
  flowParseQualifiedTypeIdentifier(s, i) {
    var a;
    (a = s) != null || (s = this.state.startLoc);
    let o = i || this.flowParseRestrictedIdentifier(!0);
    for (; this.eat(16); ) {
      const l = this.startNodeAt(s);
      l.qualification = o, l.id = this.flowParseRestrictedIdentifier(!0), o = this.finishNode(l, "QualifiedTypeIdentifier");
    }
    return o;
  }
  flowParseGenericType(s, i) {
    const a = this.startNodeAt(s);
    return a.typeParameters = null, a.id = this.flowParseQualifiedTypeIdentifier(s, i), this.match(47) && (a.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(a, "GenericTypeAnnotation");
  }
  flowParseTypeofType() {
    const s = this.startNode();
    return this.expect(87), s.argument = this.flowParsePrimaryType(), this.finishNode(s, "TypeofTypeAnnotation");
  }
  flowParseTupleType() {
    const s = this.startNode();
    for (s.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (s.types.push(this.flowParseType()), !this.match(3)); )
      this.expect(12);
    return this.expect(3), this.finishNode(s, "TupleTypeAnnotation");
  }
  flowParseFunctionTypeParam(s) {
    let i = null, a = !1, o = null;
    const l = this.startNode(), f = this.lookahead(), y = this.state.type === 78;
    return f.type === 14 || f.type === 17 ? (y && !s && this.raise(FlowErrors.ThisParamMustBeFirst, {
      at: l
    }), i = this.parseIdentifier(y), this.eat(17) && (a = !0, y && this.raise(FlowErrors.ThisParamMayNotBeOptional, {
      at: l
    })), o = this.flowParseTypeInitialiser()) : o = this.flowParseType(), l.name = i, l.optional = a, l.typeAnnotation = o, this.finishNode(l, "FunctionTypeParam");
  }
  reinterpretTypeAsFunctionTypeParam(s) {
    const i = this.startNodeAt(s.loc.start);
    return i.name = null, i.optional = !1, i.typeAnnotation = s, this.finishNode(i, "FunctionTypeParam");
  }
  flowParseFunctionTypeParams(s = []) {
    let i = null, a = null;
    for (this.match(78) && (a = this.flowParseFunctionTypeParam(!0), a.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
      s.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
    return this.eat(21) && (i = this.flowParseFunctionTypeParam(!1)), {
      params: s,
      rest: i,
      _this: a
    };
  }
  flowIdentToTypeAnnotation(s, i, a) {
    switch (a.name) {
      case "any":
        return this.finishNode(i, "AnyTypeAnnotation");
      case "bool":
      case "boolean":
        return this.finishNode(i, "BooleanTypeAnnotation");
      case "mixed":
        return this.finishNode(i, "MixedTypeAnnotation");
      case "empty":
        return this.finishNode(i, "EmptyTypeAnnotation");
      case "number":
        return this.finishNode(i, "NumberTypeAnnotation");
      case "string":
        return this.finishNode(i, "StringTypeAnnotation");
      case "symbol":
        return this.finishNode(i, "SymbolTypeAnnotation");
      default:
        return this.checkNotUnderscore(a.name), this.flowParseGenericType(s, a);
    }
  }
  flowParsePrimaryType() {
    const s = this.state.startLoc, i = this.startNode();
    let a, o, l = !1;
    const f = this.state.noAnonFunctionType;
    switch (this.state.type) {
      case 5:
        return this.flowParseObjectType({
          allowStatic: !1,
          allowExact: !1,
          allowSpread: !0,
          allowProto: !1,
          allowInexact: !0
        });
      case 6:
        return this.flowParseObjectType({
          allowStatic: !1,
          allowExact: !0,
          allowSpread: !0,
          allowProto: !1,
          allowInexact: !1
        });
      case 0:
        return this.state.noAnonFunctionType = !1, o = this.flowParseTupleType(), this.state.noAnonFunctionType = f, o;
      case 47:
        return i.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), a = this.flowParseFunctionTypeParams(), i.params = a.params, i.rest = a.rest, i.this = a._this, this.expect(11), this.expect(19), i.returnType = this.flowParseType(), this.finishNode(i, "FunctionTypeAnnotation");
      case 10:
        if (this.next(), !this.match(11) && !this.match(21))
          if (tokenIsIdentifier(this.state.type) || this.match(78)) {
            const y = this.lookahead().type;
            l = y !== 17 && y !== 14;
          } else
            l = !0;
        if (l) {
          if (this.state.noAnonFunctionType = !1, o = this.flowParseType(), this.state.noAnonFunctionType = f, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
            return this.expect(11), o;
          this.eat(12);
        }
        return o ? a = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(o)]) : a = this.flowParseFunctionTypeParams(), i.params = a.params, i.rest = a.rest, i.this = a._this, this.expect(11), this.expect(19), i.returnType = this.flowParseType(), i.typeParameters = null, this.finishNode(i, "FunctionTypeAnnotation");
      case 133:
        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
      case 85:
      case 86:
        return i.value = this.match(85), this.next(), this.finishNode(i, "BooleanLiteralTypeAnnotation");
      case 53:
        if (this.state.value === "-") {
          if (this.next(), this.match(134))
            return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", i);
          if (this.match(135))
            return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", i);
          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, {
            at: this.state.startLoc
          });
        }
        this.unexpected();
        return;
      case 134:
        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
      case 135:
        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
      case 88:
        return this.next(), this.finishNode(i, "VoidTypeAnnotation");
      case 84:
        return this.next(), this.finishNode(i, "NullLiteralTypeAnnotation");
      case 78:
        return this.next(), this.finishNode(i, "ThisTypeAnnotation");
      case 55:
        return this.next(), this.finishNode(i, "ExistsTypeAnnotation");
      case 87:
        return this.flowParseTypeofType();
      default:
        if (tokenIsKeyword(this.state.type)) {
          const y = tokenLabelName(this.state.type);
          return this.next(), super.createIdentifier(i, y);
        } else if (tokenIsIdentifier(this.state.type))
          return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(s, i, this.parseIdentifier());
    }
    this.unexpected();
  }
  flowParsePostfixType() {
    const s = this.state.startLoc;
    let i = this.flowParsePrimaryType(), a = !1;
    for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
      const o = this.startNodeAt(s), l = this.eat(18);
      a = a || l, this.expect(0), !l && this.match(3) ? (o.elementType = i, this.next(), i = this.finishNode(o, "ArrayTypeAnnotation")) : (o.objectType = i, o.indexType = this.flowParseType(), this.expect(3), a ? (o.optional = l, i = this.finishNode(o, "OptionalIndexedAccessType")) : i = this.finishNode(o, "IndexedAccessType"));
    }
    return i;
  }
  flowParsePrefixType() {
    const s = this.startNode();
    return this.eat(17) ? (s.typeAnnotation = this.flowParsePrefixType(), this.finishNode(s, "NullableTypeAnnotation")) : this.flowParsePostfixType();
  }
  flowParseAnonFunctionWithoutParens() {
    const s = this.flowParsePrefixType();
    if (!this.state.noAnonFunctionType && this.eat(19)) {
      const i = this.startNodeAt(s.loc.start);
      return i.params = [this.reinterpretTypeAsFunctionTypeParam(s)], i.rest = null, i.this = null, i.returnType = this.flowParseType(), i.typeParameters = null, this.finishNode(i, "FunctionTypeAnnotation");
    }
    return s;
  }
  flowParseIntersectionType() {
    const s = this.startNode();
    this.eat(45);
    const i = this.flowParseAnonFunctionWithoutParens();
    for (s.types = [i]; this.eat(45); )
      s.types.push(this.flowParseAnonFunctionWithoutParens());
    return s.types.length === 1 ? i : this.finishNode(s, "IntersectionTypeAnnotation");
  }
  flowParseUnionType() {
    const s = this.startNode();
    this.eat(43);
    const i = this.flowParseIntersectionType();
    for (s.types = [i]; this.eat(43); )
      s.types.push(this.flowParseIntersectionType());
    return s.types.length === 1 ? i : this.finishNode(s, "UnionTypeAnnotation");
  }
  flowParseType() {
    const s = this.state.inType;
    this.state.inType = !0;
    const i = this.flowParseUnionType();
    return this.state.inType = s, i;
  }
  flowParseTypeOrImplicitInstantiation() {
    if (this.state.type === 132 && this.state.value === "_") {
      const s = this.state.startLoc, i = this.parseIdentifier();
      return this.flowParseGenericType(s, i);
    } else
      return this.flowParseType();
  }
  flowParseTypeAnnotation() {
    const s = this.startNode();
    return s.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(s, "TypeAnnotation");
  }
  flowParseTypeAnnotatableIdentifier(s) {
    const i = s ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
    return this.match(14) && (i.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(i)), i;
  }
  typeCastToParameter(s) {
    return s.expression.typeAnnotation = s.typeAnnotation, this.resetEndLocation(s.expression, s.typeAnnotation.loc.end), s.expression;
  }
  flowParseVariance() {
    let s = null;
    return this.match(53) ? (s = this.startNode(), this.state.value === "+" ? s.kind = "plus" : s.kind = "minus", this.next(), this.finishNode(s, "Variance")) : s;
  }
  parseFunctionBody(s, i, a = !1) {
    if (i) {
      this.forwardNoArrowParamsConversionAt(s, () => super.parseFunctionBody(s, !0, a));
      return;
    }
    super.parseFunctionBody(s, !1, a);
  }
  parseFunctionBodyAndFinish(s, i, a = !1) {
    if (this.match(14)) {
      const o = this.startNode();
      [o.typeAnnotation, s.predicate] = this.flowParseTypeAndPredicateInitialiser(), s.returnType = o.typeAnnotation ? this.finishNode(o, "TypeAnnotation") : null;
    }
    return super.parseFunctionBodyAndFinish(s, i, a);
  }
  parseStatementLike(s) {
    if (this.state.strict && this.isContextual(129)) {
      const a = this.lookahead();
      if (tokenIsKeywordOrIdentifier(a.type)) {
        const o = this.startNode();
        return this.next(), this.flowParseInterface(o);
      }
    } else if (this.shouldParseEnums() && this.isContextual(126)) {
      const a = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(a);
    }
    const i = super.parseStatementLike(s);
    return this.flowPragma === void 0 && !this.isValidDirective(i) && (this.flowPragma = null), i;
  }
  parseExpressionStatement(s, i, a) {
    if (i.type === "Identifier") {
      if (i.name === "declare") {
        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82))
          return this.flowParseDeclare(s);
      } else if (tokenIsIdentifier(this.state.type)) {
        if (i.name === "interface")
          return this.flowParseInterface(s);
        if (i.name === "type")
          return this.flowParseTypeAlias(s);
        if (i.name === "opaque")
          return this.flowParseOpaqueType(s, !1);
      }
    }
    return super.parseExpressionStatement(s, i, a);
  }
  shouldParseExportDeclaration() {
    const {
      type: s
    } = this.state;
    return tokenIsFlowInterfaceOrTypeOrOpaque(s) || this.shouldParseEnums() && s === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
  }
  isExportDefaultSpecifier() {
    const {
      type: s
    } = this.state;
    return tokenIsFlowInterfaceOrTypeOrOpaque(s) || this.shouldParseEnums() && s === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
  }
  parseExportDefaultExpression() {
    if (this.shouldParseEnums() && this.isContextual(126)) {
      const s = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(s);
    }
    return super.parseExportDefaultExpression();
  }
  parseConditional(s, i, a) {
    if (!this.match(17))
      return s;
    if (this.state.maybeInArrowParameters) {
      const b = this.lookaheadCharCode();
      if (b === 44 || b === 61 || b === 58 || b === 41)
        return this.setOptionalParametersError(a), s;
    }
    this.expect(17);
    const o = this.state.clone(), l = this.state.noArrowAt, f = this.startNodeAt(i);
    let {
      consequent: y,
      failed: g
    } = this.tryParseConditionalConsequent(), [T, S] = this.getArrowLikeExpressions(y);
    if (g || S.length > 0) {
      const b = [...l];
      if (S.length > 0) {
        this.state = o, this.state.noArrowAt = b;
        for (let v = 0; v < S.length; v++)
          b.push(S[v].start);
        ({
          consequent: y,
          failed: g
        } = this.tryParseConditionalConsequent()), [T, S] = this.getArrowLikeExpressions(y);
      }
      g && T.length > 1 && this.raise(FlowErrors.AmbiguousConditionalArrow, {
        at: o.startLoc
      }), g && T.length === 1 && (this.state = o, b.push(T[0].start), this.state.noArrowAt = b, {
        consequent: y,
        failed: g
      } = this.tryParseConditionalConsequent());
    }
    return this.getArrowLikeExpressions(y, !0), this.state.noArrowAt = l, this.expect(14), f.test = s, f.consequent = y, f.alternate = this.forwardNoArrowParamsConversionAt(f, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(f, "ConditionalExpression");
  }
  tryParseConditionalConsequent() {
    this.state.noArrowParamsConversionAt.push(this.state.start);
    const s = this.parseMaybeAssignAllowIn(), i = !this.match(14);
    return this.state.noArrowParamsConversionAt.pop(), {
      consequent: s,
      failed: i
    };
  }
  getArrowLikeExpressions(s, i) {
    const a = [s], o = [];
    for (; a.length !== 0; ) {
      const l = a.pop();
      l.type === "ArrowFunctionExpression" ? (l.typeParameters || !l.returnType ? this.finishArrowValidation(l) : o.push(l), a.push(l.body)) : l.type === "ConditionalExpression" && (a.push(l.consequent), a.push(l.alternate));
    }
    return i ? (o.forEach((l) => this.finishArrowValidation(l)), [o, []]) : partition(o, (l) => l.params.every((f) => this.isAssignable(f, !0)));
  }
  finishArrowValidation(s) {
    var i;
    this.toAssignableList(s.params, (i = s.extra) == null ? void 0 : i.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(s, !1, !0), this.scope.exit();
  }
  forwardNoArrowParamsConversionAt(s, i) {
    let a;
    return this.state.noArrowParamsConversionAt.indexOf(s.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), a = i(), this.state.noArrowParamsConversionAt.pop()) : a = i(), a;
  }
  parseParenItem(s, i) {
    if (s = super.parseParenItem(s, i), this.eat(17) && (s.optional = !0, this.resetEndLocation(s)), this.match(14)) {
      const a = this.startNodeAt(i);
      return a.expression = s, a.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(a, "TypeCastExpression");
    }
    return s;
  }
  assertModuleNodeAllowed(s) {
    s.type === "ImportDeclaration" && (s.importKind === "type" || s.importKind === "typeof") || s.type === "ExportNamedDeclaration" && s.exportKind === "type" || s.type === "ExportAllDeclaration" && s.exportKind === "type" || super.assertModuleNodeAllowed(s);
  }
  parseExportDeclaration(s) {
    if (this.isContextual(130)) {
      s.exportKind = "type";
      const i = this.startNode();
      return this.next(), this.match(5) ? (s.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(s), null) : this.flowParseTypeAlias(i);
    } else if (this.isContextual(131)) {
      s.exportKind = "type";
      const i = this.startNode();
      return this.next(), this.flowParseOpaqueType(i, !1);
    } else if (this.isContextual(129)) {
      s.exportKind = "type";
      const i = this.startNode();
      return this.next(), this.flowParseInterface(i);
    } else if (this.shouldParseEnums() && this.isContextual(126)) {
      s.exportKind = "value";
      const i = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(i);
    } else
      return super.parseExportDeclaration(s);
  }
  eatExportStar(s) {
    return super.eatExportStar(s) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (s.exportKind = "type", this.next(), this.next(), !0) : !1;
  }
  maybeParseExportNamespaceSpecifier(s) {
    const {
      startLoc: i
    } = this.state, a = super.maybeParseExportNamespaceSpecifier(s);
    return a && s.exportKind === "type" && this.unexpected(i), a;
  }
  parseClassId(s, i, a) {
    super.parseClassId(s, i, a), this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration());
  }
  parseClassMember(s, i, a) {
    const {
      startLoc: o
    } = this.state;
    if (this.isContextual(125)) {
      if (super.parseClassMemberFromModifier(s, i))
        return;
      i.declare = !0;
    }
    super.parseClassMember(s, i, a), i.declare && (i.type !== "ClassProperty" && i.type !== "ClassPrivateProperty" && i.type !== "PropertyDefinition" ? this.raise(FlowErrors.DeclareClassElement, {
      at: o
    }) : i.value && this.raise(FlowErrors.DeclareClassFieldInitializer, {
      at: i.value
    }));
  }
  isIterator(s) {
    return s === "iterator" || s === "asyncIterator";
  }
  readIterator() {
    const s = super.readWord1(), i = "@@" + s;
    (!this.isIterator(s) || !this.state.inType) && this.raise(Errors.InvalidIdentifier, {
      at: this.state.curPosition(),
      identifierName: i
    }), this.finishToken(132, i);
  }
  getTokenFromCode(s) {
    const i = this.input.charCodeAt(this.state.pos + 1);
    s === 123 && i === 124 ? this.finishOp(6, 2) : this.state.inType && (s === 62 || s === 60) ? this.finishOp(s === 62 ? 48 : 47, 1) : this.state.inType && s === 63 ? i === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : isIteratorStart(s, i, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(s);
  }
  isAssignable(s, i) {
    return s.type === "TypeCastExpression" ? this.isAssignable(s.expression, i) : super.isAssignable(s, i);
  }
  toAssignable(s, i = !1) {
    !i && s.type === "AssignmentExpression" && s.left.type === "TypeCastExpression" && (s.left = this.typeCastToParameter(s.left)), super.toAssignable(s, i);
  }
  toAssignableList(s, i, a) {
    for (let o = 0; o < s.length; o++) {
      const l = s[o];
      (l == null ? void 0 : l.type) === "TypeCastExpression" && (s[o] = this.typeCastToParameter(l));
    }
    super.toAssignableList(s, i, a);
  }
  toReferencedList(s, i) {
    for (let o = 0; o < s.length; o++) {
      var a;
      const l = s[o];
      l && l.type === "TypeCastExpression" && !((a = l.extra) != null && a.parenthesized) && (s.length > 1 || !i) && this.raise(FlowErrors.TypeCastInPattern, {
        at: l.typeAnnotation
      });
    }
    return s;
  }
  parseArrayLike(s, i, a, o) {
    const l = super.parseArrayLike(s, i, a, o);
    return i && !this.state.maybeInArrowParameters && this.toReferencedList(l.elements), l;
  }
  isValidLVal(s, i, a) {
    return s === "TypeCastExpression" || super.isValidLVal(s, i, a);
  }
  parseClassProperty(s) {
    return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(s);
  }
  parseClassPrivateProperty(s) {
    return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(s);
  }
  isClassMethod() {
    return this.match(47) || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(14) || super.isClassProperty();
  }
  isNonstaticConstructor(s) {
    return !this.match(14) && super.isNonstaticConstructor(s);
  }
  pushClassMethod(s, i, a, o, l, f) {
    if (i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(s, i, a, o, l, f), i.params && l) {
      const y = i.params;
      y.length > 0 && this.isThisParam(y[0]) && this.raise(FlowErrors.ThisParamBannedInConstructor, {
        at: i
      });
    } else if (i.type === "MethodDefinition" && l && i.value.params) {
      const y = i.value.params;
      y.length > 0 && this.isThisParam(y[0]) && this.raise(FlowErrors.ThisParamBannedInConstructor, {
        at: i
      });
    }
  }
  pushClassPrivateMethod(s, i, a, o) {
    i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(s, i, a, o);
  }
  parseClassSuper(s) {
    if (super.parseClassSuper(s), s.superClass && this.match(47) && (s.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
      this.next();
      const i = s.implements = [];
      do {
        const a = this.startNode();
        a.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? a.typeParameters = this.flowParseTypeParameterInstantiation() : a.typeParameters = null, i.push(this.finishNode(a, "ClassImplements"));
      } while (this.eat(12));
    }
  }
  checkGetterSetterParams(s) {
    super.checkGetterSetterParams(s);
    const i = this.getObjectOrClassMethodParams(s);
    if (i.length > 0) {
      const a = i[0];
      this.isThisParam(a) && s.kind === "get" ? this.raise(FlowErrors.GetterMayNotHaveThisParam, {
        at: a
      }) : this.isThisParam(a) && this.raise(FlowErrors.SetterMayNotHaveThisParam, {
        at: a
      });
    }
  }
  parsePropertyNamePrefixOperator(s) {
    s.variance = this.flowParseVariance();
  }
  parseObjPropValue(s, i, a, o, l, f, y) {
    s.variance && this.unexpected(s.variance.loc.start), delete s.variance;
    let g;
    this.match(47) && !f && (g = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
    const T = super.parseObjPropValue(s, i, a, o, l, f, y);
    return g && ((T.value || T).typeParameters = g), T;
  }
  parseAssignableListItemTypes(s) {
    return this.eat(17) && (s.type !== "Identifier" && this.raise(FlowErrors.PatternIsOptional, {
      at: s
    }), this.isThisParam(s) && this.raise(FlowErrors.ThisParamMayNotBeOptional, {
      at: s
    }), s.optional = !0), this.match(14) ? s.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(s) && this.raise(FlowErrors.ThisParamAnnotationRequired, {
      at: s
    }), this.match(29) && this.isThisParam(s) && this.raise(FlowErrors.ThisParamNoDefault, {
      at: s
    }), this.resetEndLocation(s), s;
  }
  parseMaybeDefault(s, i) {
    const a = super.parseMaybeDefault(s, i);
    return a.type === "AssignmentPattern" && a.typeAnnotation && a.right.start < a.typeAnnotation.start && this.raise(FlowErrors.TypeBeforeInitializer, {
      at: a.typeAnnotation
    }), a;
  }
  checkImportReflection(s) {
    super.checkImportReflection(s), s.module && s.importKind !== "value" && this.raise(FlowErrors.ImportReflectionHasImportType, {
      at: s.specifiers[0].loc.start
    });
  }
  parseImportSpecifierLocal(s, i, a) {
    i.local = hasTypeImportKind(s) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), s.specifiers.push(this.finishImportSpecifier(i, a));
  }
  isPotentialImportPhase(s) {
    if (super.isPotentialImportPhase(s))
      return !0;
    if (this.isContextual(130)) {
      if (!s)
        return !0;
      const i = this.lookaheadCharCode();
      return i === 123 || i === 42;
    }
    return !s && this.isContextual(87);
  }
  applyImportPhase(s, i, a, o) {
    if (super.applyImportPhase(s, i, a, o), i) {
      if (!a && this.match(65))
        return;
      s.exportKind = a === "type" ? a : "value";
    } else
      a === "type" && this.match(55) && this.unexpected(), s.importKind = a === "type" || a === "typeof" ? a : "value";
  }
  parseImportSpecifier(s, i, a, o, l) {
    const f = s.imported;
    let y = null;
    f.type === "Identifier" && (f.name === "type" ? y = "type" : f.name === "typeof" && (y = "typeof"));
    let g = !1;
    if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
      const S = this.parseIdentifier(!0);
      y !== null && !tokenIsKeywordOrIdentifier(this.state.type) ? (s.imported = S, s.importKind = y, s.local = cloneIdentifier(S)) : (s.imported = f, s.importKind = null, s.local = this.parseIdentifier());
    } else {
      if (y !== null && tokenIsKeywordOrIdentifier(this.state.type))
        s.imported = this.parseIdentifier(!0), s.importKind = y;
      else {
        if (i)
          throw this.raise(Errors.ImportBindingIsString, {
            at: s,
            importName: f.value
          });
        s.imported = f, s.importKind = null;
      }
      this.eatContextual(93) ? s.local = this.parseIdentifier() : (g = !0, s.local = cloneIdentifier(s.imported));
    }
    const T = hasTypeImportKind(s);
    return a && T && this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, {
      at: s
    }), (a || T) && this.checkReservedType(s.local.name, s.local.loc.start, !0), g && !a && !T && this.checkReservedWord(s.local.name, s.loc.start, !0, !0), this.finishImportSpecifier(s, "ImportSpecifier");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case 78:
        return this.parseIdentifier(!0);
      default:
        return super.parseBindingAtom();
    }
  }
  parseFunctionParams(s, i) {
    const a = s.kind;
    a !== "get" && a !== "set" && this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(s, i);
  }
  parseVarId(s, i) {
    super.parseVarId(s, i), this.match(14) && (s.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s.id));
  }
  parseAsyncArrowFromCallExpression(s, i) {
    if (this.match(14)) {
      const a = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = !0, s.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = a;
    }
    return super.parseAsyncArrowFromCallExpression(s, i);
  }
  shouldParseAsyncArrow() {
    return this.match(14) || super.shouldParseAsyncArrow();
  }
  parseMaybeAssign(s, i) {
    var a;
    let o = null, l;
    if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
      if (o = this.state.clone(), l = this.tryParse(() => super.parseMaybeAssign(s, i), o), !l.error)
        return l.node;
      const {
        context: g
      } = this.state, T = g[g.length - 1];
      (T === types.j_oTag || T === types.j_expr) && g.pop();
    }
    if ((a = l) != null && a.error || this.match(47)) {
      var f, y;
      o = o || this.state.clone();
      let g;
      const T = this.tryParse((b) => {
        var v;
        g = this.flowParseTypeParameterDeclaration();
        const $ = this.forwardNoArrowParamsConversionAt(g, () => {
          const X = super.parseMaybeAssign(s, i);
          return this.resetStartLocationFromNode(X, g), X;
        });
        (v = $.extra) != null && v.parenthesized && b();
        const U = this.maybeUnwrapTypeCastExpression($);
        return U.type !== "ArrowFunctionExpression" && b(), U.typeParameters = g, this.resetStartLocationFromNode(U, g), $;
      }, o);
      let S = null;
      if (T.node && this.maybeUnwrapTypeCastExpression(T.node).type === "ArrowFunctionExpression") {
        if (!T.error && !T.aborted)
          return T.node.async && this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, {
            at: g
          }), T.node;
        S = T.node;
      }
      if ((f = l) != null && f.node)
        return this.state = l.failState, l.node;
      if (S)
        return this.state = T.failState, S;
      throw (y = l) != null && y.thrown ? l.error : T.thrown ? T.error : this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, {
        at: g
      });
    }
    return super.parseMaybeAssign(s, i);
  }
  parseArrow(s) {
    if (this.match(14)) {
      const i = this.tryParse(() => {
        const a = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0;
        const o = this.startNode();
        return [o.typeAnnotation, s.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = a, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), o;
      });
      if (i.thrown)
        return null;
      i.error && (this.state = i.failState), s.returnType = i.node.typeAnnotation ? this.finishNode(i.node, "TypeAnnotation") : null;
    }
    return super.parseArrow(s);
  }
  shouldParseArrow(s) {
    return this.match(14) || super.shouldParseArrow(s);
  }
  setArrowFunctionParameters(s, i) {
    this.state.noArrowParamsConversionAt.indexOf(s.start) !== -1 ? s.params = i : super.setArrowFunctionParameters(s, i);
  }
  checkParams(s, i, a, o = !0) {
    if (!(a && this.state.noArrowParamsConversionAt.indexOf(s.start) !== -1)) {
      for (let l = 0; l < s.params.length; l++)
        this.isThisParam(s.params[l]) && l > 0 && this.raise(FlowErrors.ThisParamMustBeFirst, {
          at: s.params[l]
        });
      super.checkParams(s, i, a, o);
    }
  }
  parseParenAndDistinguishExpression(s) {
    return super.parseParenAndDistinguishExpression(s && this.state.noArrowAt.indexOf(this.state.start) === -1);
  }
  parseSubscripts(s, i, a) {
    if (s.type === "Identifier" && s.name === "async" && this.state.noArrowAt.indexOf(i.index) !== -1) {
      this.next();
      const o = this.startNodeAt(i);
      o.callee = s, o.arguments = super.parseCallExpressionArguments(11, !1), s = this.finishNode(o, "CallExpression");
    } else if (s.type === "Identifier" && s.name === "async" && this.match(47)) {
      const o = this.state.clone(), l = this.tryParse((y) => this.parseAsyncArrowWithTypeParameters(i) || y(), o);
      if (!l.error && !l.aborted)
        return l.node;
      const f = this.tryParse(() => super.parseSubscripts(s, i, a), o);
      if (f.node && !f.error)
        return f.node;
      if (l.node)
        return this.state = l.failState, l.node;
      if (f.node)
        return this.state = f.failState, f.node;
      throw l.error || f.error;
    }
    return super.parseSubscripts(s, i, a);
  }
  parseSubscript(s, i, a, o) {
    if (this.match(18) && this.isLookaheadToken_lt()) {
      if (o.optionalChainMember = !0, a)
        return o.stop = !0, s;
      this.next();
      const l = this.startNodeAt(i);
      return l.callee = s, l.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), l.arguments = this.parseCallExpressionArguments(11, !1), l.optional = !0, this.finishCallExpression(l, !0);
    } else if (!a && this.shouldParseTypes() && this.match(47)) {
      const l = this.startNodeAt(i);
      l.callee = s;
      const f = this.tryParse(() => (l.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), l.arguments = super.parseCallExpressionArguments(11, !1), o.optionalChainMember && (l.optional = !1), this.finishCallExpression(l, o.optionalChainMember)));
      if (f.node)
        return f.error && (this.state = f.failState), f.node;
    }
    return super.parseSubscript(s, i, a, o);
  }
  parseNewCallee(s) {
    super.parseNewCallee(s);
    let i = null;
    this.shouldParseTypes() && this.match(47) && (i = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), s.typeArguments = i;
  }
  parseAsyncArrowWithTypeParameters(s) {
    const i = this.startNodeAt(s);
    if (this.parseFunctionParams(i, !1), !!this.parseArrow(i))
      return super.parseArrowExpression(i, void 0, !0);
  }
  readToken_mult_modulo(s) {
    const i = this.input.charCodeAt(this.state.pos + 1);
    if (s === 42 && i === 47 && this.state.hasFlowComment) {
      this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
      return;
    }
    super.readToken_mult_modulo(s);
  }
  readToken_pipe_amp(s) {
    const i = this.input.charCodeAt(this.state.pos + 1);
    if (s === 124 && i === 125) {
      this.finishOp(9, 2);
      return;
    }
    super.readToken_pipe_amp(s);
  }
  parseTopLevel(s, i) {
    const a = super.parseTopLevel(s, i);
    return this.state.hasFlowComment && this.raise(FlowErrors.UnterminatedFlowComment, {
      at: this.state.curPosition()
    }), a;
  }
  skipBlockComment() {
    if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
      if (this.state.hasFlowComment)
        throw this.raise(FlowErrors.NestedFlowComment, {
          at: this.state.startLoc
        });
      this.hasFlowCommentCompletion();
      const s = this.skipFlowComment();
      s && (this.state.pos += s, this.state.hasFlowComment = !0);
      return;
    }
    return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
  }
  skipFlowComment() {
    const {
      pos: s
    } = this.state;
    let i = 2;
    for (; [32, 9].includes(this.input.charCodeAt(s + i)); )
      i++;
    const a = this.input.charCodeAt(i + s), o = this.input.charCodeAt(i + s + 1);
    return a === 58 && o === 58 ? i + 2 : this.input.slice(i + s, i + s + 12) === "flow-include" ? i + 12 : a === 58 && o !== 58 ? i : !1;
  }
  hasFlowCommentCompletion() {
    if (this.input.indexOf("*/", this.state.pos) === -1)
      throw this.raise(Errors.UnterminatedComment, {
        at: this.state.curPosition()
      });
  }
  flowEnumErrorBooleanMemberNotInitialized(s, {
    enumName: i,
    memberName: a
  }) {
    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, {
      at: s,
      memberName: a,
      enumName: i
    });
  }
  flowEnumErrorInvalidMemberInitializer(s, i) {
    return this.raise(i.explicitType ? i.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType : FlowErrors.EnumInvalidMemberInitializerUnknownType, Object.assign({
      at: s
    }, i));
  }
  flowEnumErrorNumberMemberNotInitialized(s, {
    enumName: i,
    memberName: a
  }) {
    this.raise(FlowErrors.EnumNumberMemberNotInitialized, {
      at: s,
      enumName: i,
      memberName: a
    });
  }
  flowEnumErrorStringMemberInconsistentlyInitialized(s, {
    enumName: i
  }) {
    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, {
      at: s,
      enumName: i
    });
  }
  flowEnumMemberInit() {
    const s = this.state.startLoc, i = () => this.match(12) || this.match(8);
    switch (this.state.type) {
      case 134: {
        const a = this.parseNumericLiteral(this.state.value);
        return i() ? {
          type: "number",
          loc: a.loc.start,
          value: a
        } : {
          type: "invalid",
          loc: s
        };
      }
      case 133: {
        const a = this.parseStringLiteral(this.state.value);
        return i() ? {
          type: "string",
          loc: a.loc.start,
          value: a
        } : {
          type: "invalid",
          loc: s
        };
      }
      case 85:
      case 86: {
        const a = this.parseBooleanLiteral(this.match(85));
        return i() ? {
          type: "boolean",
          loc: a.loc.start,
          value: a
        } : {
          type: "invalid",
          loc: s
        };
      }
      default:
        return {
          type: "invalid",
          loc: s
        };
    }
  }
  flowEnumMemberRaw() {
    const s = this.state.startLoc, i = this.parseIdentifier(!0), a = this.eat(29) ? this.flowEnumMemberInit() : {
      type: "none",
      loc: s
    };
    return {
      id: i,
      init: a
    };
  }
  flowEnumCheckExplicitTypeMismatch(s, i, a) {
    const {
      explicitType: o
    } = i;
    o !== null && o !== a && this.flowEnumErrorInvalidMemberInitializer(s, i);
  }
  flowEnumMembers({
    enumName: s,
    explicitType: i
  }) {
    const a = /* @__PURE__ */ new Set(), o = {
      booleanMembers: [],
      numberMembers: [],
      stringMembers: [],
      defaultedMembers: []
    };
    let l = !1;
    for (; !this.match(8); ) {
      if (this.eat(21)) {
        l = !0;
        break;
      }
      const f = this.startNode(), {
        id: y,
        init: g
      } = this.flowEnumMemberRaw(), T = y.name;
      if (T === "")
        continue;
      /^[a-z]/.test(T) && this.raise(FlowErrors.EnumInvalidMemberName, {
        at: y,
        memberName: T,
        suggestion: T[0].toUpperCase() + T.slice(1),
        enumName: s
      }), a.has(T) && this.raise(FlowErrors.EnumDuplicateMemberName, {
        at: y,
        memberName: T,
        enumName: s
      }), a.add(T);
      const S = {
        enumName: s,
        explicitType: i,
        memberName: T
      };
      switch (f.id = y, g.type) {
        case "boolean": {
          this.flowEnumCheckExplicitTypeMismatch(g.loc, S, "boolean"), f.init = g.value, o.booleanMembers.push(this.finishNode(f, "EnumBooleanMember"));
          break;
        }
        case "number": {
          this.flowEnumCheckExplicitTypeMismatch(g.loc, S, "number"), f.init = g.value, o.numberMembers.push(this.finishNode(f, "EnumNumberMember"));
          break;
        }
        case "string": {
          this.flowEnumCheckExplicitTypeMismatch(g.loc, S, "string"), f.init = g.value, o.stringMembers.push(this.finishNode(f, "EnumStringMember"));
          break;
        }
        case "invalid":
          throw this.flowEnumErrorInvalidMemberInitializer(g.loc, S);
        case "none":
          switch (i) {
            case "boolean":
              this.flowEnumErrorBooleanMemberNotInitialized(g.loc, S);
              break;
            case "number":
              this.flowEnumErrorNumberMemberNotInitialized(g.loc, S);
              break;
            default:
              o.defaultedMembers.push(this.finishNode(f, "EnumDefaultedMember"));
          }
      }
      this.match(8) || this.expect(12);
    }
    return {
      members: o,
      hasUnknownMembers: l
    };
  }
  flowEnumStringMembers(s, i, {
    enumName: a
  }) {
    if (s.length === 0)
      return i;
    if (i.length === 0)
      return s;
    if (i.length > s.length) {
      for (const o of s)
        this.flowEnumErrorStringMemberInconsistentlyInitialized(o, {
          enumName: a
        });
      return i;
    } else {
      for (const o of i)
        this.flowEnumErrorStringMemberInconsistentlyInitialized(o, {
          enumName: a
        });
      return s;
    }
  }
  flowEnumParseExplicitType({
    enumName: s
  }) {
    if (!this.eatContextual(102))
      return null;
    if (!tokenIsIdentifier(this.state.type))
      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, {
        at: this.state.startLoc,
        enumName: s
      });
    const {
      value: i
    } = this.state;
    return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(FlowErrors.EnumInvalidExplicitType, {
      at: this.state.startLoc,
      enumName: s,
      invalidEnumType: i
    }), i;
  }
  flowEnumBody(s, i) {
    const a = i.name, o = i.loc.start, l = this.flowEnumParseExplicitType({
      enumName: a
    });
    this.expect(5);
    const {
      members: f,
      hasUnknownMembers: y
    } = this.flowEnumMembers({
      enumName: a,
      explicitType: l
    });
    switch (s.hasUnknownMembers = y, l) {
      case "boolean":
        return s.explicitType = !0, s.members = f.booleanMembers, this.expect(8), this.finishNode(s, "EnumBooleanBody");
      case "number":
        return s.explicitType = !0, s.members = f.numberMembers, this.expect(8), this.finishNode(s, "EnumNumberBody");
      case "string":
        return s.explicitType = !0, s.members = this.flowEnumStringMembers(f.stringMembers, f.defaultedMembers, {
          enumName: a
        }), this.expect(8), this.finishNode(s, "EnumStringBody");
      case "symbol":
        return s.members = f.defaultedMembers, this.expect(8), this.finishNode(s, "EnumSymbolBody");
      default: {
        const g = () => (s.members = [], this.expect(8), this.finishNode(s, "EnumStringBody"));
        s.explicitType = !1;
        const T = f.booleanMembers.length, S = f.numberMembers.length, b = f.stringMembers.length, v = f.defaultedMembers.length;
        if (!T && !S && !b && !v)
          return g();
        if (!T && !S)
          return s.members = this.flowEnumStringMembers(f.stringMembers, f.defaultedMembers, {
            enumName: a
          }), this.expect(8), this.finishNode(s, "EnumStringBody");
        if (!S && !b && T >= v) {
          for (const $ of f.defaultedMembers)
            this.flowEnumErrorBooleanMemberNotInitialized($.loc.start, {
              enumName: a,
              memberName: $.id.name
            });
          return s.members = f.booleanMembers, this.expect(8), this.finishNode(s, "EnumBooleanBody");
        } else if (!T && !b && S >= v) {
          for (const $ of f.defaultedMembers)
            this.flowEnumErrorNumberMemberNotInitialized($.loc.start, {
              enumName: a,
              memberName: $.id.name
            });
          return s.members = f.numberMembers, this.expect(8), this.finishNode(s, "EnumNumberBody");
        } else
          return this.raise(FlowErrors.EnumInconsistentMemberValues, {
            at: o,
            enumName: a
          }), g();
      }
    }
  }
  flowParseEnumDeclaration(s) {
    const i = this.parseIdentifier();
    return s.id = i, s.body = this.flowEnumBody(this.startNode(), i), this.finishNode(s, "EnumDeclaration");
  }
  isLookaheadToken_lt() {
    const s = this.nextTokenStart();
    if (this.input.charCodeAt(s) === 60) {
      const i = this.input.charCodeAt(s + 1);
      return i !== 60 && i !== 61;
    }
    return !1;
  }
  maybeUnwrapTypeCastExpression(s) {
    return s.type === "TypeCastExpression" ? s.expression : s;
  }
};
const entities = {
  __proto__: null,
  quot: '"',
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  fnof: "ƒ",
  circ: "ˆ",
  tilde: "˜",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  bull: "•",
  hellip: "…",
  permil: "‰",
  prime: "′",
  Prime: "″",
  lsaquo: "‹",
  rsaquo: "›",
  oline: "‾",
  frasl: "⁄",
  euro: "€",
  image: "ℑ",
  weierp: "℘",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦"
}, JsxErrors = ParseErrorEnum`jsx`({
  AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
  MissingClosingTagElement: ({
    openingTagName: e
  }) => `Expected corresponding JSX closing tag for <${e}>.`,
  MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
  UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
  UnexpectedToken: ({
    unexpected: e,
    HTMLEntity: t
  }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`,
  UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
  UnterminatedJsxContent: "Unterminated JSX contents.",
  UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
});
function isFragment(e) {
  return e ? e.type === "JSXOpeningFragment" || e.type === "JSXClosingFragment" : !1;
}
function getQualifiedJSXName(e) {
  if (e.type === "JSXIdentifier")
    return e.name;
  if (e.type === "JSXNamespacedName")
    return e.namespace.name + ":" + e.name.name;
  if (e.type === "JSXMemberExpression")
    return getQualifiedJSXName(e.object) + "." + getQualifiedJSXName(e.property);
  throw new Error("Node had unexpected type: " + e.type);
}
var jsx = (e) => class extends e {
  jsxReadToken() {
    let s = "", i = this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(JsxErrors.UnterminatedJsxContent, {
          at: this.state.startLoc
        });
      const a = this.input.charCodeAt(this.state.pos);
      switch (a) {
        case 60:
        case 123:
          if (this.state.pos === this.state.start) {
            a === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(a);
            return;
          }
          s += this.input.slice(i, this.state.pos), this.finishToken(141, s);
          return;
        case 38:
          s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos;
          break;
        case 62:
        case 125:
        default:
          isNewLine(a) ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadNewLine(!0), i = this.state.pos) : ++this.state.pos;
      }
    }
  }
  jsxReadNewLine(s) {
    const i = this.input.charCodeAt(this.state.pos);
    let a;
    return ++this.state.pos, i === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, a = s ? `
` : `\r
`) : a = String.fromCharCode(i), ++this.state.curLine, this.state.lineStart = this.state.pos, a;
  }
  jsxReadString(s) {
    let i = "", a = ++this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(Errors.UnterminatedString, {
          at: this.state.startLoc
        });
      const o = this.input.charCodeAt(this.state.pos);
      if (o === s)
        break;
      o === 38 ? (i += this.input.slice(a, this.state.pos), i += this.jsxReadEntity(), a = this.state.pos) : isNewLine(o) ? (i += this.input.slice(a, this.state.pos), i += this.jsxReadNewLine(!1), a = this.state.pos) : ++this.state.pos;
    }
    i += this.input.slice(a, this.state.pos++), this.finishToken(133, i);
  }
  jsxReadEntity() {
    const s = ++this.state.pos;
    if (this.codePointAtPos(this.state.pos) === 35) {
      ++this.state.pos;
      let i = 10;
      this.codePointAtPos(this.state.pos) === 120 && (i = 16, ++this.state.pos);
      const a = this.readInt(i, void 0, !1, "bail");
      if (a !== null && this.codePointAtPos(this.state.pos) === 59)
        return ++this.state.pos, String.fromCodePoint(a);
    } else {
      let i = 0, a = !1;
      for (; i++ < 10 && this.state.pos < this.length && !(a = this.codePointAtPos(this.state.pos) == 59); )
        ++this.state.pos;
      if (a) {
        const o = this.input.slice(s, this.state.pos), l = entities[o];
        if (++this.state.pos, l)
          return l;
      }
    }
    return this.state.pos = s, "&";
  }
  jsxReadWord() {
    let s;
    const i = this.state.pos;
    do
      s = this.input.charCodeAt(++this.state.pos);
    while (isIdentifierChar(s) || s === 45);
    this.finishToken(140, this.input.slice(i, this.state.pos));
  }
  jsxParseIdentifier() {
    const s = this.startNode();
    return this.match(140) ? s.name = this.state.value : tokenIsKeyword(this.state.type) ? s.name = tokenLabelName(this.state.type) : this.unexpected(), this.next(), this.finishNode(s, "JSXIdentifier");
  }
  jsxParseNamespacedName() {
    const s = this.state.startLoc, i = this.jsxParseIdentifier();
    if (!this.eat(14))
      return i;
    const a = this.startNodeAt(s);
    return a.namespace = i, a.name = this.jsxParseIdentifier(), this.finishNode(a, "JSXNamespacedName");
  }
  jsxParseElementName() {
    const s = this.state.startLoc;
    let i = this.jsxParseNamespacedName();
    if (i.type === "JSXNamespacedName")
      return i;
    for (; this.eat(16); ) {
      const a = this.startNodeAt(s);
      a.object = i, a.property = this.jsxParseIdentifier(), i = this.finishNode(a, "JSXMemberExpression");
    }
    return i;
  }
  jsxParseAttributeValue() {
    let s;
    switch (this.state.type) {
      case 5:
        return s = this.startNode(), this.setContext(types.brace), this.next(), s = this.jsxParseExpressionContainer(s, types.j_oTag), s.expression.type === "JSXEmptyExpression" && this.raise(JsxErrors.AttributeIsEmpty, {
          at: s
        }), s;
      case 142:
      case 133:
        return this.parseExprAtom();
      default:
        throw this.raise(JsxErrors.UnsupportedJsxValue, {
          at: this.state.startLoc
        });
    }
  }
  jsxParseEmptyExpression() {
    const s = this.startNodeAt(this.state.lastTokEndLoc);
    return this.finishNodeAt(s, "JSXEmptyExpression", this.state.startLoc);
  }
  jsxParseSpreadChild(s) {
    return this.next(), s.expression = this.parseExpression(), this.setContext(types.j_expr), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(s, "JSXSpreadChild");
  }
  jsxParseExpressionContainer(s, i) {
    if (this.match(8))
      s.expression = this.jsxParseEmptyExpression();
    else {
      const a = this.parseExpression();
      s.expression = a;
    }
    return this.setContext(i), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(s, "JSXExpressionContainer");
  }
  jsxParseAttribute() {
    const s = this.startNode();
    return this.match(5) ? (this.setContext(types.brace), this.next(), this.expect(21), s.argument = this.parseMaybeAssignAllowIn(), this.setContext(types.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(s, "JSXSpreadAttribute")) : (s.name = this.jsxParseNamespacedName(), s.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(s, "JSXAttribute"));
  }
  jsxParseOpeningElementAt(s) {
    const i = this.startNodeAt(s);
    return this.eat(143) ? this.finishNode(i, "JSXOpeningFragment") : (i.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(i));
  }
  jsxParseOpeningElementAfterName(s) {
    const i = [];
    for (; !this.match(56) && !this.match(143); )
      i.push(this.jsxParseAttribute());
    return s.attributes = i, s.selfClosing = this.eat(56), this.expect(143), this.finishNode(s, "JSXOpeningElement");
  }
  jsxParseClosingElementAt(s) {
    const i = this.startNodeAt(s);
    return this.eat(143) ? this.finishNode(i, "JSXClosingFragment") : (i.name = this.jsxParseElementName(), this.expect(143), this.finishNode(i, "JSXClosingElement"));
  }
  jsxParseElementAt(s) {
    const i = this.startNodeAt(s), a = [], o = this.jsxParseOpeningElementAt(s);
    let l = null;
    if (!o.selfClosing) {
      e:
        for (; ; )
          switch (this.state.type) {
            case 142:
              if (s = this.state.startLoc, this.next(), this.eat(56)) {
                l = this.jsxParseClosingElementAt(s);
                break e;
              }
              a.push(this.jsxParseElementAt(s));
              break;
            case 141:
              a.push(this.parseExprAtom());
              break;
            case 5: {
              const f = this.startNode();
              this.setContext(types.brace), this.next(), this.match(21) ? a.push(this.jsxParseSpreadChild(f)) : a.push(this.jsxParseExpressionContainer(f, types.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
      isFragment(o) && !isFragment(l) && l !== null ? this.raise(JsxErrors.MissingClosingTagFragment, {
        at: l
      }) : !isFragment(o) && isFragment(l) ? this.raise(JsxErrors.MissingClosingTagElement, {
        at: l,
        openingTagName: getQualifiedJSXName(o.name)
      }) : !isFragment(o) && !isFragment(l) && getQualifiedJSXName(l.name) !== getQualifiedJSXName(o.name) && this.raise(JsxErrors.MissingClosingTagElement, {
        at: l,
        openingTagName: getQualifiedJSXName(o.name)
      });
    }
    if (isFragment(o) ? (i.openingFragment = o, i.closingFragment = l) : (i.openingElement = o, i.closingElement = l), i.children = a, this.match(47))
      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, {
        at: this.state.startLoc
      });
    return isFragment(o) ? this.finishNode(i, "JSXFragment") : this.finishNode(i, "JSXElement");
  }
  jsxParseElement() {
    const s = this.state.startLoc;
    return this.next(), this.jsxParseElementAt(s);
  }
  setContext(s) {
    const {
      context: i
    } = this.state;
    i[i.length - 1] = s;
  }
  parseExprAtom(s) {
    return this.match(141) ? this.parseLiteral(this.state.value, "JSXText") : this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(s);
  }
  skipSpace() {
    this.curContext().preserveSpace || super.skipSpace();
  }
  getTokenFromCode(s) {
    const i = this.curContext();
    if (i === types.j_expr) {
      this.jsxReadToken();
      return;
    }
    if (i === types.j_oTag || i === types.j_cTag) {
      if (isIdentifierStart(s)) {
        this.jsxReadWord();
        return;
      }
      if (s === 62) {
        ++this.state.pos, this.finishToken(143);
        return;
      }
      if ((s === 34 || s === 39) && i === types.j_oTag) {
        this.jsxReadString(s);
        return;
      }
    }
    if (s === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
      ++this.state.pos, this.finishToken(142);
      return;
    }
    super.getTokenFromCode(s);
  }
  updateContext(s) {
    const {
      context: i,
      type: a
    } = this.state;
    if (a === 56 && s === 142)
      i.splice(-2, 2, types.j_cTag), this.state.canStartJSXElement = !1;
    else if (a === 142)
      i.push(types.j_oTag);
    else if (a === 143) {
      const o = i[i.length - 1];
      o === types.j_oTag && s === 56 || o === types.j_cTag ? (i.pop(), this.state.canStartJSXElement = i[i.length - 1] === types.j_expr) : (this.setContext(types.j_expr), this.state.canStartJSXElement = !0);
    } else
      this.state.canStartJSXElement = tokenComesBeforeExpression(a);
  }
};
class TypeScriptScope extends Scope {
  constructor(...t) {
    super(...t), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
  }
}
class TypeScriptScopeHandler extends ScopeHandler {
  constructor(...t) {
    super(...t), this.importsStack = [];
  }
  createScope(t) {
    return this.importsStack.push(/* @__PURE__ */ new Set()), new TypeScriptScope(t);
  }
  enter(t) {
    t == 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
  }
  exit() {
    const t = super.exit();
    return t == 256 && this.importsStack.pop(), t;
  }
  hasImport(t, s) {
    const i = this.importsStack.length;
    if (this.importsStack[i - 1].has(t))
      return !0;
    if (!s && i > 1) {
      for (let a = 0; a < i - 1; a++)
        if (this.importsStack[a].has(t))
          return !0;
    }
    return !1;
  }
  declareName(t, s, i) {
    if (s & 4096) {
      this.hasImport(t, !0) && this.parser.raise(Errors.VarRedeclaration, {
        at: i,
        identifierName: t
      }), this.importsStack[this.importsStack.length - 1].add(t);
      return;
    }
    const a = this.currentScope();
    if (s & 1024) {
      this.maybeExportDefined(a, t), a.exportOnlyBindings.add(t);
      return;
    }
    super.declareName(t, s, i), s & 2 && (s & 1 || (this.checkRedeclarationInScope(a, t, s, i), this.maybeExportDefined(a, t)), a.types.add(t)), s & 256 && a.enums.add(t), s & 512 && a.constEnums.add(t), s & 128 && a.classes.add(t);
  }
  isRedeclaredInScope(t, s, i) {
    if (t.enums.has(s)) {
      if (i & 256) {
        const a = !!(i & 512), o = t.constEnums.has(s);
        return a !== o;
      }
      return !0;
    }
    return i & 128 && t.classes.has(s) ? t.lexical.has(s) ? !!(i & 1) : !1 : i & 2 && t.types.has(s) ? !0 : super.isRedeclaredInScope(t, s, i);
  }
  checkLocalExport(t) {
    const {
      name: s
    } = t;
    if (this.hasImport(s))
      return;
    const i = this.scopeStack.length;
    for (let a = i - 1; a >= 0; a--) {
      const o = this.scopeStack[a];
      if (o.types.has(s) || o.exportOnlyBindings.has(s))
        return;
    }
    super.checkLocalExport(t);
  }
}
const getOwn$1 = (e, t) => Object.hasOwnProperty.call(e, t) && e[t], unwrapParenthesizedExpression = (e) => e.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(e.expression) : e;
class LValParser extends NodeUtils {
  toAssignable(t, s = !1) {
    var i, a;
    let o;
    switch ((t.type === "ParenthesizedExpression" || (i = t.extra) != null && i.parenthesized) && (o = unwrapParenthesizedExpression(t), s ? o.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, {
      at: t
    }) : o.type !== "MemberExpression" && !this.isOptionalMemberExpression(o) && this.raise(Errors.InvalidParenthesizedAssignment, {
      at: t
    }) : this.raise(Errors.InvalidParenthesizedAssignment, {
      at: t
    })), t.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        t.type = "ObjectPattern";
        for (let f = 0, y = t.properties.length, g = y - 1; f < y; f++) {
          var l;
          const T = t.properties[f], S = f === g;
          this.toAssignableObjectExpressionProp(T, S, s), S && T.type === "RestElement" && (l = t.extra) != null && l.trailingCommaLoc && this.raise(Errors.RestTrailingComma, {
            at: t.extra.trailingCommaLoc
          });
        }
        break;
      case "ObjectProperty": {
        const {
          key: f,
          value: y
        } = t;
        this.isPrivateName(f) && this.classScope.usePrivateName(this.getPrivateNameSV(f), f.loc.start), this.toAssignable(y, s);
        break;
      }
      case "SpreadElement":
        throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
      case "ArrayExpression":
        t.type = "ArrayPattern", this.toAssignableList(t.elements, (a = t.extra) == null ? void 0 : a.trailingCommaLoc, s);
        break;
      case "AssignmentExpression":
        t.operator !== "=" && this.raise(Errors.MissingEqInAssignment, {
          at: t.left.loc.end
        }), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, s);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(o, s);
        break;
    }
  }
  toAssignableObjectExpressionProp(t, s, i) {
    if (t.type === "ObjectMethod")
      this.raise(t.kind === "get" || t.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, {
        at: t.key
      });
    else if (t.type === "SpreadElement") {
      t.type = "RestElement";
      const a = t.argument;
      this.checkToRestConversion(a, !1), this.toAssignable(a, i), s || this.raise(Errors.RestTrailingComma, {
        at: t
      });
    } else
      this.toAssignable(t, i);
  }
  toAssignableList(t, s, i) {
    const a = t.length - 1;
    for (let o = 0; o <= a; o++) {
      const l = t[o];
      if (l) {
        if (l.type === "SpreadElement") {
          l.type = "RestElement";
          const f = l.argument;
          this.checkToRestConversion(f, !0), this.toAssignable(f, i);
        } else
          this.toAssignable(l, i);
        l.type === "RestElement" && (o < a ? this.raise(Errors.RestTrailingComma, {
          at: l
        }) : s && this.raise(Errors.RestTrailingComma, {
          at: s
        }));
      }
    }
  }
  isAssignable(t, s) {
    switch (t.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        return !0;
      case "ObjectExpression": {
        const i = t.properties.length - 1;
        return t.properties.every((a, o) => a.type !== "ObjectMethod" && (o === i || a.type !== "SpreadElement") && this.isAssignable(a));
      }
      case "ObjectProperty":
        return this.isAssignable(t.value);
      case "SpreadElement":
        return this.isAssignable(t.argument);
      case "ArrayExpression":
        return t.elements.every((i) => i === null || this.isAssignable(i));
      case "AssignmentExpression":
        return t.operator === "=";
      case "ParenthesizedExpression":
        return this.isAssignable(t.expression);
      case "MemberExpression":
      case "OptionalMemberExpression":
        return !s;
      default:
        return !1;
    }
  }
  toReferencedList(t, s) {
    return t;
  }
  toReferencedListDeep(t, s) {
    this.toReferencedList(t, s);
    for (const i of t)
      (i == null ? void 0 : i.type) === "ArrayExpression" && this.toReferencedListDeep(i.elements);
  }
  parseSpread(t) {
    const s = this.startNode();
    return this.next(), s.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(s, "SpreadElement");
  }
  parseRestBinding() {
    const t = this.startNode();
    return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case 0: {
        const t = this.startNode();
        return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
      }
      case 5:
        return this.parseObjectLike(8, !0);
    }
    return this.parseIdentifier();
  }
  parseBindingList(t, s, i) {
    const a = i & 1, o = [];
    let l = !0;
    for (; !this.eat(t); )
      if (l ? l = !1 : this.expect(12), a && this.match(12))
        o.push(null);
      else {
        if (this.eat(t))
          break;
        if (this.match(21)) {
          if (o.push(this.parseAssignableListItemTypes(this.parseRestBinding(), i)), !this.checkCommaAfterRest(s)) {
            this.expect(t);
            break;
          }
        } else {
          const f = [];
          for (this.match(26) && this.hasPlugin("decorators") && this.raise(Errors.UnsupportedParameterDecorator, {
            at: this.state.startLoc
          }); this.match(26); )
            f.push(this.parseDecorator());
          o.push(this.parseAssignableListItem(i, f));
        }
      }
    return o;
  }
  parseBindingRestProperty(t) {
    return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
  }
  parseBindingProperty() {
    const t = this.startNode(), {
      type: s,
      startLoc: i
    } = this.state;
    return s === 21 ? this.parseBindingRestProperty(t) : (s === 138 ? (this.expectPlugin("destructuringPrivate", i), this.classScope.usePrivateName(this.state.value, i), t.key = this.parsePrivateName()) : this.parsePropertyName(t), t.method = !1, this.parseObjPropValue(t, i, !1, !1, !0, !1));
  }
  parseAssignableListItem(t, s) {
    const i = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(i, t);
    const a = this.parseMaybeDefault(i.loc.start, i);
    return s.length && (i.decorators = s), a;
  }
  parseAssignableListItemTypes(t, s) {
    return t;
  }
  parseMaybeDefault(t, s) {
    var i, a;
    if ((i = t) != null || (t = this.state.startLoc), s = (a = s) != null ? a : this.parseBindingAtom(), !this.eat(29))
      return s;
    const o = this.startNodeAt(t);
    return o.left = s, o.right = this.parseMaybeAssignAllowIn(), this.finishNode(o, "AssignmentPattern");
  }
  isValidLVal(t, s, i) {
    return getOwn$1({
      AssignmentPattern: "left",
      RestElement: "argument",
      ObjectProperty: "value",
      ParenthesizedExpression: "expression",
      ArrayPattern: "elements",
      ObjectPattern: "properties"
    }, t);
  }
  isOptionalMemberExpression(t) {
    return t.type === "OptionalMemberExpression";
  }
  checkLVal(t, {
    in: s,
    binding: i = 64,
    checkClashes: a = !1,
    strictModeChanged: o = !1,
    hasParenthesizedAncestor: l = !1
  }) {
    var f;
    const y = t.type;
    if (this.isObjectMethod(t))
      return;
    const g = this.isOptionalMemberExpression(t);
    if (g || y === "MemberExpression") {
      g && (this.expectPlugin("optionalChainingAssign", t.loc.start), s.type !== "AssignmentExpression" && this.raise(Errors.InvalidLhsOptionalChaining, {
        at: t,
        ancestor: s
      })), i !== 64 && this.raise(Errors.InvalidPropertyBindingPattern, {
        at: t
      });
      return;
    }
    if (y === "Identifier") {
      this.checkIdentifier(t, i, o);
      const {
        name: $
      } = t;
      a && (a.has($) ? this.raise(Errors.ParamDupe, {
        at: t
      }) : a.add($));
      return;
    }
    const T = this.isValidLVal(y, !(l || (f = t.extra) != null && f.parenthesized) && s.type === "AssignmentExpression", i);
    if (T === !0)
      return;
    if (T === !1) {
      const $ = i === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
      this.raise($, {
        at: t,
        ancestor: s
      });
      return;
    }
    const [S, b] = Array.isArray(T) ? T : [T, y === "ParenthesizedExpression"], v = y === "ArrayPattern" || y === "ObjectPattern" ? {
      type: y
    } : s;
    for (const $ of [].concat(t[S]))
      $ && this.checkLVal($, {
        in: v,
        binding: i,
        checkClashes: a,
        strictModeChanged: o,
        hasParenthesizedAncestor: b
      });
  }
  checkIdentifier(t, s, i = !1) {
    this.state.strict && (i ? isStrictBindReservedWord(t.name, this.inModule) : isStrictBindOnlyReservedWord(t.name)) && (s === 64 ? this.raise(Errors.StrictEvalArguments, {
      at: t,
      referenceName: t.name
    }) : this.raise(Errors.StrictEvalArgumentsBinding, {
      at: t,
      bindingName: t.name
    })), s & 8192 && t.name === "let" && this.raise(Errors.LetInLexicalBinding, {
      at: t
    }), s & 64 || this.declareNameFromIdentifier(t, s);
  }
  declareNameFromIdentifier(t, s) {
    this.scope.declareName(t.name, s, t.loc.start);
  }
  checkToRestConversion(t, s) {
    switch (t.type) {
      case "ParenthesizedExpression":
        this.checkToRestConversion(t.expression, s);
        break;
      case "Identifier":
      case "MemberExpression":
        break;
      case "ArrayExpression":
      case "ObjectExpression":
        if (s)
          break;
      default:
        this.raise(Errors.InvalidRestAssignmentPattern, {
          at: t
        });
    }
  }
  checkCommaAfterRest(t) {
    return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? Errors.RestTrailingComma : Errors.ElementAfterRest, {
      at: this.state.startLoc
    }), !0) : !1;
  }
}
const getOwn = (e, t) => Object.hasOwnProperty.call(e, t) && e[t];
function nonNull(e) {
  if (e == null)
    throw new Error(`Unexpected ${e} value.`);
  return e;
}
function assert(e) {
  if (!e)
    throw new Error("Assert fail");
}
const TSErrors = ParseErrorEnum`typescript`({
  AbstractMethodHasImplementation: ({
    methodName: e
  }) => `Method '${e}' cannot have an implementation because it is marked abstract.`,
  AbstractPropertyHasInitializer: ({
    propertyName: e
  }) => `Property '${e}' cannot have an initializer because it is marked abstract.`,
  AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
  AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
  DeclareAccessor: ({
    kind: e
  }) => `'declare' is not allowed in ${e}ters.`,
  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
  DuplicateAccessibilityModifier: ({
    modifier: e
  }) => "Accessibility modifier already seen.",
  DuplicateModifier: ({
    modifier: e
  }) => `Duplicate modifier: '${e}'.`,
  EmptyHeritageClauseType: ({
    token: e
  }) => `'${e}' list cannot be empty.`,
  EmptyTypeArguments: "Type argument list cannot be empty.",
  EmptyTypeParameters: "Type parameter list cannot be empty.",
  ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
  ImportAliasHasImportType: "An import alias can not use 'import type'.",
  ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
  IncompatibleModifiers: ({
    modifiers: e
  }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`,
  IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
  IndexSignatureHasAccessibility: ({
    modifier: e
  }) => `Index signatures cannot have an accessibility modifier ('${e}').`,
  IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
  IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
  IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
  InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
  InvalidModifierOnTypeMember: ({
    modifier: e
  }) => `'${e}' modifier cannot appear on a type member.`,
  InvalidModifierOnTypeParameter: ({
    modifier: e
  }) => `'${e}' modifier cannot appear on a type parameter.`,
  InvalidModifierOnTypeParameterPositions: ({
    modifier: e
  }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`,
  InvalidModifiersOrder: ({
    orderedModifiers: e
  }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`,
  InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
  MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
  NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
  OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
  PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
  PrivateElementHasAccessibility: ({
    modifier: e
  }) => `Private elements cannot have an accessibility modifier ('${e}').`,
  ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
  SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
  SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
  SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
  SingleTypeParameterWithoutTrailingComma: ({
    typeParameterName: e
  }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`,
  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
  TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
  TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
  TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
  UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
  UnsupportedSignatureParameterKind: ({
    type: e
  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`
});
function keywordTypeFromName(e) {
  switch (e) {
    case "any":
      return "TSAnyKeyword";
    case "boolean":
      return "TSBooleanKeyword";
    case "bigint":
      return "TSBigIntKeyword";
    case "never":
      return "TSNeverKeyword";
    case "number":
      return "TSNumberKeyword";
    case "object":
      return "TSObjectKeyword";
    case "string":
      return "TSStringKeyword";
    case "symbol":
      return "TSSymbolKeyword";
    case "undefined":
      return "TSUndefinedKeyword";
    case "unknown":
      return "TSUnknownKeyword";
    default:
      return;
  }
}
function tsIsAccessModifier(e) {
  return e === "private" || e === "public" || e === "protected";
}
function tsIsVarianceAnnotations(e) {
  return e === "in" || e === "out";
}
var typescript$1 = (e) => class extends e {
  constructor(...s) {
    super(...s), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["in", "out"],
      disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
      errorTemplate: TSErrors.InvalidModifierOnTypeParameter
    }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["const"],
      disallowedModifiers: ["in", "out"],
      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
    }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
      allowedModifiers: ["in", "out", "const"],
      disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
      errorTemplate: TSErrors.InvalidModifierOnTypeParameter
    });
  }
  getScopeHandler() {
    return TypeScriptScopeHandler;
  }
  tsIsIdentifier() {
    return tokenIsIdentifier(this.state.type);
  }
  tsTokenCanFollowModifier() {
    return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
  }
  tsNextTokenCanFollowModifier() {
    return this.next(), this.tsTokenCanFollowModifier();
  }
  tsParseModifier(s, i) {
    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
      return;
    const a = this.state.value;
    if (s.indexOf(a) !== -1) {
      if (i && this.tsIsStartOfStaticBlocks())
        return;
      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
        return a;
    }
  }
  tsParseModifiers({
    allowedModifiers: s,
    disallowedModifiers: i,
    stopOnStartOfClassStaticBlock: a,
    errorTemplate: o = TSErrors.InvalidModifierOnTypeMember
  }, l) {
    const f = (g, T, S, b) => {
      T === S && l[b] && this.raise(TSErrors.InvalidModifiersOrder, {
        at: g,
        orderedModifiers: [S, b]
      });
    }, y = (g, T, S, b) => {
      (l[S] && T === b || l[b] && T === S) && this.raise(TSErrors.IncompatibleModifiers, {
        at: g,
        modifiers: [S, b]
      });
    };
    for (; ; ) {
      const {
        startLoc: g
      } = this.state, T = this.tsParseModifier(s.concat(i ?? []), a);
      if (!T)
        break;
      tsIsAccessModifier(T) ? l.accessibility ? this.raise(TSErrors.DuplicateAccessibilityModifier, {
        at: g,
        modifier: T
      }) : (f(g, T, T, "override"), f(g, T, T, "static"), f(g, T, T, "readonly"), l.accessibility = T) : tsIsVarianceAnnotations(T) ? (l[T] && this.raise(TSErrors.DuplicateModifier, {
        at: g,
        modifier: T
      }), l[T] = !0, f(g, T, "in", "out")) : (Object.hasOwnProperty.call(l, T) ? this.raise(TSErrors.DuplicateModifier, {
        at: g,
        modifier: T
      }) : (f(g, T, "static", "readonly"), f(g, T, "static", "override"), f(g, T, "override", "readonly"), f(g, T, "abstract", "override"), y(g, T, "declare", "override"), y(g, T, "static", "abstract")), l[T] = !0), i != null && i.includes(T) && this.raise(o, {
        at: g,
        modifier: T
      });
    }
  }
  tsIsListTerminator(s) {
    switch (s) {
      case "EnumMembers":
      case "TypeMembers":
        return this.match(8);
      case "HeritageClauseElement":
        return this.match(5);
      case "TupleElementTypes":
        return this.match(3);
      case "TypeParametersOrArguments":
        return this.match(48);
    }
  }
  tsParseList(s, i) {
    const a = [];
    for (; !this.tsIsListTerminator(s); )
      a.push(i());
    return a;
  }
  tsParseDelimitedList(s, i, a) {
    return nonNull(this.tsParseDelimitedListWorker(s, i, !0, a));
  }
  tsParseDelimitedListWorker(s, i, a, o) {
    const l = [];
    let f = -1;
    for (; !this.tsIsListTerminator(s); ) {
      f = -1;
      const y = i();
      if (y == null)
        return;
      if (l.push(y), this.eat(12)) {
        f = this.state.lastTokStart;
        continue;
      }
      if (this.tsIsListTerminator(s))
        break;
      a && this.expect(12);
      return;
    }
    return o && (o.value = f), l;
  }
  tsParseBracketedList(s, i, a, o, l) {
    o || (a ? this.expect(0) : this.expect(47));
    const f = this.tsParseDelimitedList(s, i, l);
    return a ? this.expect(3) : this.expect(48), f;
  }
  tsParseImportType() {
    const s = this.startNode();
    return this.expect(83), this.expect(10), this.match(133) || this.raise(TSErrors.UnsupportedImportTypeArgument, {
      at: this.state.startLoc
    }), s.argument = super.parseExprAtom(), this.expect(11), this.eat(16) && (s.qualifier = this.tsParseEntityName()), this.match(47) && (s.typeParameters = this.tsParseTypeArguments()), this.finishNode(s, "TSImportType");
  }
  tsParseEntityName(s = !0) {
    let i = this.parseIdentifier(s);
    for (; this.eat(16); ) {
      const a = this.startNodeAtNode(i);
      a.left = i, a.right = this.parseIdentifier(s), i = this.finishNode(a, "TSQualifiedName");
    }
    return i;
  }
  tsParseTypeReference() {
    const s = this.startNode();
    return s.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (s.typeParameters = this.tsParseTypeArguments()), this.finishNode(s, "TSTypeReference");
  }
  tsParseThisTypePredicate(s) {
    this.next();
    const i = this.startNodeAtNode(s);
    return i.parameterName = s, i.typeAnnotation = this.tsParseTypeAnnotation(!1), i.asserts = !1, this.finishNode(i, "TSTypePredicate");
  }
  tsParseThisTypeNode() {
    const s = this.startNode();
    return this.next(), this.finishNode(s, "TSThisType");
  }
  tsParseTypeQuery() {
    const s = this.startNode();
    return this.expect(87), this.match(83) ? s.exprName = this.tsParseImportType() : s.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (s.typeParameters = this.tsParseTypeArguments()), this.finishNode(s, "TSTypeQuery");
  }
  tsParseTypeParameter(s) {
    const i = this.startNode();
    return s(i), i.name = this.tsParseTypeParameterName(), i.constraint = this.tsEatThenParseType(81), i.default = this.tsEatThenParseType(29), this.finishNode(i, "TSTypeParameter");
  }
  tsTryParseTypeParameters(s) {
    if (this.match(47))
      return this.tsParseTypeParameters(s);
  }
  tsParseTypeParameters(s) {
    const i = this.startNode();
    this.match(47) || this.match(142) ? this.next() : this.unexpected();
    const a = {
      value: -1
    };
    return i.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, s), !1, !0, a), i.params.length === 0 && this.raise(TSErrors.EmptyTypeParameters, {
      at: i
    }), a.value !== -1 && this.addExtra(i, "trailingComma", a.value), this.finishNode(i, "TSTypeParameterDeclaration");
  }
  tsFillSignature(s, i) {
    const a = s === 19, o = "parameters", l = "typeAnnotation";
    i.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), i[o] = this.tsParseBindingListForSignature(), a ? i[l] = this.tsParseTypeOrTypePredicateAnnotation(s) : this.match(s) && (i[l] = this.tsParseTypeOrTypePredicateAnnotation(s));
  }
  tsParseBindingListForSignature() {
    const s = super.parseBindingList(11, 41, 2);
    for (const i of s) {
      const {
        type: a
      } = i;
      (a === "AssignmentPattern" || a === "TSParameterProperty") && this.raise(TSErrors.UnsupportedSignatureParameterKind, {
        at: i,
        type: a
      });
    }
    return s;
  }
  tsParseTypeMemberSemicolon() {
    !this.eat(12) && !this.isLineTerminator() && this.expect(13);
  }
  tsParseSignatureMember(s, i) {
    return this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon(), this.finishNode(i, s);
  }
  tsIsUnambiguouslyIndexSignature() {
    return this.next(), tokenIsIdentifier(this.state.type) ? (this.next(), this.match(14)) : !1;
  }
  tsTryParseIndexSignature(s) {
    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
      return;
    this.expect(0);
    const i = this.parseIdentifier();
    i.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(i), this.expect(3), s.parameters = [i];
    const a = this.tsTryParseTypeAnnotation();
    return a && (s.typeAnnotation = a), this.tsParseTypeMemberSemicolon(), this.finishNode(s, "TSIndexSignature");
  }
  tsParsePropertyOrMethodSignature(s, i) {
    this.eat(17) && (s.optional = !0);
    const a = s;
    if (this.match(10) || this.match(47)) {
      i && this.raise(TSErrors.ReadonlyForMethodSignature, {
        at: s
      });
      const o = a;
      o.kind && this.match(47) && this.raise(TSErrors.AccesorCannotHaveTypeParameters, {
        at: this.state.curPosition()
      }), this.tsFillSignature(14, o), this.tsParseTypeMemberSemicolon();
      const l = "parameters", f = "typeAnnotation";
      if (o.kind === "get")
        o[l].length > 0 && (this.raise(Errors.BadGetterArity, {
          at: this.state.curPosition()
        }), this.isThisParam(o[l][0]) && this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
          at: this.state.curPosition()
        }));
      else if (o.kind === "set") {
        if (o[l].length !== 1)
          this.raise(Errors.BadSetterArity, {
            at: this.state.curPosition()
          });
        else {
          const y = o[l][0];
          this.isThisParam(y) && this.raise(TSErrors.AccesorCannotDeclareThisParameter, {
            at: this.state.curPosition()
          }), y.type === "Identifier" && y.optional && this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, {
            at: this.state.curPosition()
          }), y.type === "RestElement" && this.raise(TSErrors.SetAccesorCannotHaveRestParameter, {
            at: this.state.curPosition()
          });
        }
        o[f] && this.raise(TSErrors.SetAccesorCannotHaveReturnType, {
          at: o[f]
        });
      } else
        o.kind = "method";
      return this.finishNode(o, "TSMethodSignature");
    } else {
      const o = a;
      i && (o.readonly = !0);
      const l = this.tsTryParseTypeAnnotation();
      return l && (o.typeAnnotation = l), this.tsParseTypeMemberSemicolon(), this.finishNode(o, "TSPropertySignature");
    }
  }
  tsParseTypeMember() {
    const s = this.startNode();
    if (this.match(10) || this.match(47))
      return this.tsParseSignatureMember("TSCallSignatureDeclaration", s);
    if (this.match(77)) {
      const a = this.startNode();
      return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", s) : (s.key = this.createIdentifier(a, "new"), this.tsParsePropertyOrMethodSignature(s, !1));
    }
    this.tsParseModifiers({
      allowedModifiers: ["readonly"],
      disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
    }, s);
    const i = this.tsTryParseIndexSignature(s);
    return i || (super.parsePropertyName(s), !s.computed && s.key.type === "Identifier" && (s.key.name === "get" || s.key.name === "set") && this.tsTokenCanFollowModifier() && (s.kind = s.key.name, super.parsePropertyName(s)), this.tsParsePropertyOrMethodSignature(s, !!s.readonly));
  }
  tsParseTypeLiteral() {
    const s = this.startNode();
    return s.members = this.tsParseObjectTypeMembers(), this.finishNode(s, "TSTypeLiteral");
  }
  tsParseObjectTypeMembers() {
    this.expect(5);
    const s = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
    return this.expect(8), s;
  }
  tsIsStartOfMappedType() {
    return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
  }
  tsParseMappedTypeParameter() {
    const s = this.startNode();
    return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsExpectThenParseType(58), this.finishNode(s, "TSTypeParameter");
  }
  tsParseMappedType() {
    const s = this.startNode();
    return this.expect(5), this.match(53) ? (s.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (s.readonly = !0), this.expect(0), s.typeParameter = this.tsParseMappedTypeParameter(), s.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (s.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (s.optional = !0), s.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(s, "TSMappedType");
  }
  tsParseTupleType() {
    const s = this.startNode();
    s.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
    let i = !1;
    return s.elementTypes.forEach((a) => {
      const {
        type: o
      } = a;
      i && o !== "TSRestType" && o !== "TSOptionalType" && !(o === "TSNamedTupleMember" && a.optional) && this.raise(TSErrors.OptionalTypeBeforeRequired, {
        at: a
      }), i || (i = o === "TSNamedTupleMember" && a.optional || o === "TSOptionalType");
    }), this.finishNode(s, "TSTupleType");
  }
  tsParseTupleElementType() {
    const {
      startLoc: s
    } = this.state, i = this.eat(21);
    let a, o, l, f;
    const g = tokenIsKeywordOrIdentifier(this.state.type) ? this.lookaheadCharCode() : null;
    if (g === 58)
      a = !0, l = !1, o = this.parseIdentifier(!0), this.expect(14), f = this.tsParseType();
    else if (g === 63) {
      l = !0;
      const T = this.state.startLoc, S = this.state.value, b = this.tsParseNonArrayType();
      this.lookaheadCharCode() === 58 ? (a = !0, o = this.createIdentifier(this.startNodeAt(T), S), this.expect(17), this.expect(14), f = this.tsParseType()) : (a = !1, f = b, this.expect(17));
    } else
      f = this.tsParseType(), l = this.eat(17), a = this.eat(14);
    if (a) {
      let T;
      o ? (T = this.startNodeAtNode(o), T.optional = l, T.label = o, T.elementType = f, this.eat(17) && (T.optional = !0, this.raise(TSErrors.TupleOptionalAfterType, {
        at: this.state.lastTokStartLoc
      }))) : (T = this.startNodeAtNode(f), T.optional = l, this.raise(TSErrors.InvalidTupleMemberLabel, {
        at: f
      }), T.label = f, T.elementType = this.tsParseType()), f = this.finishNode(T, "TSNamedTupleMember");
    } else if (l) {
      const T = this.startNodeAtNode(f);
      T.typeAnnotation = f, f = this.finishNode(T, "TSOptionalType");
    }
    if (i) {
      const T = this.startNodeAt(s);
      T.typeAnnotation = f, f = this.finishNode(T, "TSRestType");
    }
    return f;
  }
  tsParseParenthesizedType() {
    const s = this.startNode();
    return this.expect(10), s.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(s, "TSParenthesizedType");
  }
  tsParseFunctionOrConstructorType(s, i) {
    const a = this.startNode();
    return s === "TSConstructorType" && (a.abstract = !!i, i && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, a)), this.finishNode(a, s);
  }
  tsParseLiteralTypeNode() {
    const s = this.startNode();
    switch (this.state.type) {
      case 134:
      case 135:
      case 133:
      case 85:
      case 86:
        s.literal = super.parseExprAtom();
        break;
      default:
        this.unexpected();
    }
    return this.finishNode(s, "TSLiteralType");
  }
  tsParseTemplateLiteralType() {
    const s = this.startNode();
    return s.literal = super.parseTemplate(!1), this.finishNode(s, "TSLiteralType");
  }
  parseTemplateSubstitution() {
    return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
  }
  tsParseThisTypeOrThisTypePredicate() {
    const s = this.tsParseThisTypeNode();
    return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(s) : s;
  }
  tsParseNonArrayType() {
    switch (this.state.type) {
      case 133:
      case 134:
      case 135:
      case 85:
      case 86:
        return this.tsParseLiteralTypeNode();
      case 53:
        if (this.state.value === "-") {
          const s = this.startNode(), i = this.lookahead();
          return i.type !== 134 && i.type !== 135 && this.unexpected(), s.literal = this.parseMaybeUnary(), this.finishNode(s, "TSLiteralType");
        }
        break;
      case 78:
        return this.tsParseThisTypeOrThisTypePredicate();
      case 87:
        return this.tsParseTypeQuery();
      case 83:
        return this.tsParseImportType();
      case 5:
        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
      case 0:
        return this.tsParseTupleType();
      case 10:
        return this.tsParseParenthesizedType();
      case 25:
      case 24:
        return this.tsParseTemplateLiteralType();
      default: {
        const {
          type: s
        } = this.state;
        if (tokenIsIdentifier(s) || s === 88 || s === 84) {
          const i = s === 88 ? "TSVoidKeyword" : s === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
          if (i !== void 0 && this.lookaheadCharCode() !== 46) {
            const a = this.startNode();
            return this.next(), this.finishNode(a, i);
          }
          return this.tsParseTypeReference();
        }
      }
    }
    this.unexpected();
  }
  tsParseArrayTypeOrHigher() {
    let s = this.tsParseNonArrayType();
    for (; !this.hasPrecedingLineBreak() && this.eat(0); )
      if (this.match(3)) {
        const i = this.startNodeAtNode(s);
        i.elementType = s, this.expect(3), s = this.finishNode(i, "TSArrayType");
      } else {
        const i = this.startNodeAtNode(s);
        i.objectType = s, i.indexType = this.tsParseType(), this.expect(3), s = this.finishNode(i, "TSIndexedAccessType");
      }
    return s;
  }
  tsParseTypeOperator() {
    const s = this.startNode(), i = this.state.value;
    return this.next(), s.operator = i, s.typeAnnotation = this.tsParseTypeOperatorOrHigher(), i === "readonly" && this.tsCheckTypeAnnotationForReadOnly(s), this.finishNode(s, "TSTypeOperator");
  }
  tsCheckTypeAnnotationForReadOnly(s) {
    switch (s.typeAnnotation.type) {
      case "TSTupleType":
      case "TSArrayType":
        return;
      default:
        this.raise(TSErrors.UnexpectedReadonly, {
          at: s
        });
    }
  }
  tsParseInferType() {
    const s = this.startNode();
    this.expectContextual(115);
    const i = this.startNode();
    return i.name = this.tsParseTypeParameterName(), i.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), s.typeParameter = this.finishNode(i, "TSTypeParameter"), this.finishNode(s, "TSInferType");
  }
  tsParseConstraintForInferType() {
    if (this.eat(81)) {
      const s = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
      if (this.state.inDisallowConditionalTypesContext || !this.match(17))
        return s;
    }
  }
  tsParseTypeOperatorOrHigher() {
    return tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
  }
  tsParseUnionOrIntersectionType(s, i, a) {
    const o = this.startNode(), l = this.eat(a), f = [];
    do
      f.push(i());
    while (this.eat(a));
    return f.length === 1 && !l ? f[0] : (o.types = f, this.finishNode(o, s));
  }
  tsParseIntersectionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
  }
  tsParseUnionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
  }
  tsIsStartOfFunctionType() {
    return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
  }
  tsSkipParameterStart() {
    if (tokenIsIdentifier(this.state.type) || this.match(78))
      return this.next(), !0;
    if (this.match(5)) {
      const {
        errors: s
      } = this.state, i = s.length;
      try {
        return this.parseObjectLike(8, !0), s.length === i;
      } catch {
        return !1;
      }
    }
    if (this.match(0)) {
      this.next();
      const {
        errors: s
      } = this.state, i = s.length;
      try {
        return super.parseBindingList(3, 93, 1), s.length === i;
      } catch {
        return !1;
      }
    }
    return !1;
  }
  tsIsUnambiguouslyStartOfFunctionType() {
    return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
  }
  tsParseTypeOrTypePredicateAnnotation(s) {
    return this.tsInType(() => {
      const i = this.startNode();
      this.expect(s);
      const a = this.startNode(), o = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
      if (o && this.match(78)) {
        let y = this.tsParseThisTypeOrThisTypePredicate();
        return y.type === "TSThisType" ? (a.parameterName = y, a.asserts = !0, a.typeAnnotation = null, y = this.finishNode(a, "TSTypePredicate")) : (this.resetStartLocationFromNode(y, a), y.asserts = !0), i.typeAnnotation = y, this.finishNode(i, "TSTypeAnnotation");
      }
      const l = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
      if (!l)
        return o ? (a.parameterName = this.parseIdentifier(), a.asserts = o, a.typeAnnotation = null, i.typeAnnotation = this.finishNode(a, "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, i);
      const f = this.tsParseTypeAnnotation(!1);
      return a.parameterName = l, a.typeAnnotation = f, a.asserts = o, i.typeAnnotation = this.finishNode(a, "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation");
    });
  }
  tsTryParseTypeOrTypePredicateAnnotation() {
    if (this.match(14))
      return this.tsParseTypeOrTypePredicateAnnotation(14);
  }
  tsTryParseTypeAnnotation() {
    if (this.match(14))
      return this.tsParseTypeAnnotation();
  }
  tsTryParseType() {
    return this.tsEatThenParseType(14);
  }
  tsParseTypePredicatePrefix() {
    const s = this.parseIdentifier();
    if (this.isContextual(116) && !this.hasPrecedingLineBreak())
      return this.next(), s;
  }
  tsParseTypePredicateAsserts() {
    if (this.state.type !== 109)
      return !1;
    const s = this.state.containsEsc;
    return this.next(), !tokenIsIdentifier(this.state.type) && !this.match(78) ? !1 : (s && this.raise(Errors.InvalidEscapedReservedWord, {
      at: this.state.lastTokStartLoc,
      reservedWord: "asserts"
    }), !0);
  }
  tsParseTypeAnnotation(s = !0, i = this.startNode()) {
    return this.tsInType(() => {
      s && this.expect(14), i.typeAnnotation = this.tsParseType();
    }), this.finishNode(i, "TSTypeAnnotation");
  }
  tsParseType() {
    assert(this.state.inType);
    const s = this.tsParseNonConditionalType();
    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
      return s;
    const i = this.startNodeAtNode(s);
    return i.checkType = s, i.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), i.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), i.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(i, "TSConditionalType");
  }
  isAbstractConstructorSignature() {
    return this.isContextual(124) && this.lookahead().type === 77;
  }
  tsParseNonConditionalType() {
    return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
  }
  tsParseTypeAssertion() {
    this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(TSErrors.ReservedTypeAssertion, {
      at: this.state.startLoc
    });
    const s = this.startNode();
    return s.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), s.expression = this.parseMaybeUnary(), this.finishNode(s, "TSTypeAssertion");
  }
  tsParseHeritageClause(s) {
    const i = this.state.startLoc, a = this.tsParseDelimitedList("HeritageClauseElement", () => {
      const o = this.startNode();
      return o.expression = this.tsParseEntityName(), this.match(47) && (o.typeParameters = this.tsParseTypeArguments()), this.finishNode(o, "TSExpressionWithTypeArguments");
    });
    return a.length || this.raise(TSErrors.EmptyHeritageClauseType, {
      at: i,
      token: s
    }), a;
  }
  tsParseInterfaceDeclaration(s, i = {}) {
    if (this.hasFollowingLineBreak())
      return null;
    this.expectContextual(129), i.declare && (s.declare = !0), tokenIsIdentifier(this.state.type) ? (s.id = this.parseIdentifier(), this.checkIdentifier(s.id, 130)) : (s.id = null, this.raise(TSErrors.MissingInterfaceName, {
      at: this.state.startLoc
    })), s.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (s.extends = this.tsParseHeritageClause("extends"));
    const a = this.startNode();
    return a.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), s.body = this.finishNode(a, "TSInterfaceBody"), this.finishNode(s, "TSInterfaceDeclaration");
  }
  tsParseTypeAliasDeclaration(s) {
    return s.id = this.parseIdentifier(), this.checkIdentifier(s.id, 2), s.typeAnnotation = this.tsInType(() => {
      if (s.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
        const i = this.startNode();
        return this.next(), this.finishNode(i, "TSIntrinsicKeyword");
      }
      return this.tsParseType();
    }), this.semicolon(), this.finishNode(s, "TSTypeAliasDeclaration");
  }
  tsInNoContext(s) {
    const i = this.state.context;
    this.state.context = [i[0]];
    try {
      return s();
    } finally {
      this.state.context = i;
    }
  }
  tsInType(s) {
    const i = this.state.inType;
    this.state.inType = !0;
    try {
      return s();
    } finally {
      this.state.inType = i;
    }
  }
  tsInDisallowConditionalTypesContext(s) {
    const i = this.state.inDisallowConditionalTypesContext;
    this.state.inDisallowConditionalTypesContext = !0;
    try {
      return s();
    } finally {
      this.state.inDisallowConditionalTypesContext = i;
    }
  }
  tsInAllowConditionalTypesContext(s) {
    const i = this.state.inDisallowConditionalTypesContext;
    this.state.inDisallowConditionalTypesContext = !1;
    try {
      return s();
    } finally {
      this.state.inDisallowConditionalTypesContext = i;
    }
  }
  tsEatThenParseType(s) {
    if (this.match(s))
      return this.tsNextThenParseType();
  }
  tsExpectThenParseType(s) {
    return this.tsInType(() => (this.expect(s), this.tsParseType()));
  }
  tsNextThenParseType() {
    return this.tsInType(() => (this.next(), this.tsParseType()));
  }
  tsParseEnumMember() {
    const s = this.startNode();
    return s.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (s.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(s, "TSEnumMember");
  }
  tsParseEnumDeclaration(s, i = {}) {
    return i.const && (s.const = !0), i.declare && (s.declare = !0), this.expectContextual(126), s.id = this.parseIdentifier(), this.checkIdentifier(s.id, s.const ? 8971 : 8459), this.expect(5), s.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(s, "TSEnumDeclaration");
  }
  tsParseModuleBlock() {
    const s = this.startNode();
    return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(s.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(s, "TSModuleBlock");
  }
  tsParseModuleOrNamespaceDeclaration(s, i = !1) {
    if (s.id = this.parseIdentifier(), i || this.checkIdentifier(s.id, 1024), this.eat(16)) {
      const a = this.startNode();
      this.tsParseModuleOrNamespaceDeclaration(a, !0), s.body = a;
    } else
      this.scope.enter(256), this.prodParam.enter(0), s.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
    return this.finishNode(s, "TSModuleDeclaration");
  }
  tsParseAmbientExternalModuleDeclaration(s) {
    return this.isContextual(112) ? (s.global = !0, s.id = this.parseIdentifier()) : this.match(133) ? s.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), s.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(s, "TSModuleDeclaration");
  }
  tsParseImportEqualsDeclaration(s, i, a) {
    s.isExport = a || !1, s.id = i || this.parseIdentifier(), this.checkIdentifier(s.id, 4096), this.expect(29);
    const o = this.tsParseModuleReference();
    return s.importKind === "type" && o.type !== "TSExternalModuleReference" && this.raise(TSErrors.ImportAliasHasImportType, {
      at: o
    }), s.moduleReference = o, this.semicolon(), this.finishNode(s, "TSImportEqualsDeclaration");
  }
  tsIsExternalModuleReference() {
    return this.isContextual(119) && this.lookaheadCharCode() === 40;
  }
  tsParseModuleReference() {
    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1);
  }
  tsParseExternalModuleReference() {
    const s = this.startNode();
    return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), s.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = !0, this.finishNode(s, "TSExternalModuleReference");
  }
  tsLookAhead(s) {
    const i = this.state.clone(), a = s();
    return this.state = i, a;
  }
  tsTryParseAndCatch(s) {
    const i = this.tryParse((a) => s() || a());
    if (!(i.aborted || !i.node))
      return i.error && (this.state = i.failState), i.node;
  }
  tsTryParse(s) {
    const i = this.state.clone(), a = s();
    if (a !== void 0 && a !== !1)
      return a;
    this.state = i;
  }
  tsTryParseDeclare(s) {
    if (this.isLineTerminator())
      return;
    let i = this.state.type, a;
    return this.isContextual(100) && (i = 74, a = "let"), this.tsInAmbientContext(() => {
      switch (i) {
        case 68:
          return s.declare = !0, super.parseFunctionStatement(s, !1, !1);
        case 80:
          return s.declare = !0, this.parseClass(s, !0, !1);
        case 126:
          return this.tsParseEnumDeclaration(s, {
            declare: !0
          });
        case 112:
          return this.tsParseAmbientExternalModuleDeclaration(s);
        case 75:
        case 74:
          return !this.match(75) || !this.isLookaheadContextual("enum") ? (s.declare = !0, this.parseVarStatement(s, a || this.state.value, !0)) : (this.expect(75), this.tsParseEnumDeclaration(s, {
            const: !0,
            declare: !0
          }));
        case 129: {
          const o = this.tsParseInterfaceDeclaration(s, {
            declare: !0
          });
          if (o)
            return o;
        }
        default:
          if (tokenIsIdentifier(i))
            return this.tsParseDeclaration(s, this.state.value, !0, null);
      }
    });
  }
  tsTryParseExportDeclaration() {
    return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
  }
  tsParseExpressionStatement(s, i, a) {
    switch (i.name) {
      case "declare": {
        const o = this.tsTryParseDeclare(s);
        return o && (o.declare = !0), o;
      }
      case "global":
        if (this.match(5)) {
          this.scope.enter(256), this.prodParam.enter(0);
          const o = s;
          return o.global = !0, o.id = i, o.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(o, "TSModuleDeclaration");
        }
        break;
      default:
        return this.tsParseDeclaration(s, i.name, !1, a);
    }
  }
  tsParseDeclaration(s, i, a, o) {
    switch (i) {
      case "abstract":
        if (this.tsCheckLineTerminator(a) && (this.match(80) || tokenIsIdentifier(this.state.type)))
          return this.tsParseAbstractDeclaration(s, o);
        break;
      case "module":
        if (this.tsCheckLineTerminator(a)) {
          if (this.match(133))
            return this.tsParseAmbientExternalModuleDeclaration(s);
          if (tokenIsIdentifier(this.state.type))
            return this.tsParseModuleOrNamespaceDeclaration(s);
        }
        break;
      case "namespace":
        if (this.tsCheckLineTerminator(a) && tokenIsIdentifier(this.state.type))
          return this.tsParseModuleOrNamespaceDeclaration(s);
        break;
      case "type":
        if (this.tsCheckLineTerminator(a) && tokenIsIdentifier(this.state.type))
          return this.tsParseTypeAliasDeclaration(s);
        break;
    }
  }
  tsCheckLineTerminator(s) {
    return s ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
  }
  tsTryParseGenericAsyncArrowFunction(s) {
    if (!this.match(47))
      return;
    const i = this.state.maybeInArrowParameters;
    this.state.maybeInArrowParameters = !0;
    const a = this.tsTryParseAndCatch(() => {
      const o = this.startNodeAt(s);
      return o.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(o), o.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), o;
    });
    if (this.state.maybeInArrowParameters = i, !!a)
      return super.parseArrowExpression(a, null, !0);
  }
  tsParseTypeArgumentsInExpression() {
    if (this.reScan_lt() === 47)
      return this.tsParseTypeArguments();
  }
  tsParseTypeArguments() {
    const s = this.startNode();
    return s.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), s.params.length === 0 ? this.raise(TSErrors.EmptyTypeArguments, {
      at: s
    }) : !this.state.inType && this.curContext() === types.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(s, "TSTypeParameterInstantiation");
  }
  tsIsDeclarationStart() {
    return tokenIsTSDeclarationStart(this.state.type);
  }
  isExportDefaultSpecifier() {
    return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
  }
  parseAssignableListItem(s, i) {
    const a = this.state.startLoc, o = {};
    this.tsParseModifiers({
      allowedModifiers: ["public", "private", "protected", "override", "readonly"]
    }, o);
    const l = o.accessibility, f = o.override, y = o.readonly;
    !(s & 4) && (l || y || f) && this.raise(TSErrors.UnexpectedParameterModifier, {
      at: a
    });
    const g = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(g, s);
    const T = this.parseMaybeDefault(g.loc.start, g);
    if (l || y || f) {
      const S = this.startNodeAt(a);
      return i.length && (S.decorators = i), l && (S.accessibility = l), y && (S.readonly = y), f && (S.override = f), T.type !== "Identifier" && T.type !== "AssignmentPattern" && this.raise(TSErrors.UnsupportedParameterPropertyKind, {
        at: S
      }), S.parameter = T, this.finishNode(S, "TSParameterProperty");
    }
    return i.length && (g.decorators = i), T;
  }
  isSimpleParameter(s) {
    return s.type === "TSParameterProperty" && super.isSimpleParameter(s.parameter) || super.isSimpleParameter(s);
  }
  tsDisallowOptionalPattern(s) {
    for (const i of s.params)
      i.type !== "Identifier" && i.optional && !this.state.isAmbientContext && this.raise(TSErrors.PatternIsOptional, {
        at: i
      });
  }
  setArrowFunctionParameters(s, i, a) {
    super.setArrowFunctionParameters(s, i, a), this.tsDisallowOptionalPattern(s);
  }
  parseFunctionBodyAndFinish(s, i, a = !1) {
    this.match(14) && (s.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
    const o = i === "FunctionDeclaration" ? "TSDeclareFunction" : i === "ClassMethod" || i === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
    return o && !this.match(5) && this.isLineTerminator() ? this.finishNode(s, o) : o === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(TSErrors.DeclareFunctionHasImplementation, {
      at: s
    }), s.declare) ? super.parseFunctionBodyAndFinish(s, o, a) : (this.tsDisallowOptionalPattern(s), super.parseFunctionBodyAndFinish(s, i, a));
  }
  registerFunctionStatementId(s) {
    !s.body && s.id ? this.checkIdentifier(s.id, 1024) : super.registerFunctionStatementId(s);
  }
  tsCheckForInvalidTypeCasts(s) {
    s.forEach((i) => {
      (i == null ? void 0 : i.type) === "TSTypeCastExpression" && this.raise(TSErrors.UnexpectedTypeAnnotation, {
        at: i.typeAnnotation
      });
    });
  }
  toReferencedList(s, i) {
    return this.tsCheckForInvalidTypeCasts(s), s;
  }
  parseArrayLike(s, i, a, o) {
    const l = super.parseArrayLike(s, i, a, o);
    return l.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(l.elements), l;
  }
  parseSubscript(s, i, a, o) {
    if (!this.hasPrecedingLineBreak() && this.match(35)) {
      this.state.canStartJSXElement = !1, this.next();
      const f = this.startNodeAt(i);
      return f.expression = s, this.finishNode(f, "TSNonNullExpression");
    }
    let l = !1;
    if (this.match(18) && this.lookaheadCharCode() === 60) {
      if (a)
        return o.stop = !0, s;
      o.optionalChainMember = l = !0, this.next();
    }
    if (this.match(47) || this.match(51)) {
      let f;
      const y = this.tsTryParseAndCatch(() => {
        if (!a && this.atPossibleAsyncArrow(s)) {
          const b = this.tsTryParseGenericAsyncArrowFunction(i);
          if (b)
            return b;
        }
        const g = this.tsParseTypeArgumentsInExpression();
        if (!g)
          return;
        if (l && !this.match(10)) {
          f = this.state.curPosition();
          return;
        }
        if (tokenIsTemplate(this.state.type)) {
          const b = super.parseTaggedTemplateExpression(s, i, o);
          return b.typeParameters = g, b;
        }
        if (!a && this.eat(10)) {
          const b = this.startNodeAt(i);
          return b.callee = s, b.arguments = this.parseCallExpressionArguments(11, !1), this.tsCheckForInvalidTypeCasts(b.arguments), b.typeParameters = g, o.optionalChainMember && (b.optional = l), this.finishCallExpression(b, o.optionalChainMember);
        }
        const T = this.state.type;
        if (T === 48 || T === 52 || T !== 10 && tokenCanStartExpression(T) && !this.hasPrecedingLineBreak())
          return;
        const S = this.startNodeAt(i);
        return S.expression = s, S.typeParameters = g, this.finishNode(S, "TSInstantiationExpression");
      });
      if (f && this.unexpected(f, 10), y)
        return y.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, {
          at: this.state.startLoc
        }), y;
    }
    return super.parseSubscript(s, i, a, o);
  }
  parseNewCallee(s) {
    var i;
    super.parseNewCallee(s);
    const {
      callee: a
    } = s;
    a.type === "TSInstantiationExpression" && !((i = a.extra) != null && i.parenthesized) && (s.typeParameters = a.typeParameters, s.callee = a.expression);
  }
  parseExprOp(s, i, a) {
    let o;
    if (tokenOperatorPrecedence(58) > a && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (o = this.isContextual(120)))) {
      const l = this.startNodeAt(i);
      return l.expression = s, l.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (o && this.raise(Errors.UnexpectedKeyword, {
        at: this.state.startLoc,
        keyword: "const"
      }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(l, o ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(l, i, a);
    }
    return super.parseExprOp(s, i, a);
  }
  checkReservedWord(s, i, a, o) {
    this.state.isAmbientContext || super.checkReservedWord(s, i, a, o);
  }
  checkImportReflection(s) {
    super.checkImportReflection(s), s.module && s.importKind !== "value" && this.raise(TSErrors.ImportReflectionHasImportType, {
      at: s.specifiers[0].loc.start
    });
  }
  checkDuplicateExports() {
  }
  isPotentialImportPhase(s) {
    if (super.isPotentialImportPhase(s))
      return !0;
    if (this.isContextual(130)) {
      const i = this.lookaheadCharCode();
      return s ? i === 123 || i === 42 : i !== 61;
    }
    return !s && this.isContextual(87);
  }
  applyImportPhase(s, i, a, o) {
    super.applyImportPhase(s, i, a, o), i ? s.exportKind = a === "type" ? "type" : "value" : s.importKind = a === "type" || a === "typeof" ? a : "value";
  }
  parseImport(s) {
    if (this.match(133))
      return s.importKind = "value", super.parseImport(s);
    let i;
    if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61)
      return s.importKind = "value", this.tsParseImportEqualsDeclaration(s);
    if (this.isContextual(130)) {
      const a = this.parseMaybeImportPhase(s, !1);
      if (this.lookaheadCharCode() === 61)
        return this.tsParseImportEqualsDeclaration(s, a);
      i = super.parseImportSpecifiersAndAfter(s, a);
    } else
      i = super.parseImport(s);
    return i.importKind === "type" && i.specifiers.length > 1 && i.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, {
      at: i
    }), i;
  }
  parseExport(s, i) {
    if (this.match(83)) {
      this.next();
      let a = null;
      return this.isContextual(130) && this.isPotentialImportPhase(!1) ? a = this.parseMaybeImportPhase(s, !1) : s.importKind = "value", this.tsParseImportEqualsDeclaration(s, a, !0);
    } else if (this.eat(29)) {
      const a = s;
      return a.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(a, "TSExportAssignment");
    } else if (this.eatContextual(93)) {
      const a = s;
      return this.expectContextual(128), a.id = this.parseIdentifier(), this.semicolon(), this.finishNode(a, "TSNamespaceExportDeclaration");
    } else
      return super.parseExport(s, i);
  }
  isAbstractClass() {
    return this.isContextual(124) && this.lookahead().type === 80;
  }
  parseExportDefaultExpression() {
    if (this.isAbstractClass()) {
      const s = this.startNode();
      return this.next(), s.abstract = !0, this.parseClass(s, !0, !0);
    }
    if (this.match(129)) {
      const s = this.tsParseInterfaceDeclaration(this.startNode());
      if (s)
        return s;
    }
    return super.parseExportDefaultExpression();
  }
  parseVarStatement(s, i, a = !1) {
    const {
      isAmbientContext: o
    } = this.state, l = super.parseVarStatement(s, i, a || o);
    if (!o)
      return l;
    for (const {
      id: f,
      init: y
    } of l.declarations)
      y && (i !== "const" || f.typeAnnotation ? this.raise(TSErrors.InitializerNotAllowedInAmbientContext, {
        at: y
      }) : isValidAmbientConstInitializer(y, this.hasPlugin("estree")) || this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, {
        at: y
      }));
    return l;
  }
  parseStatementContent(s, i) {
    if (this.match(75) && this.isLookaheadContextual("enum")) {
      const a = this.startNode();
      return this.expect(75), this.tsParseEnumDeclaration(a, {
        const: !0
      });
    }
    if (this.isContextual(126))
      return this.tsParseEnumDeclaration(this.startNode());
    if (this.isContextual(129)) {
      const a = this.tsParseInterfaceDeclaration(this.startNode());
      if (a)
        return a;
    }
    return super.parseStatementContent(s, i);
  }
  parseAccessModifier() {
    return this.tsParseModifier(["public", "protected", "private"]);
  }
  tsHasSomeModifiers(s, i) {
    return i.some((a) => tsIsAccessModifier(a) ? s.accessibility === a : !!s[a]);
  }
  tsIsStartOfStaticBlocks() {
    return this.isContextual(106) && this.lookaheadCharCode() === 123;
  }
  parseClassMember(s, i, a) {
    const o = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
    this.tsParseModifiers({
      allowedModifiers: o,
      disallowedModifiers: ["in", "out"],
      stopOnStartOfClassStaticBlock: !0,
      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
    }, i);
    const l = () => {
      this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(i, o) && this.raise(TSErrors.StaticBlockCannotHaveModifier, {
        at: this.state.curPosition()
      }), super.parseClassStaticBlock(s, i)) : this.parseClassMemberWithIsStatic(s, i, a, !!i.static);
    };
    i.declare ? this.tsInAmbientContext(l) : l();
  }
  parseClassMemberWithIsStatic(s, i, a, o) {
    const l = this.tsTryParseIndexSignature(i);
    if (l) {
      s.body.push(l), i.abstract && this.raise(TSErrors.IndexSignatureHasAbstract, {
        at: i
      }), i.accessibility && this.raise(TSErrors.IndexSignatureHasAccessibility, {
        at: i,
        modifier: i.accessibility
      }), i.declare && this.raise(TSErrors.IndexSignatureHasDeclare, {
        at: i
      }), i.override && this.raise(TSErrors.IndexSignatureHasOverride, {
        at: i
      });
      return;
    }
    !this.state.inAbstractClass && i.abstract && this.raise(TSErrors.NonAbstractClassHasAbstractMethod, {
      at: i
    }), i.override && (a.hadSuperClass || this.raise(TSErrors.OverrideNotInSubClass, {
      at: i
    })), super.parseClassMemberWithIsStatic(s, i, a, o);
  }
  parsePostMemberNameModifiers(s) {
    this.eat(17) && (s.optional = !0), s.readonly && this.match(10) && this.raise(TSErrors.ClassMethodHasReadonly, {
      at: s
    }), s.declare && this.match(10) && this.raise(TSErrors.ClassMethodHasDeclare, {
      at: s
    });
  }
  parseExpressionStatement(s, i, a) {
    return (i.type === "Identifier" ? this.tsParseExpressionStatement(s, i, a) : void 0) || super.parseExpressionStatement(s, i, a);
  }
  shouldParseExportDeclaration() {
    return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
  }
  parseConditional(s, i, a) {
    if (!this.state.maybeInArrowParameters || !this.match(17))
      return super.parseConditional(s, i, a);
    const o = this.tryParse(() => super.parseConditional(s, i));
    return o.node ? (o.error && (this.state = o.failState), o.node) : (o.error && super.setOptionalParametersError(a, o.error), s);
  }
  parseParenItem(s, i) {
    if (s = super.parseParenItem(s, i), this.eat(17) && (s.optional = !0, this.resetEndLocation(s)), this.match(14)) {
      const a = this.startNodeAt(i);
      return a.expression = s, a.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(a, "TSTypeCastExpression");
    }
    return s;
  }
  parseExportDeclaration(s) {
    if (!this.state.isAmbientContext && this.isContextual(125))
      return this.tsInAmbientContext(() => this.parseExportDeclaration(s));
    const i = this.state.startLoc, a = this.eatContextual(125);
    if (a && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, {
        at: this.state.startLoc
      });
    const l = tokenIsIdentifier(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(s);
    return l ? ((l.type === "TSInterfaceDeclaration" || l.type === "TSTypeAliasDeclaration" || a) && (s.exportKind = "type"), a && (this.resetStartLocation(l, i), l.declare = !0), l) : null;
  }
  parseClassId(s, i, a, o) {
    if ((!i || a) && this.isContextual(113))
      return;
    super.parseClassId(s, i, a, s.declare ? 1024 : 8331);
    const l = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
    l && (s.typeParameters = l);
  }
  parseClassPropertyAnnotation(s) {
    s.optional || (this.eat(35) ? s.definite = !0 : this.eat(17) && (s.optional = !0));
    const i = this.tsTryParseTypeAnnotation();
    i && (s.typeAnnotation = i);
  }
  parseClassProperty(s) {
    if (this.parseClassPropertyAnnotation(s), this.state.isAmbientContext && !(s.readonly && !s.typeAnnotation) && this.match(29) && this.raise(TSErrors.DeclareClassFieldHasInitializer, {
      at: this.state.startLoc
    }), s.abstract && this.match(29)) {
      const {
        key: i
      } = s;
      this.raise(TSErrors.AbstractPropertyHasInitializer, {
        at: this.state.startLoc,
        propertyName: i.type === "Identifier" && !s.computed ? i.name : `[${this.input.slice(i.start, i.end)}]`
      });
    }
    return super.parseClassProperty(s);
  }
  parseClassPrivateProperty(s) {
    return s.abstract && this.raise(TSErrors.PrivateElementHasAbstract, {
      at: s
    }), s.accessibility && this.raise(TSErrors.PrivateElementHasAccessibility, {
      at: s,
      modifier: s.accessibility
    }), this.parseClassPropertyAnnotation(s), super.parseClassPrivateProperty(s);
  }
  parseClassAccessorProperty(s) {
    return this.parseClassPropertyAnnotation(s), s.optional && this.raise(TSErrors.AccessorCannotBeOptional, {
      at: s
    }), super.parseClassAccessorProperty(s);
  }
  pushClassMethod(s, i, a, o, l, f) {
    const y = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    y && l && this.raise(TSErrors.ConstructorHasTypeParameters, {
      at: y
    });
    const {
      declare: g = !1,
      kind: T
    } = i;
    g && (T === "get" || T === "set") && this.raise(TSErrors.DeclareAccessor, {
      at: i,
      kind: T
    }), y && (i.typeParameters = y), super.pushClassMethod(s, i, a, o, l, f);
  }
  pushClassPrivateMethod(s, i, a, o) {
    const l = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    l && (i.typeParameters = l), super.pushClassPrivateMethod(s, i, a, o);
  }
  declareClassPrivateMethodInScope(s, i) {
    s.type !== "TSDeclareMethod" && (s.type === "MethodDefinition" && !s.value.body || super.declareClassPrivateMethodInScope(s, i));
  }
  parseClassSuper(s) {
    super.parseClassSuper(s), s.superClass && (this.match(47) || this.match(51)) && (s.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (s.implements = this.tsParseHeritageClause("implements"));
  }
  parseObjPropValue(s, i, a, o, l, f, y) {
    const g = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    return g && (s.typeParameters = g), super.parseObjPropValue(s, i, a, o, l, f, y);
  }
  parseFunctionParams(s, i) {
    const a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
    a && (s.typeParameters = a), super.parseFunctionParams(s, i);
  }
  parseVarId(s, i) {
    super.parseVarId(s, i), s.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (s.definite = !0);
    const a = this.tsTryParseTypeAnnotation();
    a && (s.id.typeAnnotation = a, this.resetEndLocation(s.id));
  }
  parseAsyncArrowFromCallExpression(s, i) {
    return this.match(14) && (s.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(s, i);
  }
  parseMaybeAssign(s, i) {
    var a, o, l, f, y;
    let g, T, S;
    if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
      if (g = this.state.clone(), T = this.tryParse(() => super.parseMaybeAssign(s, i), g), !T.error)
        return T.node;
      const {
        context: $
      } = this.state, U = $[$.length - 1];
      (U === types.j_oTag || U === types.j_expr) && $.pop();
    }
    if (!((a = T) != null && a.error) && !this.match(47))
      return super.parseMaybeAssign(s, i);
    (!g || g === this.state) && (g = this.state.clone());
    let b;
    const v = this.tryParse(($) => {
      var U, X;
      b = this.tsParseTypeParameters(this.tsParseConstModifier);
      const k = super.parseMaybeAssign(s, i);
      return (k.type !== "ArrowFunctionExpression" || (U = k.extra) != null && U.parenthesized) && $(), ((X = b) == null ? void 0 : X.params.length) !== 0 && this.resetStartLocationFromNode(k, b), k.typeParameters = b, k;
    }, g);
    if (!v.error && !v.aborted)
      return b && this.reportReservedArrowTypeParam(b), v.node;
    if (!T && (assert(!this.hasPlugin("jsx")), S = this.tryParse(() => super.parseMaybeAssign(s, i), g), !S.error))
      return S.node;
    if ((o = T) != null && o.node)
      return this.state = T.failState, T.node;
    if (v.node)
      return this.state = v.failState, b && this.reportReservedArrowTypeParam(b), v.node;
    if ((l = S) != null && l.node)
      return this.state = S.failState, S.node;
    throw ((f = T) == null ? void 0 : f.error) || v.error || ((y = S) == null ? void 0 : y.error);
  }
  reportReservedArrowTypeParam(s) {
    var i;
    s.params.length === 1 && !s.params[0].constraint && !((i = s.extra) != null && i.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(TSErrors.ReservedArrowTypeParam, {
      at: s
    });
  }
  parseMaybeUnary(s, i) {
    return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(s, i);
  }
  parseArrow(s) {
    if (this.match(14)) {
      const i = this.tryParse((a) => {
        const o = this.tsParseTypeOrTypePredicateAnnotation(14);
        return (this.canInsertSemicolon() || !this.match(19)) && a(), o;
      });
      if (i.aborted)
        return;
      i.thrown || (i.error && (this.state = i.failState), s.returnType = i.node);
    }
    return super.parseArrow(s);
  }
  parseAssignableListItemTypes(s, i) {
    if (!(i & 2))
      return s;
    this.eat(17) && (s.optional = !0);
    const a = this.tsTryParseTypeAnnotation();
    return a && (s.typeAnnotation = a), this.resetEndLocation(s), s;
  }
  isAssignable(s, i) {
    switch (s.type) {
      case "TSTypeCastExpression":
        return this.isAssignable(s.expression, i);
      case "TSParameterProperty":
        return !0;
      default:
        return super.isAssignable(s, i);
    }
  }
  toAssignable(s, i = !1) {
    switch (s.type) {
      case "ParenthesizedExpression":
        this.toAssignableParenthesizedExpression(s, i);
        break;
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
        i ? this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, {
          at: s
        }) : this.raise(TSErrors.UnexpectedTypeCastInParameter, {
          at: s
        }), this.toAssignable(s.expression, i);
        break;
      case "AssignmentExpression":
        !i && s.left.type === "TSTypeCastExpression" && (s.left = this.typeCastToParameter(s.left));
      default:
        super.toAssignable(s, i);
    }
  }
  toAssignableParenthesizedExpression(s, i) {
    switch (s.expression.type) {
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
      case "ParenthesizedExpression":
        this.toAssignable(s.expression, i);
        break;
      default:
        super.toAssignable(s, i);
    }
  }
  checkToRestConversion(s, i) {
    switch (s.type) {
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        this.checkToRestConversion(s.expression, !1);
        break;
      default:
        super.checkToRestConversion(s, i);
    }
  }
  isValidLVal(s, i, a) {
    return getOwn({
      TSTypeCastExpression: !0,
      TSParameterProperty: "parameter",
      TSNonNullExpression: "expression",
      TSAsExpression: (a !== 64 || !i) && ["expression", !0],
      TSSatisfiesExpression: (a !== 64 || !i) && ["expression", !0],
      TSTypeAssertion: (a !== 64 || !i) && ["expression", !0]
    }, s) || super.isValidLVal(s, i, a);
  }
  parseBindingAtom() {
    return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
  }
  parseMaybeDecoratorArguments(s) {
    if (this.match(47) || this.match(51)) {
      const i = this.tsParseTypeArgumentsInExpression();
      if (this.match(10)) {
        const a = super.parseMaybeDecoratorArguments(s);
        return a.typeParameters = i, a;
      }
      this.unexpected(null, 10);
    }
    return super.parseMaybeDecoratorArguments(s);
  }
  checkCommaAfterRest(s) {
    return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === s ? (this.next(), !1) : super.checkCommaAfterRest(s);
  }
  isClassMethod() {
    return this.match(47) || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(35) || this.match(14) || super.isClassProperty();
  }
  parseMaybeDefault(s, i) {
    const a = super.parseMaybeDefault(s, i);
    return a.type === "AssignmentPattern" && a.typeAnnotation && a.right.start < a.typeAnnotation.start && this.raise(TSErrors.TypeAnnotationAfterAssign, {
      at: a.typeAnnotation
    }), a;
  }
  getTokenFromCode(s) {
    if (this.state.inType) {
      if (s === 62) {
        this.finishOp(48, 1);
        return;
      }
      if (s === 60) {
        this.finishOp(47, 1);
        return;
      }
    }
    super.getTokenFromCode(s);
  }
  reScan_lt_gt() {
    const {
      type: s
    } = this.state;
    s === 47 ? (this.state.pos -= 1, this.readToken_lt()) : s === 48 && (this.state.pos -= 1, this.readToken_gt());
  }
  reScan_lt() {
    const {
      type: s
    } = this.state;
    return s === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : s;
  }
  toAssignableList(s, i, a) {
    for (let o = 0; o < s.length; o++) {
      const l = s[o];
      (l == null ? void 0 : l.type) === "TSTypeCastExpression" && (s[o] = this.typeCastToParameter(l));
    }
    super.toAssignableList(s, i, a);
  }
  typeCastToParameter(s) {
    return s.expression.typeAnnotation = s.typeAnnotation, this.resetEndLocation(s.expression, s.typeAnnotation.loc.end), s.expression;
  }
  shouldParseArrow(s) {
    return this.match(14) ? s.every((i) => this.isAssignable(i, !0)) : super.shouldParseArrow(s);
  }
  shouldParseAsyncArrow() {
    return this.match(14) || super.shouldParseAsyncArrow();
  }
  canHaveLeadingDecorator() {
    return super.canHaveLeadingDecorator() || this.isAbstractClass();
  }
  jsxParseOpeningElementAfterName(s) {
    if (this.match(47) || this.match(51)) {
      const i = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
      i && (s.typeParameters = i);
    }
    return super.jsxParseOpeningElementAfterName(s);
  }
  getGetterSetterExpectedParamCount(s) {
    const i = super.getGetterSetterExpectedParamCount(s), o = this.getObjectOrClassMethodParams(s)[0];
    return o && this.isThisParam(o) ? i + 1 : i;
  }
  parseCatchClauseParam() {
    const s = super.parseCatchClauseParam(), i = this.tsTryParseTypeAnnotation();
    return i && (s.typeAnnotation = i, this.resetEndLocation(s)), s;
  }
  tsInAmbientContext(s) {
    const i = this.state.isAmbientContext;
    this.state.isAmbientContext = !0;
    try {
      return s();
    } finally {
      this.state.isAmbientContext = i;
    }
  }
  parseClass(s, i, a) {
    const o = this.state.inAbstractClass;
    this.state.inAbstractClass = !!s.abstract;
    try {
      return super.parseClass(s, i, a);
    } finally {
      this.state.inAbstractClass = o;
    }
  }
  tsParseAbstractDeclaration(s, i) {
    if (this.match(80))
      return s.abstract = !0, this.maybeTakeDecorators(i, this.parseClass(s, !0, !1));
    if (this.isContextual(129)) {
      if (!this.hasFollowingLineBreak())
        return s.abstract = !0, this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, {
          at: s
        }), this.tsParseInterfaceDeclaration(s);
    } else
      this.unexpected(null, 80);
  }
  parseMethod(s, i, a, o, l, f, y) {
    const g = super.parseMethod(s, i, a, o, l, f, y);
    if (g.abstract && (this.hasPlugin("estree") ? !!g.value.body : !!g.body)) {
      const {
        key: S
      } = g;
      this.raise(TSErrors.AbstractMethodHasImplementation, {
        at: g,
        methodName: S.type === "Identifier" && !g.computed ? S.name : `[${this.input.slice(S.start, S.end)}]`
      });
    }
    return g;
  }
  tsParseTypeParameterName() {
    return this.parseIdentifier().name;
  }
  shouldParseAsAmbientContext() {
    return !!this.getPluginOption("typescript", "dts");
  }
  parse() {
    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
  }
  getExpression() {
    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
  }
  parseExportSpecifier(s, i, a, o) {
    return !i && o ? (this.parseTypeOnlyImportExportSpecifier(s, !1, a), this.finishNode(s, "ExportSpecifier")) : (s.exportKind = "value", super.parseExportSpecifier(s, i, a, o));
  }
  parseImportSpecifier(s, i, a, o, l) {
    return !i && o ? (this.parseTypeOnlyImportExportSpecifier(s, !0, a), this.finishNode(s, "ImportSpecifier")) : (s.importKind = "value", super.parseImportSpecifier(s, i, a, o, a ? 4098 : 4096));
  }
  parseTypeOnlyImportExportSpecifier(s, i, a) {
    const o = i ? "imported" : "local", l = i ? "local" : "exported";
    let f = s[o], y, g = !1, T = !0;
    const S = f.loc.start;
    if (this.isContextual(93)) {
      const v = this.parseIdentifier();
      if (this.isContextual(93)) {
        const $ = this.parseIdentifier();
        tokenIsKeywordOrIdentifier(this.state.type) ? (g = !0, f = v, y = i ? this.parseIdentifier() : this.parseModuleExportName(), T = !1) : (y = $, T = !1);
      } else
        tokenIsKeywordOrIdentifier(this.state.type) ? (T = !1, y = i ? this.parseIdentifier() : this.parseModuleExportName()) : (g = !0, f = v);
    } else
      tokenIsKeywordOrIdentifier(this.state.type) && (g = !0, i ? (f = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(f.name, f.loc.start, !0, !0)) : f = this.parseModuleExportName());
    g && a && this.raise(i ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, {
      at: S
    }), s[o] = f, s[l] = y;
    const b = i ? "importKind" : "exportKind";
    s[b] = g ? "type" : "value", T && this.eatContextual(93) && (s[l] = i ? this.parseIdentifier() : this.parseModuleExportName()), s[l] || (s[l] = cloneIdentifier(s[o])), i && this.checkIdentifier(s[l], g ? 4098 : 4096);
  }
};
function isPossiblyLiteralEnum(e) {
  if (e.type !== "MemberExpression")
    return !1;
  const {
    computed: t,
    property: s
  } = e;
  return t && s.type !== "StringLiteral" && (s.type !== "TemplateLiteral" || s.expressions.length > 0) ? !1 : isUncomputedMemberExpressionChain(e.object);
}
function isValidAmbientConstInitializer(e, t) {
  var s;
  const {
    type: i
  } = e;
  if ((s = e.extra) != null && s.parenthesized)
    return !1;
  if (t) {
    if (i === "Literal") {
      const {
        value: a
      } = e;
      if (typeof a == "string" || typeof a == "boolean")
        return !0;
    }
  } else if (i === "StringLiteral" || i === "BooleanLiteral")
    return !0;
  return !!(isNumber(e, t) || isNegativeNumber(e, t) || i === "TemplateLiteral" && e.expressions.length === 0 || isPossiblyLiteralEnum(e));
}
function isNumber(e, t) {
  return t ? e.type === "Literal" && (typeof e.value == "number" || "bigint" in e) : e.type === "NumericLiteral" || e.type === "BigIntLiteral";
}
function isNegativeNumber(e, t) {
  if (e.type === "UnaryExpression") {
    const {
      operator: s,
      argument: i
    } = e;
    if (s === "-" && isNumber(i, t))
      return !0;
  }
  return !1;
}
function isUncomputedMemberExpressionChain(e) {
  return e.type === "Identifier" ? !0 : e.type !== "MemberExpression" || e.computed ? !1 : isUncomputedMemberExpressionChain(e.object);
}
const PlaceholderErrors = ParseErrorEnum`placeholders`({
  ClassNameIsRequired: "A class name is required.",
  UnexpectedSpace: "Unexpected space in placeholder."
});
var placeholders = (e) => class extends e {
  parsePlaceholder(s) {
    if (this.match(144)) {
      const i = this.startNode();
      return this.next(), this.assertNoSpace(), i.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(i, s);
    }
  }
  finishPlaceholder(s, i) {
    const a = !!(s.expectedNode && s.type === "Placeholder");
    return s.expectedNode = i, a ? s : this.finishNode(s, "Placeholder");
  }
  getTokenFromCode(s) {
    s === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(s);
  }
  parseExprAtom(s) {
    return this.parsePlaceholder("Expression") || super.parseExprAtom(s);
  }
  parseIdentifier(s) {
    return this.parsePlaceholder("Identifier") || super.parseIdentifier(s);
  }
  checkReservedWord(s, i, a, o) {
    s !== void 0 && super.checkReservedWord(s, i, a, o);
  }
  parseBindingAtom() {
    return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
  }
  isValidLVal(s, i, a) {
    return s === "Placeholder" || super.isValidLVal(s, i, a);
  }
  toAssignable(s, i) {
    s && s.type === "Placeholder" && s.expectedNode === "Expression" ? s.expectedNode = "Pattern" : super.toAssignable(s, i);
  }
  chStartsBindingIdentifier(s, i) {
    return !!(super.chStartsBindingIdentifier(s, i) || this.lookahead().type === 144);
  }
  verifyBreakContinue(s, i) {
    s.label && s.label.type === "Placeholder" || super.verifyBreakContinue(s, i);
  }
  parseExpressionStatement(s, i) {
    var a;
    if (i.type !== "Placeholder" || (a = i.extra) != null && a.parenthesized)
      return super.parseExpressionStatement(s, i);
    if (this.match(14)) {
      const o = s;
      return o.label = this.finishPlaceholder(i, "Identifier"), this.next(), o.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(o, "LabeledStatement");
    }
    return this.semicolon(), s.name = i.name, this.finishPlaceholder(s, "Statement");
  }
  parseBlock(s, i, a) {
    return this.parsePlaceholder("BlockStatement") || super.parseBlock(s, i, a);
  }
  parseFunctionId(s) {
    return this.parsePlaceholder("Identifier") || super.parseFunctionId(s);
  }
  parseClass(s, i, a) {
    const o = i ? "ClassDeclaration" : "ClassExpression";
    this.next();
    const l = this.state.strict, f = this.parsePlaceholder("Identifier");
    if (f)
      if (this.match(81) || this.match(144) || this.match(5))
        s.id = f;
      else {
        if (a || !i)
          return s.id = null, s.body = this.finishPlaceholder(f, "ClassBody"), this.finishNode(s, o);
        throw this.raise(PlaceholderErrors.ClassNameIsRequired, {
          at: this.state.startLoc
        });
      }
    else
      this.parseClassId(s, i, a);
    return super.parseClassSuper(s), s.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!s.superClass, l), this.finishNode(s, o);
  }
  parseExport(s, i) {
    const a = this.parsePlaceholder("Identifier");
    if (!a)
      return super.parseExport(s, i);
    if (!this.isContextual(98) && !this.match(12))
      return s.specifiers = [], s.source = null, s.declaration = this.finishPlaceholder(a, "Declaration"), this.finishNode(s, "ExportNamedDeclaration");
    this.expectPlugin("exportDefaultFrom");
    const o = this.startNode();
    return o.exported = a, s.specifiers = [this.finishNode(o, "ExportDefaultSpecifier")], super.parseExport(s, i);
  }
  isExportDefaultSpecifier() {
    if (this.match(65)) {
      const s = this.nextTokenStart();
      if (this.isUnparsedContextual(s, "from") && this.input.startsWith(tokenLabelName(144), this.nextTokenStartSince(s + 4)))
        return !0;
    }
    return super.isExportDefaultSpecifier();
  }
  maybeParseExportDefaultSpecifier(s, i) {
    var a;
    return (a = s.specifiers) != null && a.length ? !0 : super.maybeParseExportDefaultSpecifier(s, i);
  }
  checkExport(s) {
    const {
      specifiers: i
    } = s;
    i != null && i.length && (s.specifiers = i.filter((a) => a.exported.type === "Placeholder")), super.checkExport(s), s.specifiers = i;
  }
  parseImport(s) {
    const i = this.parsePlaceholder("Identifier");
    if (!i)
      return super.parseImport(s);
    if (s.specifiers = [], !this.isContextual(98) && !this.match(12))
      return s.source = this.finishPlaceholder(i, "StringLiteral"), this.semicolon(), this.finishNode(s, "ImportDeclaration");
    const a = this.startNodeAtNode(i);
    return a.local = i, s.specifiers.push(this.finishNode(a, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(s) || this.parseNamedImportSpecifiers(s)), this.expectContextual(98), s.source = this.parseImportSource(), this.semicolon(), this.finishNode(s, "ImportDeclaration");
  }
  parseImportSource() {
    return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
  }
  assertNoSpace() {
    this.state.start > this.state.lastTokEndLoc.index && this.raise(PlaceholderErrors.UnexpectedSpace, {
      at: this.state.lastTokEndLoc
    });
  }
}, v8intrinsic = (e) => class extends e {
  parseV8Intrinsic() {
    if (this.match(54)) {
      const s = this.state.startLoc, i = this.startNode();
      if (this.next(), tokenIsIdentifier(this.state.type)) {
        const a = this.parseIdentifierName(), o = this.createIdentifier(i, a);
        if (o.type = "V8IntrinsicIdentifier", this.match(10))
          return o;
      }
      this.unexpected(s);
    }
  }
  parseExprAtom(s) {
    return this.parseV8Intrinsic() || super.parseExprAtom(s);
  }
};
function hasPlugin(e, t) {
  const [s, i] = typeof t == "string" ? [t, {}] : t, a = Object.keys(i), o = a.length === 0;
  return e.some((l) => {
    if (typeof l == "string")
      return o && l === s;
    {
      const [f, y] = l;
      if (f !== s)
        return !1;
      for (const g of a)
        if (y[g] !== i[g])
          return !1;
      return !0;
    }
  });
}
function getPluginOption(e, t, s) {
  const i = e.find((a) => Array.isArray(a) ? a[0] === t : a === t);
  return i && Array.isArray(i) && i.length > 1 ? i[1][s] : null;
}
const PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"], TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"], RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
function validatePlugins(e) {
  if (hasPlugin(e, "decorators")) {
    if (hasPlugin(e, "decorators-legacy"))
      throw new Error("Cannot use the decorators and decorators-legacy plugin together");
    const t = getPluginOption(e, "decorators", "decoratorsBeforeExport");
    if (t != null && typeof t != "boolean")
      throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
    const s = getPluginOption(e, "decorators", "allowCallParenthesized");
    if (s != null && typeof s != "boolean")
      throw new Error("'allowCallParenthesized' must be a boolean.");
  }
  if (hasPlugin(e, "flow") && hasPlugin(e, "typescript"))
    throw new Error("Cannot combine flow and typescript plugins.");
  if (hasPlugin(e, "placeholders") && hasPlugin(e, "v8intrinsic"))
    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
  if (hasPlugin(e, "pipelineOperator")) {
    const t = getPluginOption(e, "pipelineOperator", "proposal");
    if (!PIPELINE_PROPOSALS.includes(t)) {
      const i = PIPELINE_PROPOSALS.map((a) => `"${a}"`).join(", ");
      throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i}.`);
    }
    const s = hasPlugin(e, ["recordAndTuple", {
      syntaxType: "hash"
    }]);
    if (t === "hack") {
      if (hasPlugin(e, "placeholders"))
        throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
      if (hasPlugin(e, "v8intrinsic"))
        throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
      const i = getPluginOption(e, "pipelineOperator", "topicToken");
      if (!TOPIC_TOKENS.includes(i)) {
        const a = TOPIC_TOKENS.map((o) => `"${o}"`).join(", ");
        throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${a}.`);
      }
      if (i === "#" && s)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    } else if (t === "smart" && s)
      throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
  }
  if (hasPlugin(e, "moduleAttributes")) {
    if (hasPlugin(e, "importAssertions") || hasPlugin(e, "importAttributes"))
      throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
    if (getPluginOption(e, "moduleAttributes", "version") !== "may-2020")
      throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
  }
  if (hasPlugin(e, "importAssertions") && hasPlugin(e, "importAttributes"))
    throw new Error("Cannot combine importAssertions and importAttributes plugins.");
  if (hasPlugin(e, "recordAndTuple") && getPluginOption(e, "recordAndTuple", "syntaxType") != null && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(e, "recordAndTuple", "syntaxType")))
    throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((t) => `'${t}'`).join(", "));
  if (hasPlugin(e, "asyncDoExpressions") && !hasPlugin(e, "doExpressions")) {
    const t = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
    throw t.missingPlugins = "doExpressions", t;
  }
  if (hasPlugin(e, "optionalChainingAssign") && getPluginOption(e, "optionalChainingAssign", "version") !== "2023-07")
    throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
}
const mixinPlugins = {
  estree,
  jsx,
  flow,
  typescript: typescript$1,
  v8intrinsic,
  placeholders
}, mixinPluginNames = Object.keys(mixinPlugins), defaultOptions = {
  sourceType: "script",
  sourceFilename: void 0,
  startColumn: 0,
  startLine: 1,
  allowAwaitOutsideFunction: !1,
  allowReturnOutsideFunction: !1,
  allowNewTargetOutsideFunction: !1,
  allowImportExportEverywhere: !1,
  allowSuperOutsideMethod: !1,
  allowUndeclaredExports: !1,
  plugins: [],
  strictMode: null,
  ranges: !1,
  tokens: !1,
  createImportExpressions: !1,
  createParenthesizedExpressions: !1,
  errorRecovery: !1,
  attachComment: !0,
  annexB: !0
};
function getOptions(e) {
  if (e == null)
    return Object.assign({}, defaultOptions);
  if (e.annexB != null && e.annexB !== !1)
    throw new Error("The `annexB` option can only be set to `false`.");
  const t = {};
  for (const i of Object.keys(defaultOptions)) {
    var s;
    t[i] = (s = e[i]) != null ? s : defaultOptions[i];
  }
  return t;
}
class ExpressionParser extends LValParser {
  checkProto(t, s, i, a) {
    if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand)
      return;
    const o = t.key;
    if ((o.type === "Identifier" ? o.name : o.value) === "__proto__") {
      if (s) {
        this.raise(Errors.RecordNoProto, {
          at: o
        });
        return;
      }
      i.used && (a ? a.doubleProtoLoc === null && (a.doubleProtoLoc = o.loc.start) : this.raise(Errors.DuplicateProto, {
        at: o
      })), i.used = !0;
    }
  }
  shouldExitDescending(t, s) {
    return t.type === "ArrowFunctionExpression" && t.start === s;
  }
  getExpression() {
    this.enterInitialScopes(), this.nextToken();
    const t = this.parseExpression();
    return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.state.comments, t.errors = this.state.errors, this.options.tokens && (t.tokens = this.tokens), t;
  }
  parseExpression(t, s) {
    return t ? this.disallowInAnd(() => this.parseExpressionBase(s)) : this.allowInAnd(() => this.parseExpressionBase(s));
  }
  parseExpressionBase(t) {
    const s = this.state.startLoc, i = this.parseMaybeAssign(t);
    if (this.match(12)) {
      const a = this.startNodeAt(s);
      for (a.expressions = [i]; this.eat(12); )
        a.expressions.push(this.parseMaybeAssign(t));
      return this.toReferencedList(a.expressions), this.finishNode(a, "SequenceExpression");
    }
    return i;
  }
  parseMaybeAssignDisallowIn(t, s) {
    return this.disallowInAnd(() => this.parseMaybeAssign(t, s));
  }
  parseMaybeAssignAllowIn(t, s) {
    return this.allowInAnd(() => this.parseMaybeAssign(t, s));
  }
  setOptionalParametersError(t, s) {
    var i;
    t.optionalParametersLoc = (i = s == null ? void 0 : s.loc) != null ? i : this.state.startLoc;
  }
  parseMaybeAssign(t, s) {
    const i = this.state.startLoc;
    if (this.isContextual(108) && this.prodParam.hasYield) {
      let f = this.parseYield();
      return s && (f = s.call(this, f, i)), f;
    }
    let a;
    t ? a = !1 : (t = new ExpressionErrors(), a = !0);
    const {
      type: o
    } = this.state;
    (o === 10 || tokenIsIdentifier(o)) && (this.state.potentialArrowAt = this.state.start);
    let l = this.parseMaybeConditional(t);
    if (s && (l = s.call(this, l, i)), tokenIsAssignment(this.state.type)) {
      const f = this.startNodeAt(i), y = this.state.value;
      if (f.operator = y, this.match(29)) {
        this.toAssignable(l, !0), f.left = l;
        const g = i.index;
        t.doubleProtoLoc != null && t.doubleProtoLoc.index >= g && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.index >= g && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= g && (this.checkDestructuringPrivate(t), t.privateKeyLoc = null);
      } else
        f.left = l;
      return this.next(), f.right = this.parseMaybeAssign(), this.checkLVal(l, {
        in: this.finishNode(f, "AssignmentExpression")
      }), f;
    } else
      a && this.checkExpressionErrors(t, !0);
    return l;
  }
  parseMaybeConditional(t) {
    const s = this.state.startLoc, i = this.state.potentialArrowAt, a = this.parseExprOps(t);
    return this.shouldExitDescending(a, i) ? a : this.parseConditional(a, s, t);
  }
  parseConditional(t, s, i) {
    if (this.eat(17)) {
      const a = this.startNodeAt(s);
      return a.test = t, a.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), a.alternate = this.parseMaybeAssign(), this.finishNode(a, "ConditionalExpression");
    }
    return t;
  }
  parseMaybeUnaryOrPrivate(t) {
    return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(t);
  }
  parseExprOps(t) {
    const s = this.state.startLoc, i = this.state.potentialArrowAt, a = this.parseMaybeUnaryOrPrivate(t);
    return this.shouldExitDescending(a, i) ? a : this.parseExprOp(a, s, -1);
  }
  parseExprOp(t, s, i) {
    if (this.isPrivateName(t)) {
      const o = this.getPrivateNameSV(t);
      (i >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(Errors.PrivateInExpectedIn, {
        at: t,
        identifierName: o
      }), this.classScope.usePrivateName(o, t.loc.start);
    }
    const a = this.state.type;
    if (tokenIsOperator(a) && (this.prodParam.hasIn || !this.match(58))) {
      let o = tokenOperatorPrecedence(a);
      if (o > i) {
        if (a === 39) {
          if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
            return t;
          this.checkPipelineAtInfixOperator(t, s);
        }
        const l = this.startNodeAt(s);
        l.left = t, l.operator = this.state.value;
        const f = a === 41 || a === 42, y = a === 40;
        if (y && (o = tokenOperatorPrecedence(42)), this.next(), a === 39 && this.hasPlugin(["pipelineOperator", {
          proposal: "minimal"
        }]) && this.state.type === 96 && this.prodParam.hasAwait)
          throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {
            at: this.state.startLoc
          });
        l.right = this.parseExprOpRightExpr(a, o);
        const g = this.finishNode(l, f || y ? "LogicalExpression" : "BinaryExpression"), T = this.state.type;
        if (y && (T === 41 || T === 42) || f && T === 40)
          throw this.raise(Errors.MixingCoalesceWithLogical, {
            at: this.state.startLoc
          });
        return this.parseExprOp(g, s, i);
      }
    }
    return t;
  }
  parseExprOpRightExpr(t, s) {
    const i = this.state.startLoc;
    switch (t) {
      case 39:
        switch (this.getPluginOption("pipelineOperator", "proposal")) {
          case "hack":
            return this.withTopicBindingContext(() => this.parseHackPipeBody());
          case "smart":
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(108))
                throw this.raise(Errors.PipeBodyIsTighter, {
                  at: this.state.startLoc
                });
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, s), i);
            });
          case "fsharp":
            return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(s));
        }
      default:
        return this.parseExprOpBaseRightExpr(t, s);
    }
  }
  parseExprOpBaseRightExpr(t, s) {
    const i = this.state.startLoc;
    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), i, tokenIsRightAssociative(t) ? s - 1 : s);
  }
  parseHackPipeBody() {
    var t;
    const {
      startLoc: s
    } = this.state, i = this.parseMaybeAssign();
    return UnparenthesizedPipeBodyDescriptions.has(i.type) && !((t = i.extra) != null && t.parenthesized) && this.raise(Errors.PipeUnparenthesizedBody, {
      at: s,
      type: i.type
    }), this.topicReferenceWasUsedInCurrentContext() || this.raise(Errors.PipeTopicUnused, {
      at: s
    }), i;
  }
  checkExponentialAfterUnary(t) {
    this.match(57) && this.raise(Errors.UnexpectedTokenUnaryExponentiation, {
      at: t.argument
    });
  }
  parseMaybeUnary(t, s) {
    const i = this.state.startLoc, a = this.isContextual(96);
    if (a && this.isAwaitAllowed()) {
      this.next();
      const y = this.parseAwait(i);
      return s || this.checkExponentialAfterUnary(y), y;
    }
    const o = this.match(34), l = this.startNode();
    if (tokenIsPrefix(this.state.type)) {
      l.operator = this.state.value, l.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
      const y = this.match(89);
      if (this.next(), l.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), this.state.strict && y) {
        const g = l.argument;
        g.type === "Identifier" ? this.raise(Errors.StrictDelete, {
          at: l
        }) : this.hasPropertyAsPrivateName(g) && this.raise(Errors.DeletePrivateField, {
          at: l
        });
      }
      if (!o)
        return s || this.checkExponentialAfterUnary(l), this.finishNode(l, "UnaryExpression");
    }
    const f = this.parseUpdate(l, o, t);
    if (a) {
      const {
        type: y
      } = this.state;
      if ((this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(y) : tokenCanStartExpression(y) && !this.match(54)) && !this.isAmbiguousAwait())
        return this.raiseOverwrite(Errors.AwaitNotInAsyncContext, {
          at: i
        }), this.parseAwait(i);
    }
    return f;
  }
  parseUpdate(t, s, i) {
    if (s) {
      const l = t;
      return this.checkLVal(l.argument, {
        in: this.finishNode(l, "UpdateExpression")
      }), t;
    }
    const a = this.state.startLoc;
    let o = this.parseExprSubscripts(i);
    if (this.checkExpressionErrors(i, !1))
      return o;
    for (; tokenIsPostfix(this.state.type) && !this.canInsertSemicolon(); ) {
      const l = this.startNodeAt(a);
      l.operator = this.state.value, l.prefix = !1, l.argument = o, this.next(), this.checkLVal(o, {
        in: o = this.finishNode(l, "UpdateExpression")
      });
    }
    return o;
  }
  parseExprSubscripts(t) {
    const s = this.state.startLoc, i = this.state.potentialArrowAt, a = this.parseExprAtom(t);
    return this.shouldExitDescending(a, i) ? a : this.parseSubscripts(a, s);
  }
  parseSubscripts(t, s, i) {
    const a = {
      optionalChainMember: !1,
      maybeAsyncArrow: this.atPossibleAsyncArrow(t),
      stop: !1
    };
    do
      t = this.parseSubscript(t, s, i, a), a.maybeAsyncArrow = !1;
    while (!a.stop);
    return t;
  }
  parseSubscript(t, s, i, a) {
    const {
      type: o
    } = this.state;
    if (!i && o === 15)
      return this.parseBind(t, s, i, a);
    if (tokenIsTemplate(o))
      return this.parseTaggedTemplateExpression(t, s, a);
    let l = !1;
    if (o === 18) {
      if (i && (this.raise(Errors.OptionalChainingNoNew, {
        at: this.state.startLoc
      }), this.lookaheadCharCode() === 40))
        return a.stop = !0, t;
      a.optionalChainMember = l = !0, this.next();
    }
    if (!i && this.match(10))
      return this.parseCoverCallAndAsyncArrowHead(t, s, a, l);
    {
      const f = this.eat(0);
      return f || l || this.eat(16) ? this.parseMember(t, s, a, f, l) : (a.stop = !0, t);
    }
  }
  parseMember(t, s, i, a, o) {
    const l = this.startNodeAt(s);
    return l.object = t, l.computed = a, a ? (l.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (t.type === "Super" && this.raise(Errors.SuperPrivateField, {
      at: s
    }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), l.property = this.parsePrivateName()) : l.property = this.parseIdentifier(!0), i.optionalChainMember ? (l.optional = o, this.finishNode(l, "OptionalMemberExpression")) : this.finishNode(l, "MemberExpression");
  }
  parseBind(t, s, i, a) {
    const o = this.startNodeAt(s);
    return o.object = t, this.next(), o.callee = this.parseNoCallExpr(), a.stop = !0, this.parseSubscripts(this.finishNode(o, "BindExpression"), s, i);
  }
  parseCoverCallAndAsyncArrowHead(t, s, i, a) {
    const o = this.state.maybeInArrowParameters;
    let l = null;
    this.state.maybeInArrowParameters = !0, this.next();
    const f = this.startNodeAt(s);
    f.callee = t;
    const {
      maybeAsyncArrow: y,
      optionalChainMember: g
    } = i;
    y && (this.expressionScope.enter(newAsyncArrowScope()), l = new ExpressionErrors()), g && (f.optional = a), a ? f.arguments = this.parseCallExpressionArguments(11) : f.arguments = this.parseCallExpressionArguments(11, t.type === "Import", t.type !== "Super", f, l);
    let T = this.finishCallExpression(f, g);
    return y && this.shouldParseAsyncArrow() && !a ? (i.stop = !0, this.checkDestructuringPrivate(l), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), T = this.parseAsyncArrowFromCallExpression(this.startNodeAt(s), T)) : (y && (this.checkExpressionErrors(l, !0), this.expressionScope.exit()), this.toReferencedArguments(T)), this.state.maybeInArrowParameters = o, T;
  }
  toReferencedArguments(t, s) {
    this.toReferencedListDeep(t.arguments, s);
  }
  parseTaggedTemplateExpression(t, s, i) {
    const a = this.startNodeAt(s);
    return a.tag = t, a.quasi = this.parseTemplate(!0), i.optionalChainMember && this.raise(Errors.OptionalChainingNoTemplate, {
      at: s
    }), this.finishNode(a, "TaggedTemplateExpression");
  }
  atPossibleAsyncArrow(t) {
    return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && t.start === this.state.potentialArrowAt;
  }
  expectImportAttributesPlugin() {
    this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
  }
  finishCallExpression(t, s) {
    if (t.callee.type === "Import")
      if (t.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), t.arguments.length === 0 || t.arguments.length > 2)
        this.raise(Errors.ImportCallArity, {
          at: t,
          maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
        });
      else
        for (const i of t.arguments)
          i.type === "SpreadElement" && this.raise(Errors.ImportCallSpreadArgument, {
            at: i
          });
    return this.finishNode(t, s ? "OptionalCallExpression" : "CallExpression");
  }
  parseCallExpressionArguments(t, s, i, a, o) {
    const l = [];
    let f = !0;
    const y = this.state.inFSharpPipelineDirectBody;
    for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(t); ) {
      if (f)
        f = !1;
      else if (this.expect(12), this.match(t)) {
        s && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(Errors.ImportCallArgumentTrailingComma, {
          at: this.state.lastTokStartLoc
        }), a && this.addTrailingCommaExtraToNode(a), this.next();
        break;
      }
      l.push(this.parseExprListItem(!1, o, i));
    }
    return this.state.inFSharpPipelineDirectBody = y, l;
  }
  shouldParseAsyncArrow() {
    return this.match(19) && !this.canInsertSemicolon();
  }
  parseAsyncArrowFromCallExpression(t, s) {
    var i;
    return this.resetPreviousNodeTrailingComments(s), this.expect(19), this.parseArrowExpression(t, s.arguments, !0, (i = s.extra) == null ? void 0 : i.trailingCommaLoc), s.innerComments && setInnerComments(t, s.innerComments), s.callee.trailingComments && setInnerComments(t, s.callee.trailingComments), t;
  }
  parseNoCallExpr() {
    const t = this.state.startLoc;
    return this.parseSubscripts(this.parseExprAtom(), t, !0);
  }
  parseExprAtom(t) {
    let s, i = null;
    const {
      type: a
    } = this.state;
    switch (a) {
      case 79:
        return this.parseSuper();
      case 83:
        return s = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(s) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(s) : this.finishNode(s, "Import") : (this.raise(Errors.UnsupportedImport, {
          at: this.state.lastTokStartLoc
        }), this.finishNode(s, "Import"));
      case 78:
        return s = this.startNode(), this.next(), this.finishNode(s, "ThisExpression");
      case 90:
        return this.parseDo(this.startNode(), !1);
      case 56:
      case 31:
        return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
      case 134:
        return this.parseNumericLiteral(this.state.value);
      case 135:
        return this.parseBigIntLiteral(this.state.value);
      case 136:
        return this.parseDecimalLiteral(this.state.value);
      case 133:
        return this.parseStringLiteral(this.state.value);
      case 84:
        return this.parseNullLiteral();
      case 85:
        return this.parseBooleanLiteral(!0);
      case 86:
        return this.parseBooleanLiteral(!1);
      case 10: {
        const o = this.state.potentialArrowAt === this.state.start;
        return this.parseParenAndDistinguishExpression(o);
      }
      case 2:
      case 1:
        return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !1, !0);
      case 0:
        return this.parseArrayLike(3, !0, !1, t);
      case 6:
      case 7:
        return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
      case 5:
        return this.parseObjectLike(8, !1, !1, t);
      case 68:
        return this.parseFunctionOrFunctionSent();
      case 26:
        i = this.parseDecorators();
      case 80:
        return this.parseClass(this.maybeTakeDecorators(i, this.startNode()), !1);
      case 77:
        return this.parseNewOrNewTarget();
      case 25:
      case 24:
        return this.parseTemplate(!1);
      case 15: {
        s = this.startNode(), this.next(), s.object = null;
        const o = s.callee = this.parseNoCallExpr();
        if (o.type === "MemberExpression")
          return this.finishNode(s, "BindExpression");
        throw this.raise(Errors.UnsupportedBind, {
          at: o
        });
      }
      case 138:
        return this.raise(Errors.PrivateInExpectedIn, {
          at: this.state.startLoc,
          identifierName: this.state.value
        }), this.parsePrivateName();
      case 33:
        return this.parseTopicReferenceThenEqualsSign(54, "%");
      case 32:
        return this.parseTopicReferenceThenEqualsSign(44, "^");
      case 37:
      case 38:
        return this.parseTopicReference("hack");
      case 44:
      case 54:
      case 27: {
        const o = this.getPluginOption("pipelineOperator", "proposal");
        if (o)
          return this.parseTopicReference(o);
        this.unexpected();
        break;
      }
      case 47: {
        const o = this.input.codePointAt(this.nextTokenStart());
        isIdentifierStart(o) || o === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
        break;
      }
      default:
        if (tokenIsIdentifier(a)) {
          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
            return this.parseModuleExpression();
          const o = this.state.potentialArrowAt === this.state.start, l = this.state.containsEsc, f = this.parseIdentifier();
          if (!l && f.name === "async" && !this.canInsertSemicolon()) {
            const {
              type: y
            } = this.state;
            if (y === 68)
              return this.resetPreviousNodeTrailingComments(f), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(f));
            if (tokenIsIdentifier(y))
              return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(f)) : f;
            if (y === 90)
              return this.resetPreviousNodeTrailingComments(f), this.parseDo(this.startNodeAtNode(f), !0);
          }
          return o && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(f), [f], !1)) : f;
        } else
          this.unexpected();
    }
  }
  parseTopicReferenceThenEqualsSign(t, s) {
    const i = this.getPluginOption("pipelineOperator", "proposal");
    if (i)
      return this.state.type = t, this.state.value = s, this.state.pos--, this.state.end--, this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1), this.parseTopicReference(i);
    this.unexpected();
  }
  parseTopicReference(t) {
    const s = this.startNode(), i = this.state.startLoc, a = this.state.type;
    return this.next(), this.finishTopicReference(s, i, t, a);
  }
  finishTopicReference(t, s, i, a) {
    if (this.testTopicReferenceConfiguration(i, s, a)) {
      const o = i === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
      return this.topicReferenceIsAllowedInCurrentContext() || this.raise(i === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, {
        at: s
      }), this.registerTopicReference(), this.finishNode(t, o);
    } else
      throw this.raise(Errors.PipeTopicUnconfiguredToken, {
        at: s,
        token: tokenLabelName(a)
      });
  }
  testTopicReferenceConfiguration(t, s, i) {
    switch (t) {
      case "hack":
        return this.hasPlugin(["pipelineOperator", {
          topicToken: tokenLabelName(i)
        }]);
      case "smart":
        return i === 27;
      default:
        throw this.raise(Errors.PipeTopicRequiresHackPipes, {
          at: s
        });
    }
  }
  parseAsyncArrowUnaryFunction(t) {
    this.prodParam.enter(functionFlags(!0, this.prodParam.hasYield));
    const s = [this.parseIdentifier()];
    return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(Errors.LineTerminatorBeforeArrow, {
      at: this.state.curPosition()
    }), this.expect(19), this.parseArrowExpression(t, s, !0);
  }
  parseDo(t, s) {
    this.expectPlugin("doExpressions"), s && this.expectPlugin("asyncDoExpressions"), t.async = s, this.next();
    const i = this.state.labels;
    return this.state.labels = [], s ? (this.prodParam.enter(2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(), this.state.labels = i, this.finishNode(t, "DoExpression");
  }
  parseSuper() {
    const t = this.startNode();
    return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(Errors.SuperNotAllowed, {
      at: t
    }) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(Errors.UnexpectedSuper, {
      at: t
    }), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(Errors.UnsupportedSuper, {
      at: t
    }), this.finishNode(t, "Super");
  }
  parsePrivateName() {
    const t = this.startNode(), s = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1)), i = this.state.value;
    return this.next(), t.id = this.createIdentifier(s, i), this.finishNode(t, "PrivateName");
  }
  parseFunctionOrFunctionSent() {
    const t = this.startNode();
    if (this.next(), this.prodParam.hasYield && this.match(16)) {
      const s = this.createIdentifier(this.startNodeAtNode(t), "function");
      return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t, s, "sent");
    }
    return this.parseFunction(t);
  }
  parseMetaProperty(t, s, i) {
    t.meta = s;
    const a = this.state.containsEsc;
    return t.property = this.parseIdentifier(!0), (t.property.name !== i || a) && this.raise(Errors.UnsupportedMetaProperty, {
      at: t.property,
      target: s.name,
      onlyValidPropertyName: i
    }), this.finishNode(t, "MetaProperty");
  }
  parseImportMetaProperty(t) {
    const s = this.createIdentifier(this.startNodeAtNode(t), "import");
    if (this.next(), this.isContextual(101))
      this.inModule || this.raise(Errors.ImportMetaOutsideModule, {
        at: s
      }), this.sawUnambiguousESM = !0;
    else if (this.isContextual(105) || this.isContextual(97)) {
      const i = this.isContextual(105);
      if (i || this.unexpected(), this.expectPlugin(i ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
        throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, {
          at: this.state.startLoc,
          phase: this.state.value
        });
      return this.next(), t.phase = i ? "source" : "defer", this.parseImportCall(t);
    }
    return this.parseMetaProperty(t, s, "meta");
  }
  parseLiteralAtNode(t, s, i) {
    return this.addExtra(i, "rawValue", t), this.addExtra(i, "raw", this.input.slice(i.start, this.state.end)), i.value = t, this.next(), this.finishNode(i, s);
  }
  parseLiteral(t, s) {
    const i = this.startNode();
    return this.parseLiteralAtNode(t, s, i);
  }
  parseStringLiteral(t) {
    return this.parseLiteral(t, "StringLiteral");
  }
  parseNumericLiteral(t) {
    return this.parseLiteral(t, "NumericLiteral");
  }
  parseBigIntLiteral(t) {
    return this.parseLiteral(t, "BigIntLiteral");
  }
  parseDecimalLiteral(t) {
    return this.parseLiteral(t, "DecimalLiteral");
  }
  parseRegExpLiteral(t) {
    const s = this.parseLiteral(t.value, "RegExpLiteral");
    return s.pattern = t.pattern, s.flags = t.flags, s;
  }
  parseBooleanLiteral(t) {
    const s = this.startNode();
    return s.value = t, this.next(), this.finishNode(s, "BooleanLiteral");
  }
  parseNullLiteral() {
    const t = this.startNode();
    return this.next(), this.finishNode(t, "NullLiteral");
  }
  parseParenAndDistinguishExpression(t) {
    const s = this.state.startLoc;
    let i;
    this.next(), this.expressionScope.enter(newArrowHeadScope());
    const a = this.state.maybeInArrowParameters, o = this.state.inFSharpPipelineDirectBody;
    this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
    const l = this.state.startLoc, f = [], y = new ExpressionErrors();
    let g = !0, T, S;
    for (; !this.match(11); ) {
      if (g)
        g = !1;
      else if (this.expect(12, y.optionalParametersLoc === null ? null : y.optionalParametersLoc), this.match(11)) {
        S = this.state.startLoc;
        break;
      }
      if (this.match(21)) {
        const $ = this.state.startLoc;
        if (T = this.state.startLoc, f.push(this.parseParenItem(this.parseRestBinding(), $)), !this.checkCommaAfterRest(41))
          break;
      } else
        f.push(this.parseMaybeAssignAllowIn(y, this.parseParenItem));
    }
    const b = this.state.lastTokEndLoc;
    this.expect(11), this.state.maybeInArrowParameters = a, this.state.inFSharpPipelineDirectBody = o;
    let v = this.startNodeAt(s);
    return t && this.shouldParseArrow(f) && (v = this.parseArrow(v)) ? (this.checkDestructuringPrivate(y), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(v, f, !1), v) : (this.expressionScope.exit(), f.length || this.unexpected(this.state.lastTokStartLoc), S && this.unexpected(S), T && this.unexpected(T), this.checkExpressionErrors(y, !0), this.toReferencedListDeep(f, !0), f.length > 1 ? (i = this.startNodeAt(l), i.expressions = f, this.finishNode(i, "SequenceExpression"), this.resetEndLocation(i, b)) : i = f[0], this.wrapParenthesis(s, i));
  }
  wrapParenthesis(t, s) {
    if (!this.options.createParenthesizedExpressions)
      return this.addExtra(s, "parenthesized", !0), this.addExtra(s, "parenStart", t.index), this.takeSurroundingComments(s, t.index, this.state.lastTokEndLoc.index), s;
    const i = this.startNodeAt(t);
    return i.expression = s, this.finishNode(i, "ParenthesizedExpression");
  }
  shouldParseArrow(t) {
    return !this.canInsertSemicolon();
  }
  parseArrow(t) {
    if (this.eat(19))
      return t;
  }
  parseParenItem(t, s) {
    return t;
  }
  parseNewOrNewTarget() {
    const t = this.startNode();
    if (this.next(), this.match(16)) {
      const s = this.createIdentifier(this.startNodeAtNode(t), "new");
      this.next();
      const i = this.parseMetaProperty(t, s, "target");
      return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(Errors.UnexpectedNewTarget, {
        at: i
      }), i;
    }
    return this.parseNew(t);
  }
  parseNew(t) {
    if (this.parseNewCallee(t), this.eat(10)) {
      const s = this.parseExprList(11);
      this.toReferencedList(s), t.arguments = s;
    } else
      t.arguments = [];
    return this.finishNode(t, "NewExpression");
  }
  parseNewCallee(t) {
    const s = this.match(83), i = this.parseNoCallExpr();
    t.callee = i, s && (i.type === "Import" || i.type === "ImportExpression") && this.raise(Errors.ImportCallNotNewExpression, {
      at: i
    });
  }
  parseTemplateElement(t) {
    const {
      start: s,
      startLoc: i,
      end: a,
      value: o
    } = this.state, l = s + 1, f = this.startNodeAt(createPositionWithColumnOffset(i, 1));
    o === null && (t || this.raise(Errors.InvalidEscapeSequenceTemplate, {
      at: createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)
    }));
    const y = this.match(24), g = y ? -1 : -2, T = a + g;
    f.value = {
      raw: this.input.slice(l, T).replace(/\r\n?/g, `
`),
      cooked: o === null ? null : o.slice(1, g)
    }, f.tail = y, this.next();
    const S = this.finishNode(f, "TemplateElement");
    return this.resetEndLocation(S, createPositionWithColumnOffset(this.state.lastTokEndLoc, g)), S;
  }
  parseTemplate(t) {
    const s = this.startNode();
    s.expressions = [];
    let i = this.parseTemplateElement(t);
    for (s.quasis = [i]; !i.tail; )
      s.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), s.quasis.push(i = this.parseTemplateElement(t));
    return this.finishNode(s, "TemplateLiteral");
  }
  parseTemplateSubstitution() {
    return this.parseExpression();
  }
  parseObjectLike(t, s, i, a) {
    i && this.expectPlugin("recordAndTuple");
    const o = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = !1;
    const l = /* @__PURE__ */ Object.create(null);
    let f = !0;
    const y = this.startNode();
    for (y.properties = [], this.next(); !this.match(t); ) {
      if (f)
        f = !1;
      else if (this.expect(12), this.match(t)) {
        this.addTrailingCommaExtraToNode(y);
        break;
      }
      let T;
      s ? T = this.parseBindingProperty() : (T = this.parsePropertyDefinition(a), this.checkProto(T, i, l, a)), i && !this.isObjectProperty(T) && T.type !== "SpreadElement" && this.raise(Errors.InvalidRecordProperty, {
        at: T
      }), T.shorthand && this.addExtra(T, "shorthand", !0), y.properties.push(T);
    }
    this.next(), this.state.inFSharpPipelineDirectBody = o;
    let g = "ObjectExpression";
    return s ? g = "ObjectPattern" : i && (g = "RecordExpression"), this.finishNode(y, g);
  }
  addTrailingCommaExtraToNode(t) {
    this.addExtra(t, "trailingComma", this.state.lastTokStart), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
  }
  maybeAsyncOrAccessorProp(t) {
    return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
  }
  parsePropertyDefinition(t) {
    let s = [];
    if (this.match(26))
      for (this.hasPlugin("decorators") && this.raise(Errors.UnsupportedPropertyDecorator, {
        at: this.state.startLoc
      }); this.match(26); )
        s.push(this.parseDecorator());
    const i = this.startNode();
    let a = !1, o = !1, l;
    if (this.match(21))
      return s.length && this.unexpected(), this.parseSpread();
    s.length && (i.decorators = s, s = []), i.method = !1, t && (l = this.state.startLoc);
    let f = this.eat(55);
    this.parsePropertyNamePrefixOperator(i);
    const y = this.state.containsEsc, g = this.parsePropertyName(i, t);
    if (!f && !y && this.maybeAsyncOrAccessorProp(i)) {
      const T = g.name;
      T === "async" && !this.hasPrecedingLineBreak() && (a = !0, this.resetPreviousNodeTrailingComments(g), f = this.eat(55), this.parsePropertyName(i)), (T === "get" || T === "set") && (o = !0, this.resetPreviousNodeTrailingComments(g), i.kind = T, this.match(55) && (f = !0, this.raise(Errors.AccessorIsGenerator, {
        at: this.state.curPosition(),
        kind: T
      }), this.next()), this.parsePropertyName(i));
    }
    return this.parseObjPropValue(i, l, f, a, !1, o, t);
  }
  getGetterSetterExpectedParamCount(t) {
    return t.kind === "get" ? 0 : 1;
  }
  getObjectOrClassMethodParams(t) {
    return t.params;
  }
  checkGetterSetterParams(t) {
    var s;
    const i = this.getGetterSetterExpectedParamCount(t), a = this.getObjectOrClassMethodParams(t);
    a.length !== i && this.raise(t.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, {
      at: t
    }), t.kind === "set" && ((s = a[a.length - 1]) == null ? void 0 : s.type) === "RestElement" && this.raise(Errors.BadSetterRestParameter, {
      at: t
    });
  }
  parseObjectMethod(t, s, i, a, o) {
    if (o) {
      const l = this.parseMethod(t, s, !1, !1, !1, "ObjectMethod");
      return this.checkGetterSetterParams(l), l;
    }
    if (i || s || this.match(10))
      return a && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, s, i, !1, !1, "ObjectMethod");
  }
  parseObjectProperty(t, s, i, a) {
    if (t.shorthand = !1, this.eat(14))
      return t.value = i ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(a), this.finishNode(t, "ObjectProperty");
    if (!t.computed && t.key.type === "Identifier") {
      if (this.checkReservedWord(t.key.name, t.key.loc.start, !0, !1), i)
        t.value = this.parseMaybeDefault(s, cloneIdentifier(t.key));
      else if (this.match(29)) {
        const o = this.state.startLoc;
        a != null ? a.shorthandAssignLoc === null && (a.shorthandAssignLoc = o) : this.raise(Errors.InvalidCoverInitializedName, {
          at: o
        }), t.value = this.parseMaybeDefault(s, cloneIdentifier(t.key));
      } else
        t.value = cloneIdentifier(t.key);
      return t.shorthand = !0, this.finishNode(t, "ObjectProperty");
    }
  }
  parseObjPropValue(t, s, i, a, o, l, f) {
    const y = this.parseObjectMethod(t, i, a, o, l) || this.parseObjectProperty(t, s, o, f);
    return y || this.unexpected(), y;
  }
  parsePropertyName(t, s) {
    if (this.eat(0))
      t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
    else {
      const {
        type: i,
        value: a
      } = this.state;
      let o;
      if (tokenIsKeywordOrIdentifier(i))
        o = this.parseIdentifier(!0);
      else
        switch (i) {
          case 134:
            o = this.parseNumericLiteral(a);
            break;
          case 133:
            o = this.parseStringLiteral(a);
            break;
          case 135:
            o = this.parseBigIntLiteral(a);
            break;
          case 136:
            o = this.parseDecimalLiteral(a);
            break;
          case 138: {
            const l = this.state.startLoc;
            s != null ? s.privateKeyLoc === null && (s.privateKeyLoc = l) : this.raise(Errors.UnexpectedPrivateField, {
              at: l
            }), o = this.parsePrivateName();
            break;
          }
          default:
            this.unexpected();
        }
      t.key = o, i !== 138 && (t.computed = !1);
    }
    return t.key;
  }
  initFunction(t, s) {
    t.id = null, t.generator = !1, t.async = s;
  }
  parseMethod(t, s, i, a, o, l, f = !1) {
    this.initFunction(t, i), t.generator = s, this.scope.enter(18 | (f ? 64 : 0) | (o ? 32 : 0)), this.prodParam.enter(functionFlags(i, t.generator)), this.parseFunctionParams(t, a);
    const y = this.parseFunctionBodyAndFinish(t, l, !0);
    return this.prodParam.exit(), this.scope.exit(), y;
  }
  parseArrayLike(t, s, i, a) {
    i && this.expectPlugin("recordAndTuple");
    const o = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = !1;
    const l = this.startNode();
    return this.next(), l.elements = this.parseExprList(t, !i, a, l), this.state.inFSharpPipelineDirectBody = o, this.finishNode(l, i ? "TupleExpression" : "ArrayExpression");
  }
  parseArrowExpression(t, s, i, a) {
    this.scope.enter(6);
    let o = functionFlags(i, !1);
    !this.match(5) && this.prodParam.hasIn && (o |= 8), this.prodParam.enter(o), this.initFunction(t, i);
    const l = this.state.maybeInArrowParameters;
    return s && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, s, a)), this.state.maybeInArrowParameters = !1, this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = l, this.finishNode(t, "ArrowFunctionExpression");
  }
  setArrowFunctionParameters(t, s, i) {
    this.toAssignableList(s, i, !1), t.params = s;
  }
  parseFunctionBodyAndFinish(t, s, i = !1) {
    return this.parseFunctionBody(t, !1, i), this.finishNode(t, s);
  }
  parseFunctionBody(t, s, i = !1) {
    const a = s && !this.match(5);
    if (this.expressionScope.enter(newExpressionScope()), a)
      t.body = this.parseMaybeAssign(), this.checkParams(t, !1, s, !1);
    else {
      const o = this.state.strict, l = this.state.labels;
      this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t.body = this.parseBlock(!0, !1, (f) => {
        const y = !this.isSimpleParamList(t.params);
        f && y && this.raise(Errors.IllegalLanguageModeDirective, {
          at: (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t
        });
        const g = !o && this.state.strict;
        this.checkParams(t, !this.state.strict && !s && !i && !y, s, g), this.state.strict && t.id && this.checkIdentifier(t.id, 65, g);
      }), this.prodParam.exit(), this.state.labels = l;
    }
    this.expressionScope.exit();
  }
  isSimpleParameter(t) {
    return t.type === "Identifier";
  }
  isSimpleParamList(t) {
    for (let s = 0, i = t.length; s < i; s++)
      if (!this.isSimpleParameter(t[s]))
        return !1;
    return !0;
  }
  checkParams(t, s, i, a = !0) {
    const o = !s && /* @__PURE__ */ new Set(), l = {
      type: "FormalParameters"
    };
    for (const f of t.params)
      this.checkLVal(f, {
        in: l,
        binding: 5,
        checkClashes: o,
        strictModeChanged: a
      });
  }
  parseExprList(t, s, i, a) {
    const o = [];
    let l = !0;
    for (; !this.eat(t); ) {
      if (l)
        l = !1;
      else if (this.expect(12), this.match(t)) {
        a && this.addTrailingCommaExtraToNode(a), this.next();
        break;
      }
      o.push(this.parseExprListItem(s, i));
    }
    return o;
  }
  parseExprListItem(t, s, i) {
    let a;
    if (this.match(12))
      t || this.raise(Errors.UnexpectedToken, {
        at: this.state.curPosition(),
        unexpected: ","
      }), a = null;
    else if (this.match(21)) {
      const o = this.state.startLoc;
      a = this.parseParenItem(this.parseSpread(s), o);
    } else if (this.match(17)) {
      this.expectPlugin("partialApplication"), i || this.raise(Errors.UnexpectedArgumentPlaceholder, {
        at: this.state.startLoc
      });
      const o = this.startNode();
      this.next(), a = this.finishNode(o, "ArgumentPlaceholder");
    } else
      a = this.parseMaybeAssignAllowIn(s, this.parseParenItem);
    return a;
  }
  parseIdentifier(t) {
    const s = this.startNode(), i = this.parseIdentifierName(t);
    return this.createIdentifier(s, i);
  }
  createIdentifier(t, s) {
    return t.name = s, t.loc.identifierName = s, this.finishNode(t, "Identifier");
  }
  parseIdentifierName(t) {
    let s;
    const {
      startLoc: i,
      type: a
    } = this.state;
    tokenIsKeywordOrIdentifier(a) ? s = this.state.value : this.unexpected();
    const o = tokenKeywordOrIdentifierIsKeyword(a);
    return t ? o && this.replaceToken(132) : this.checkReservedWord(s, i, o, !1), this.next(), s;
  }
  checkReservedWord(t, s, i, a) {
    if (t.length > 10 || !canBeReservedWord(t))
      return;
    if (i && isKeyword(t)) {
      this.raise(Errors.UnexpectedKeyword, {
        at: s,
        keyword: t
      });
      return;
    }
    if ((this.state.strict ? a ? isStrictBindReservedWord : isStrictReservedWord : isReservedWord)(t, this.inModule)) {
      this.raise(Errors.UnexpectedReservedWord, {
        at: s,
        reservedWord: t
      });
      return;
    } else if (t === "yield") {
      if (this.prodParam.hasYield) {
        this.raise(Errors.YieldBindingIdentifier, {
          at: s
        });
        return;
      }
    } else if (t === "await") {
      if (this.prodParam.hasAwait) {
        this.raise(Errors.AwaitBindingIdentifier, {
          at: s
        });
        return;
      }
      if (this.scope.inStaticBlock) {
        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, {
          at: s
        });
        return;
      }
      this.expressionScope.recordAsyncArrowParametersError({
        at: s
      });
    } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
      this.raise(Errors.ArgumentsInClass, {
        at: s
      });
      return;
    }
  }
  isAwaitAllowed() {
    return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
  }
  parseAwait(t) {
    const s = this.startNodeAt(t);
    return this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, {
      at: s
    }), this.eat(55) && this.raise(Errors.ObsoleteAwaitStar, {
      at: s
    }), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (s.argument = this.parseMaybeUnary(null, !0)), this.finishNode(s, "AwaitExpression");
  }
  isAmbiguousAwait() {
    if (this.hasPrecedingLineBreak())
      return !0;
    const {
      type: t
    } = this.state;
    return t === 53 || t === 10 || t === 0 || tokenIsTemplate(t) || t === 102 && !this.state.containsEsc || t === 137 || t === 56 || this.hasPlugin("v8intrinsic") && t === 54;
  }
  parseYield() {
    const t = this.startNode();
    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, {
      at: t
    }), this.next();
    let s = !1, i = null;
    if (!this.hasPrecedingLineBreak())
      switch (s = this.eat(55), this.state.type) {
        case 13:
        case 139:
        case 8:
        case 11:
        case 3:
        case 9:
        case 14:
        case 12:
          if (!s)
            break;
        default:
          i = this.parseMaybeAssign();
      }
    return t.delegate = s, t.argument = i, this.finishNode(t, "YieldExpression");
  }
  parseImportCall(t) {
    return this.next(), t.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (t.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (t.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(t, "ImportExpression");
  }
  checkPipelineAtInfixOperator(t, s) {
    this.hasPlugin(["pipelineOperator", {
      proposal: "smart"
    }]) && t.type === "SequenceExpression" && this.raise(Errors.PipelineHeadSequenceExpression, {
      at: s
    });
  }
  parseSmartPipelineBodyInStyle(t, s) {
    if (this.isSimpleReference(t)) {
      const i = this.startNodeAt(s);
      return i.callee = t, this.finishNode(i, "PipelineBareFunction");
    } else {
      const i = this.startNodeAt(s);
      return this.checkSmartPipeTopicBodyEarlyErrors(s), i.expression = t, this.finishNode(i, "PipelineTopicExpression");
    }
  }
  isSimpleReference(t) {
    switch (t.type) {
      case "MemberExpression":
        return !t.computed && this.isSimpleReference(t.object);
      case "Identifier":
        return !0;
      default:
        return !1;
    }
  }
  checkSmartPipeTopicBodyEarlyErrors(t) {
    if (this.match(19))
      throw this.raise(Errors.PipelineBodyNoArrow, {
        at: this.state.startLoc
      });
    this.topicReferenceWasUsedInCurrentContext() || this.raise(Errors.PipelineTopicUnused, {
      at: t
    });
  }
  withTopicBindingContext(t) {
    const s = this.state.topicContext;
    this.state.topicContext = {
      maxNumOfResolvableTopics: 1,
      maxTopicIndex: null
    };
    try {
      return t();
    } finally {
      this.state.topicContext = s;
    }
  }
  withSmartMixTopicForbiddingContext(t) {
    if (this.hasPlugin(["pipelineOperator", {
      proposal: "smart"
    }])) {
      const s = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      try {
        return t();
      } finally {
        this.state.topicContext = s;
      }
    } else
      return t();
  }
  withSoloAwaitPermittingContext(t) {
    const s = this.state.soloAwait;
    this.state.soloAwait = !0;
    try {
      return t();
    } finally {
      this.state.soloAwait = s;
    }
  }
  allowInAnd(t) {
    const s = this.prodParam.currentFlags();
    if (8 & ~s) {
      this.prodParam.enter(s | 8);
      try {
        return t();
      } finally {
        this.prodParam.exit();
      }
    }
    return t();
  }
  disallowInAnd(t) {
    const s = this.prodParam.currentFlags();
    if (8 & s) {
      this.prodParam.enter(s & -9);
      try {
        return t();
      } finally {
        this.prodParam.exit();
      }
    }
    return t();
  }
  registerTopicReference() {
    this.state.topicContext.maxTopicIndex = 0;
  }
  topicReferenceIsAllowedInCurrentContext() {
    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
  }
  topicReferenceWasUsedInCurrentContext() {
    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
  }
  parseFSharpPipelineBody(t) {
    const s = this.state.startLoc;
    this.state.potentialArrowAt = this.state.start;
    const i = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = !0;
    const a = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, t);
    return this.state.inFSharpPipelineDirectBody = i, a;
  }
  parseModuleExpression() {
    this.expectPlugin("moduleBlocks");
    const t = this.startNode();
    this.next(), this.match(5) || this.unexpected(null, 5);
    const s = this.startNodeAt(this.state.endLoc);
    this.next();
    const i = this.initializeScopes(!0);
    this.enterInitialScopes();
    try {
      t.body = this.parseProgram(s, 8, "module");
    } finally {
      i();
    }
    return this.finishNode(t, "ModuleExpression");
  }
  parsePropertyNamePrefixOperator(t) {
  }
}
const loopLabel = {
  kind: "loop"
}, switchLabel = {
  kind: "switch"
}, loneSurrogate = /[\uD800-\uDFFF]/u, keywordRelationalOperator = /in(?:stanceof)?/y;
function babel7CompatTokens(e, t) {
  for (let s = 0; s < e.length; s++) {
    const i = e[s], {
      type: a
    } = i;
    if (typeof a == "number") {
      {
        if (a === 138) {
          const {
            loc: o,
            start: l,
            value: f,
            end: y
          } = i, g = l + 1, T = createPositionWithColumnOffset(o.start, 1);
          e.splice(s, 1, new Token({
            type: getExportedToken(27),
            value: "#",
            start: l,
            end: g,
            startLoc: o.start,
            endLoc: T
          }), new Token({
            type: getExportedToken(132),
            value: f,
            start: g,
            end: y,
            startLoc: T,
            endLoc: o.end
          })), s++;
          continue;
        }
        if (tokenIsTemplate(a)) {
          const {
            loc: o,
            start: l,
            value: f,
            end: y
          } = i, g = l + 1, T = createPositionWithColumnOffset(o.start, 1);
          let S;
          t.charCodeAt(l) === 96 ? S = new Token({
            type: getExportedToken(22),
            value: "`",
            start: l,
            end: g,
            startLoc: o.start,
            endLoc: T
          }) : S = new Token({
            type: getExportedToken(8),
            value: "}",
            start: l,
            end: g,
            startLoc: o.start,
            endLoc: T
          });
          let b, v, $, U;
          a === 24 ? (v = y - 1, $ = createPositionWithColumnOffset(o.end, -1), b = f === null ? null : f.slice(1, -1), U = new Token({
            type: getExportedToken(22),
            value: "`",
            start: v,
            end: y,
            startLoc: $,
            endLoc: o.end
          })) : (v = y - 2, $ = createPositionWithColumnOffset(o.end, -2), b = f === null ? null : f.slice(1, -2), U = new Token({
            type: getExportedToken(23),
            value: "${",
            start: v,
            end: y,
            startLoc: $,
            endLoc: o.end
          })), e.splice(s, 1, S, new Token({
            type: getExportedToken(20),
            value: b,
            start: g,
            end: v,
            startLoc: T,
            endLoc: $
          }), U), s += 2;
          continue;
        }
      }
      i.type = getExportedToken(a);
    }
  }
  return e;
}
class StatementParser extends ExpressionParser {
  parseTopLevel(t, s) {
    return t.program = this.parseProgram(s), t.comments = this.state.comments, this.options.tokens && (t.tokens = babel7CompatTokens(this.tokens, this.input)), this.finishNode(t, "File");
  }
  parseProgram(t, s = 139, i = this.options.sourceType) {
    if (t.sourceType = i, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, !0, !0, s), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
      for (const [o, l] of Array.from(this.scope.undefinedExports))
        this.raise(Errors.ModuleExportUndefined, {
          at: l,
          localName: o
        });
    let a;
    return s === 139 ? a = this.finishNode(t, "Program") : a = this.finishNodeAt(t, "Program", createPositionWithColumnOffset(this.state.startLoc, -1)), a;
  }
  stmtToDirective(t) {
    const s = t;
    s.type = "Directive", s.value = s.expression, delete s.expression;
    const i = s.value, a = i.value, o = this.input.slice(i.start, i.end), l = i.value = o.slice(1, -1);
    return this.addExtra(i, "raw", o), this.addExtra(i, "rawValue", l), this.addExtra(i, "expressionValue", a), i.type = "DirectiveLiteral", s;
  }
  parseInterpreterDirective() {
    if (!this.match(28))
      return null;
    const t = this.startNode();
    return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
  }
  isLet() {
    return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
  }
  chStartsBindingIdentifier(t, s) {
    if (isIdentifierStart(t)) {
      if (keywordRelationalOperator.lastIndex = s, keywordRelationalOperator.test(this.input)) {
        const i = this.codePointAtPos(keywordRelationalOperator.lastIndex);
        if (!isIdentifierChar(i) && i !== 92)
          return !1;
      }
      return !0;
    } else
      return t === 92;
  }
  chStartsBindingPattern(t) {
    return t === 91 || t === 123;
  }
  hasFollowingBindingAtom() {
    const t = this.nextTokenStart(), s = this.codePointAtPos(t);
    return this.chStartsBindingPattern(s) || this.chStartsBindingIdentifier(s, t);
  }
  hasInLineFollowingBindingIdentifier() {
    const t = this.nextTokenInLineStart(), s = this.codePointAtPos(t);
    return this.chStartsBindingIdentifier(s, t);
  }
  startsUsingForOf() {
    const {
      type: t,
      containsEsc: s
    } = this.lookahead();
    if (t === 102 && !s)
      return !1;
    if (tokenIsIdentifier(t) && !this.hasFollowingLineBreak())
      return this.expectPlugin("explicitResourceManagement"), !0;
  }
  startsAwaitUsing() {
    let t = this.nextTokenInLineStart();
    if (this.isUnparsedContextual(t, "using")) {
      t = this.nextTokenInLineStartSince(t + 5);
      const s = this.codePointAtPos(t);
      if (this.chStartsBindingIdentifier(s, t))
        return this.expectPlugin("explicitResourceManagement"), !0;
    }
    return !1;
  }
  parseModuleItem() {
    return this.parseStatementLike(15);
  }
  parseStatementListItem() {
    return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
  }
  parseStatementOrSloppyAnnexBFunctionDeclaration(t = !1) {
    let s = 0;
    return this.options.annexB && !this.state.strict && (s |= 4, t && (s |= 8)), this.parseStatementLike(s);
  }
  parseStatement() {
    return this.parseStatementLike(0);
  }
  parseStatementLike(t) {
    let s = null;
    return this.match(26) && (s = this.parseDecorators(!0)), this.parseStatementContent(t, s);
  }
  parseStatementContent(t, s) {
    const i = this.state.type, a = this.startNode(), o = !!(t & 2), l = !!(t & 4), f = t & 1;
    switch (i) {
      case 60:
        return this.parseBreakContinueStatement(a, !0);
      case 63:
        return this.parseBreakContinueStatement(a, !1);
      case 64:
        return this.parseDebuggerStatement(a);
      case 90:
        return this.parseDoWhileStatement(a);
      case 91:
        return this.parseForStatement(a);
      case 68:
        if (this.lookaheadCharCode() === 46)
          break;
        return l || this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, {
          at: this.state.startLoc
        }), this.parseFunctionStatement(a, !1, !o && l);
      case 80:
        return o || this.unexpected(), this.parseClass(this.maybeTakeDecorators(s, a), !0);
      case 69:
        return this.parseIfStatement(a);
      case 70:
        return this.parseReturnStatement(a);
      case 71:
        return this.parseSwitchStatement(a);
      case 72:
        return this.parseThrowStatement(a);
      case 73:
        return this.parseTryStatement(a);
      case 96:
        if (!this.state.containsEsc && this.startsAwaitUsing())
          return this.isAwaitAllowed() ? o || this.raise(Errors.UnexpectedLexicalDeclaration, {
            at: a
          }) : this.raise(Errors.AwaitUsingNotInAsyncContext, {
            at: a
          }), this.next(), this.parseVarStatement(a, "await using");
        break;
      case 107:
        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifier())
          break;
        return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(Errors.UnexpectedUsingDeclaration, {
          at: this.state.startLoc
        }) : o || this.raise(Errors.UnexpectedLexicalDeclaration, {
          at: this.state.startLoc
        }), this.parseVarStatement(a, "using");
      case 100: {
        if (this.state.containsEsc)
          break;
        const T = this.nextTokenStart(), S = this.codePointAtPos(T);
        if (S !== 91 && (!o && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(S, T) && S !== 123))
          break;
      }
      case 75:
        o || this.raise(Errors.UnexpectedLexicalDeclaration, {
          at: this.state.startLoc
        });
      case 74: {
        const T = this.state.value;
        return this.parseVarStatement(a, T);
      }
      case 92:
        return this.parseWhileStatement(a);
      case 76:
        return this.parseWithStatement(a);
      case 5:
        return this.parseBlock();
      case 13:
        return this.parseEmptyStatement(a);
      case 83: {
        const T = this.lookaheadCharCode();
        if (T === 40 || T === 46)
          break;
      }
      case 82: {
        !this.options.allowImportExportEverywhere && !f && this.raise(Errors.UnexpectedImportExport, {
          at: this.state.startLoc
        }), this.next();
        let T;
        return i === 83 ? (T = this.parseImport(a), T.type === "ImportDeclaration" && (!T.importKind || T.importKind === "value") && (this.sawUnambiguousESM = !0)) : (T = this.parseExport(a, s), (T.type === "ExportNamedDeclaration" && (!T.exportKind || T.exportKind === "value") || T.type === "ExportAllDeclaration" && (!T.exportKind || T.exportKind === "value") || T.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(T), T;
      }
      default:
        if (this.isAsyncFunction())
          return o || this.raise(Errors.AsyncFunctionInSingleStatementContext, {
            at: this.state.startLoc
          }), this.next(), this.parseFunctionStatement(a, !0, !o && l);
    }
    const y = this.state.value, g = this.parseExpression();
    return tokenIsIdentifier(i) && g.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(a, y, g, t) : this.parseExpressionStatement(a, g, s);
  }
  assertModuleNodeAllowed(t) {
    !this.options.allowImportExportEverywhere && !this.inModule && this.raise(Errors.ImportOutsideModule, {
      at: t
    });
  }
  decoratorsEnabledBeforeExport() {
    return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== !1;
  }
  maybeTakeDecorators(t, s, i) {
    return t && (s.decorators && s.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(Errors.DecoratorsBeforeAfterExport, {
      at: s.decorators[0]
    }), s.decorators.unshift(...t)) : s.decorators = t, this.resetStartLocationFromNode(s, t[0]), i && this.resetStartLocationFromNode(i, s)), s;
  }
  canHaveLeadingDecorator() {
    return this.match(80);
  }
  parseDecorators(t) {
    const s = [];
    do
      s.push(this.parseDecorator());
    while (this.match(26));
    if (this.match(82))
      t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(Errors.DecoratorExportClass, {
        at: this.state.startLoc
      });
    else if (!this.canHaveLeadingDecorator())
      throw this.raise(Errors.UnexpectedLeadingDecorator, {
        at: this.state.startLoc
      });
    return s;
  }
  parseDecorator() {
    this.expectOnePlugin(["decorators", "decorators-legacy"]);
    const t = this.startNode();
    if (this.next(), this.hasPlugin("decorators")) {
      const s = this.state.startLoc;
      let i;
      if (this.match(10)) {
        const a = this.state.startLoc;
        this.next(), i = this.parseExpression(), this.expect(11), i = this.wrapParenthesis(a, i);
        const o = this.state.startLoc;
        t.expression = this.parseMaybeDecoratorArguments(i), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && t.expression !== i && this.raise(Errors.DecoratorArgumentsOutsideParentheses, {
          at: o
        });
      } else {
        for (i = this.parseIdentifier(!1); this.eat(16); ) {
          const a = this.startNodeAt(s);
          a.object = i, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), a.property = this.parsePrivateName()) : a.property = this.parseIdentifier(!0), a.computed = !1, i = this.finishNode(a, "MemberExpression");
        }
        t.expression = this.parseMaybeDecoratorArguments(i);
      }
    } else
      t.expression = this.parseExprSubscripts();
    return this.finishNode(t, "Decorator");
  }
  parseMaybeDecoratorArguments(t) {
    if (this.eat(10)) {
      const s = this.startNodeAtNode(t);
      return s.callee = t, s.arguments = this.parseCallExpressionArguments(11, !1), this.toReferencedList(s.arguments), this.finishNode(s, "CallExpression");
    }
    return t;
  }
  parseBreakContinueStatement(t, s) {
    return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, s), this.finishNode(t, s ? "BreakStatement" : "ContinueStatement");
  }
  verifyBreakContinue(t, s) {
    let i;
    for (i = 0; i < this.state.labels.length; ++i) {
      const a = this.state.labels[i];
      if ((t.label == null || a.name === t.label.name) && (a.kind != null && (s || a.kind === "loop") || t.label && s))
        break;
    }
    if (i === this.state.labels.length) {
      const a = s ? "BreakStatement" : "ContinueStatement";
      this.raise(Errors.IllegalBreakContinue, {
        at: t,
        type: a
      });
    }
  }
  parseDebuggerStatement(t) {
    return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
  }
  parseHeaderExpression() {
    this.expect(10);
    const t = this.parseExpression();
    return this.expect(11), t;
  }
  parseDoWhileStatement(t) {
    return this.next(), this.state.labels.push(loopLabel), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
  }
  parseForStatement(t) {
    this.next(), this.state.labels.push(loopLabel);
    let s = null;
    if (this.isAwaitAllowed() && this.eatContextual(96) && (s = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))
      return s !== null && this.unexpected(s), this.parseFor(t, null);
    const i = this.isContextual(100);
    {
      const y = this.isContextual(96) && this.startsAwaitUsing(), g = y || this.isContextual(107) && this.startsUsingForOf(), T = i && this.hasFollowingBindingAtom() || g;
      if (this.match(74) || this.match(75) || T) {
        const S = this.startNode();
        let b;
        y ? (b = "await using", this.isAwaitAllowed() || this.raise(Errors.AwaitUsingNotInAsyncContext, {
          at: this.state.startLoc
        }), this.next()) : b = this.state.value, this.next(), this.parseVar(S, !0, b);
        const v = this.finishNode(S, "VariableDeclaration"), $ = this.match(58);
        return $ && g && this.raise(Errors.ForInUsing, {
          at: v
        }), ($ || this.isContextual(102)) && v.declarations.length === 1 ? this.parseForIn(t, v, s) : (s !== null && this.unexpected(s), this.parseFor(t, v));
      }
    }
    const a = this.isContextual(95), o = new ExpressionErrors(), l = this.parseExpression(!0, o), f = this.isContextual(102);
    if (f && (i && this.raise(Errors.ForOfLet, {
      at: l
    }), s === null && a && l.type === "Identifier" && this.raise(Errors.ForOfAsync, {
      at: l
    })), f || this.match(58)) {
      this.checkDestructuringPrivate(o), this.toAssignable(l, !0);
      const y = f ? "ForOfStatement" : "ForInStatement";
      return this.checkLVal(l, {
        in: {
          type: y
        }
      }), this.parseForIn(t, l, s);
    } else
      this.checkExpressionErrors(o, !0);
    return s !== null && this.unexpected(s), this.parseFor(t, l);
  }
  parseFunctionStatement(t, s, i) {
    return this.next(), this.parseFunction(t, 1 | (i ? 2 : 0) | (s ? 8 : 0));
  }
  parseIfStatement(t) {
    return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
  }
  parseReturnStatement(t) {
    return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(Errors.IllegalReturn, {
      at: this.state.startLoc
    }), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
  }
  parseSwitchStatement(t) {
    this.next(), t.discriminant = this.parseHeaderExpression();
    const s = t.cases = [];
    this.expect(5), this.state.labels.push(switchLabel), this.scope.enter(0);
    let i;
    for (let a; !this.match(8); )
      if (this.match(61) || this.match(65)) {
        const o = this.match(61);
        i && this.finishNode(i, "SwitchCase"), s.push(i = this.startNode()), i.consequent = [], this.next(), o ? i.test = this.parseExpression() : (a && this.raise(Errors.MultipleDefaultsInSwitch, {
          at: this.state.lastTokStartLoc
        }), a = !0, i.test = null), this.expect(14);
      } else
        i ? i.consequent.push(this.parseStatementListItem()) : this.unexpected();
    return this.scope.exit(), i && this.finishNode(i, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
  }
  parseThrowStatement(t) {
    return this.next(), this.hasPrecedingLineBreak() && this.raise(Errors.NewlineAfterThrow, {
      at: this.state.lastTokEndLoc
    }), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
  }
  parseCatchClauseParam() {
    const t = this.parseBindingAtom();
    return this.scope.enter(this.options.annexB && t.type === "Identifier" ? 8 : 0), this.checkLVal(t, {
      in: {
        type: "CatchClause"
      },
      binding: 9
    }), t;
  }
  parseTryStatement(t) {
    if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
      const s = this.startNode();
      this.next(), this.match(10) ? (this.expect(10), s.param = this.parseCatchClauseParam(), this.expect(11)) : (s.param = null, this.scope.enter(0)), s.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), t.handler = this.finishNode(s, "CatchClause");
    }
    return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(Errors.NoCatchOrFinally, {
      at: t
    }), this.finishNode(t, "TryStatement");
  }
  parseVarStatement(t, s, i = !1) {
    return this.next(), this.parseVar(t, !1, s, i), this.semicolon(), this.finishNode(t, "VariableDeclaration");
  }
  parseWhileStatement(t) {
    return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(loopLabel), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
  }
  parseWithStatement(t) {
    return this.state.strict && this.raise(Errors.StrictWith, {
      at: this.state.startLoc
    }), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
  }
  parseEmptyStatement(t) {
    return this.next(), this.finishNode(t, "EmptyStatement");
  }
  parseLabeledStatement(t, s, i, a) {
    for (const l of this.state.labels)
      l.name === s && this.raise(Errors.LabelRedeclaration, {
        at: i,
        labelName: s
      });
    const o = tokenIsLoop(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
    for (let l = this.state.labels.length - 1; l >= 0; l--) {
      const f = this.state.labels[l];
      if (f.statementStart === t.start)
        f.statementStart = this.state.start, f.kind = o;
      else
        break;
    }
    return this.state.labels.push({
      name: s,
      kind: o,
      statementStart: this.state.start
    }), t.body = a & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), t.label = i, this.finishNode(t, "LabeledStatement");
  }
  parseExpressionStatement(t, s, i) {
    return t.expression = s, this.semicolon(), this.finishNode(t, "ExpressionStatement");
  }
  parseBlock(t = !1, s = !0, i) {
    const a = this.startNode();
    return t && this.state.strictErrors.clear(), this.expect(5), s && this.scope.enter(0), this.parseBlockBody(a, t, !1, 8, i), s && this.scope.exit(), this.finishNode(a, "BlockStatement");
  }
  isValidDirective(t) {
    return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
  }
  parseBlockBody(t, s, i, a, o) {
    const l = t.body = [], f = t.directives = [];
    this.parseBlockOrModuleBlockBody(l, s ? f : void 0, i, a, o);
  }
  parseBlockOrModuleBlockBody(t, s, i, a, o) {
    const l = this.state.strict;
    let f = !1, y = !1;
    for (; !this.match(a); ) {
      const g = i ? this.parseModuleItem() : this.parseStatementListItem();
      if (s && !y) {
        if (this.isValidDirective(g)) {
          const T = this.stmtToDirective(g);
          s.push(T), !f && T.value.value === "use strict" && (f = !0, this.setStrict(!0));
          continue;
        }
        y = !0, this.state.strictErrors.clear();
      }
      t.push(g);
    }
    o == null || o.call(this, f), l || this.setStrict(!1), this.next();
  }
  parseFor(t, s) {
    return t.init = s, this.semicolon(!1), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), t.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
  }
  parseForIn(t, s, i) {
    const a = this.match(58);
    return this.next(), a ? i !== null && this.unexpected(i) : t.await = i !== null, s.type === "VariableDeclaration" && s.declarations[0].init != null && (!a || !this.options.annexB || this.state.strict || s.kind !== "var" || s.declarations[0].id.type !== "Identifier") && this.raise(Errors.ForInOfLoopInitializer, {
      at: s,
      type: a ? "ForInStatement" : "ForOfStatement"
    }), s.type === "AssignmentPattern" && this.raise(Errors.InvalidLhs, {
      at: s,
      ancestor: {
        type: "ForStatement"
      }
    }), t.left = s, t.right = a ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, a ? "ForInStatement" : "ForOfStatement");
  }
  parseVar(t, s, i, a = !1) {
    const o = t.declarations = [];
    for (t.kind = i; ; ) {
      const l = this.startNode();
      if (this.parseVarId(l, i), l.init = this.eat(29) ? s ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, l.init === null && !a && (l.id.type !== "Identifier" && !(s && (this.match(58) || this.isContextual(102))) ? this.raise(Errors.DeclarationMissingInitializer, {
        at: this.state.lastTokEndLoc,
        kind: "destructuring"
      }) : i === "const" && !(this.match(58) || this.isContextual(102)) && this.raise(Errors.DeclarationMissingInitializer, {
        at: this.state.lastTokEndLoc,
        kind: "const"
      })), o.push(this.finishNode(l, "VariableDeclarator")), !this.eat(12))
        break;
    }
    return t;
  }
  parseVarId(t, s) {
    const i = this.parseBindingAtom();
    this.checkLVal(i, {
      in: {
        type: "VariableDeclarator"
      },
      binding: s === "var" ? 5 : 8201
    }), t.id = i;
  }
  parseAsyncFunctionExpression(t) {
    return this.parseFunction(t, 8);
  }
  parseFunction(t, s = 0) {
    const i = s & 2, a = !!(s & 1), o = a && !(s & 4), l = !!(s & 8);
    this.initFunction(t, l), this.match(55) && (i && this.raise(Errors.GeneratorInSingleStatementContext, {
      at: this.state.startLoc
    }), this.next(), t.generator = !0), a && (t.id = this.parseFunctionId(o));
    const f = this.state.maybeInArrowParameters;
    return this.state.maybeInArrowParameters = !1, this.scope.enter(2), this.prodParam.enter(functionFlags(l, t.generator)), a || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, !1), this.withSmartMixTopicForbiddingContext(() => {
      this.parseFunctionBodyAndFinish(t, a ? "FunctionDeclaration" : "FunctionExpression");
    }), this.prodParam.exit(), this.scope.exit(), a && !i && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = f, t;
  }
  parseFunctionId(t) {
    return t || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
  }
  parseFunctionParams(t, s) {
    this.expect(10), this.expressionScope.enter(newParameterDeclarationScope()), t.params = this.parseBindingList(11, 41, 2 | (s ? 4 : 0)), this.expressionScope.exit();
  }
  registerFunctionStatementId(t) {
    t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, t.id.loc.start);
  }
  parseClass(t, s, i) {
    this.next();
    const a = this.state.strict;
    return this.state.strict = !0, this.parseClassId(t, s, i), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, a), this.finishNode(t, s ? "ClassDeclaration" : "ClassExpression");
  }
  isClassProperty() {
    return this.match(29) || this.match(13) || this.match(8);
  }
  isClassMethod() {
    return this.match(10);
  }
  isNonstaticConstructor(t) {
    return !t.computed && !t.static && (t.key.name === "constructor" || t.key.value === "constructor");
  }
  parseClassBody(t, s) {
    this.classScope.enter();
    const i = {
      hadConstructor: !1,
      hadSuperClass: t
    };
    let a = [];
    const o = this.startNode();
    if (o.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
      for (; !this.match(8); ) {
        if (this.eat(13)) {
          if (a.length > 0)
            throw this.raise(Errors.DecoratorSemicolon, {
              at: this.state.lastTokEndLoc
            });
          continue;
        }
        if (this.match(26)) {
          a.push(this.parseDecorator());
          continue;
        }
        const l = this.startNode();
        a.length && (l.decorators = a, this.resetStartLocationFromNode(l, a[0]), a = []), this.parseClassMember(o, l, i), l.kind === "constructor" && l.decorators && l.decorators.length > 0 && this.raise(Errors.DecoratorConstructor, {
          at: l
        });
      }
    }), this.state.strict = s, this.next(), a.length)
      throw this.raise(Errors.TrailingDecorator, {
        at: this.state.startLoc
      });
    return this.classScope.exit(), this.finishNode(o, "ClassBody");
  }
  parseClassMemberFromModifier(t, s) {
    const i = this.parseIdentifier(!0);
    if (this.isClassMethod()) {
      const a = s;
      return a.kind = "method", a.computed = !1, a.key = i, a.static = !1, this.pushClassMethod(t, a, !1, !1, !1, !1), !0;
    } else if (this.isClassProperty()) {
      const a = s;
      return a.computed = !1, a.key = i, a.static = !1, t.body.push(this.parseClassProperty(a)), !0;
    }
    return this.resetPreviousNodeTrailingComments(i), !1;
  }
  parseClassMember(t, s, i) {
    const a = this.isContextual(106);
    if (a) {
      if (this.parseClassMemberFromModifier(t, s))
        return;
      if (this.eat(5)) {
        this.parseClassStaticBlock(t, s);
        return;
      }
    }
    this.parseClassMemberWithIsStatic(t, s, i, a);
  }
  parseClassMemberWithIsStatic(t, s, i, a) {
    const o = s, l = s, f = s, y = s, g = s, T = o, S = o;
    if (s.static = a, this.parsePropertyNamePrefixOperator(s), this.eat(55)) {
      T.kind = "method";
      const X = this.match(138);
      if (this.parseClassElementName(T), X) {
        this.pushClassPrivateMethod(t, l, !0, !1);
        return;
      }
      this.isNonstaticConstructor(o) && this.raise(Errors.ConstructorIsGenerator, {
        at: o.key
      }), this.pushClassMethod(t, o, !0, !1, !1, !1);
      return;
    }
    const b = tokenIsIdentifier(this.state.type) && !this.state.containsEsc, v = this.match(138), $ = this.parseClassElementName(s), U = this.state.startLoc;
    if (this.parsePostMemberNameModifiers(S), this.isClassMethod()) {
      if (T.kind = "method", v) {
        this.pushClassPrivateMethod(t, l, !1, !1);
        return;
      }
      const X = this.isNonstaticConstructor(o);
      let k = !1;
      X && (o.kind = "constructor", i.hadConstructor && !this.hasPlugin("typescript") && this.raise(Errors.DuplicateConstructor, {
        at: $
      }), X && this.hasPlugin("typescript") && s.override && this.raise(Errors.OverrideOnConstructor, {
        at: $
      }), i.hadConstructor = !0, k = i.hadSuperClass), this.pushClassMethod(t, o, !1, !1, X, k);
    } else if (this.isClassProperty())
      v ? this.pushClassPrivateProperty(t, y) : this.pushClassProperty(t, f);
    else if (b && $.name === "async" && !this.isLineTerminator()) {
      this.resetPreviousNodeTrailingComments($);
      const X = this.eat(55);
      S.optional && this.unexpected(U), T.kind = "method";
      const k = this.match(138);
      this.parseClassElementName(T), this.parsePostMemberNameModifiers(S), k ? this.pushClassPrivateMethod(t, l, X, !0) : (this.isNonstaticConstructor(o) && this.raise(Errors.ConstructorIsAsync, {
        at: o.key
      }), this.pushClassMethod(t, o, X, !0, !1, !1));
    } else if (b && ($.name === "get" || $.name === "set") && !(this.match(55) && this.isLineTerminator())) {
      this.resetPreviousNodeTrailingComments($), T.kind = $.name;
      const X = this.match(138);
      this.parseClassElementName(o), X ? this.pushClassPrivateMethod(t, l, !1, !1) : (this.isNonstaticConstructor(o) && this.raise(Errors.ConstructorIsAccessor, {
        at: o.key
      }), this.pushClassMethod(t, o, !1, !1, !1, !1)), this.checkGetterSetterParams(o);
    } else if (b && $.name === "accessor" && !this.isLineTerminator()) {
      this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments($);
      const X = this.match(138);
      this.parseClassElementName(f), this.pushClassAccessorProperty(t, g, X);
    } else
      this.isLineTerminator() ? v ? this.pushClassPrivateProperty(t, y) : this.pushClassProperty(t, f) : this.unexpected();
  }
  parseClassElementName(t) {
    const {
      type: s,
      value: i
    } = this.state;
    if ((s === 132 || s === 133) && t.static && i === "prototype" && this.raise(Errors.StaticPrototype, {
      at: this.state.startLoc
    }), s === 138) {
      i === "constructor" && this.raise(Errors.ConstructorClassPrivateField, {
        at: this.state.startLoc
      });
      const a = this.parsePrivateName();
      return t.key = a, a;
    }
    return this.parsePropertyName(t);
  }
  parseClassStaticBlock(t, s) {
    var i;
    this.scope.enter(208);
    const a = this.state.labels;
    this.state.labels = [], this.prodParam.enter(0);
    const o = s.body = [];
    this.parseBlockOrModuleBlockBody(o, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = a, t.body.push(this.finishNode(s, "StaticBlock")), (i = s.decorators) != null && i.length && this.raise(Errors.DecoratorStaticBlock, {
      at: s
    });
  }
  pushClassProperty(t, s) {
    !s.computed && (s.key.name === "constructor" || s.key.value === "constructor") && this.raise(Errors.ConstructorClassField, {
      at: s.key
    }), t.body.push(this.parseClassProperty(s));
  }
  pushClassPrivateProperty(t, s) {
    const i = this.parseClassPrivateProperty(s);
    t.body.push(i), this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
  }
  pushClassAccessorProperty(t, s, i) {
    if (!i && !s.computed) {
      const o = s.key;
      (o.name === "constructor" || o.value === "constructor") && this.raise(Errors.ConstructorClassField, {
        at: o
      });
    }
    const a = this.parseClassAccessorProperty(s);
    t.body.push(a), i && this.classScope.declarePrivateName(this.getPrivateNameSV(a.key), 0, a.key.loc.start);
  }
  pushClassMethod(t, s, i, a, o, l) {
    t.body.push(this.parseMethod(s, i, a, o, l, "ClassMethod", !0));
  }
  pushClassPrivateMethod(t, s, i, a) {
    const o = this.parseMethod(s, i, a, !1, !1, "ClassPrivateMethod", !0);
    t.body.push(o);
    const l = o.kind === "get" ? o.static ? 6 : 2 : o.kind === "set" ? o.static ? 5 : 1 : 0;
    this.declareClassPrivateMethodInScope(o, l);
  }
  declareClassPrivateMethodInScope(t, s) {
    this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), s, t.key.loc.start);
  }
  parsePostMemberNameModifiers(t) {
  }
  parseClassPrivateProperty(t) {
    return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
  }
  parseClassProperty(t) {
    return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
  }
  parseClassAccessorProperty(t) {
    return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
  }
  parseInitializer(t) {
    this.scope.enter(80), this.expressionScope.enter(newExpressionScope()), this.prodParam.enter(0), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
  }
  parseClassId(t, s, i, a = 8331) {
    if (tokenIsIdentifier(this.state.type))
      t.id = this.parseIdentifier(), s && this.declareNameFromIdentifier(t.id, a);
    else if (i || !s)
      t.id = null;
    else
      throw this.raise(Errors.MissingClassName, {
        at: this.state.startLoc
      });
  }
  parseClassSuper(t) {
    t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
  }
  parseExport(t, s) {
    const i = this.parseMaybeImportPhase(t, !0), a = this.maybeParseExportDefaultSpecifier(t, i), o = !a || this.eat(12), l = o && this.eatExportStar(t), f = l && this.maybeParseExportNamespaceSpecifier(t), y = o && (!f || this.eat(12)), g = a || l;
    if (l && !f) {
      if (a && this.unexpected(), s)
        throw this.raise(Errors.UnsupportedDecoratorExport, {
          at: t
        });
      return this.parseExportFrom(t, !0), this.finishNode(t, "ExportAllDeclaration");
    }
    const T = this.maybeParseExportNamedSpecifiers(t);
    a && o && !l && !T && this.unexpected(null, 5), f && y && this.unexpected(null, 98);
    let S;
    if (g || T) {
      if (S = !1, s)
        throw this.raise(Errors.UnsupportedDecoratorExport, {
          at: t
        });
      this.parseExportFrom(t, g);
    } else
      S = this.maybeParseExportDeclaration(t);
    if (g || T || S) {
      var b;
      const v = t;
      if (this.checkExport(v, !0, !1, !!v.source), ((b = v.declaration) == null ? void 0 : b.type) === "ClassDeclaration")
        this.maybeTakeDecorators(s, v.declaration, v);
      else if (s)
        throw this.raise(Errors.UnsupportedDecoratorExport, {
          at: t
        });
      return this.finishNode(v, "ExportNamedDeclaration");
    }
    if (this.eat(65)) {
      const v = t, $ = this.parseExportDefaultExpression();
      if (v.declaration = $, $.type === "ClassDeclaration")
        this.maybeTakeDecorators(s, $, v);
      else if (s)
        throw this.raise(Errors.UnsupportedDecoratorExport, {
          at: t
        });
      return this.checkExport(v, !0, !0), this.finishNode(v, "ExportDefaultDeclaration");
    }
    this.unexpected(null, 5);
  }
  eatExportStar(t) {
    return this.eat(55);
  }
  maybeParseExportDefaultSpecifier(t, s) {
    if (s || this.isExportDefaultSpecifier()) {
      this.expectPlugin("exportDefaultFrom", s == null ? void 0 : s.loc.start);
      const i = s || this.parseIdentifier(!0), a = this.startNodeAtNode(i);
      return a.exported = i, t.specifiers = [this.finishNode(a, "ExportDefaultSpecifier")], !0;
    }
    return !1;
  }
  maybeParseExportNamespaceSpecifier(t) {
    if (this.isContextual(93)) {
      t.specifiers || (t.specifiers = []);
      const s = this.startNodeAt(this.state.lastTokStartLoc);
      return this.next(), s.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(s, "ExportNamespaceSpecifier")), !0;
    }
    return !1;
  }
  maybeParseExportNamedSpecifiers(t) {
    if (this.match(5)) {
      t.specifiers || (t.specifiers = []);
      const s = t.exportKind === "type";
      return t.specifiers.push(...this.parseExportSpecifiers(s)), t.source = null, t.declaration = null, this.hasPlugin("importAssertions") && (t.assertions = []), !0;
    }
    return !1;
  }
  maybeParseExportDeclaration(t) {
    return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions = []), t.declaration = this.parseExportDeclaration(t), !0) : !1;
  }
  isAsyncFunction() {
    if (!this.isContextual(95))
      return !1;
    const t = this.nextTokenInLineStart();
    return this.isUnparsedContextual(t, "function");
  }
  parseExportDefaultExpression() {
    const t = this.startNode();
    if (this.match(68))
      return this.next(), this.parseFunction(t, 5);
    if (this.isAsyncFunction())
      return this.next(), this.next(), this.parseFunction(t, 13);
    if (this.match(80))
      return this.parseClass(t, !0, !0);
    if (this.match(26))
      return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(Errors.DecoratorBeforeExport, {
        at: this.state.startLoc
      }), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
    if (this.match(75) || this.match(74) || this.isLet())
      throw this.raise(Errors.UnsupportedDefaultExport, {
        at: this.state.startLoc
      });
    const s = this.parseMaybeAssignAllowIn();
    return this.semicolon(), s;
  }
  parseExportDeclaration(t) {
    return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
  }
  isExportDefaultSpecifier() {
    const {
      type: t
    } = this.state;
    if (tokenIsIdentifier(t)) {
      if (t === 95 && !this.state.containsEsc || t === 100)
        return !1;
      if ((t === 130 || t === 129) && !this.state.containsEsc) {
        const {
          type: a
        } = this.lookahead();
        if (tokenIsIdentifier(a) && a !== 98 || a === 5)
          return this.expectOnePlugin(["flow", "typescript"]), !1;
      }
    } else if (!this.match(65))
      return !1;
    const s = this.nextTokenStart(), i = this.isUnparsedContextual(s, "from");
    if (this.input.charCodeAt(s) === 44 || tokenIsIdentifier(this.state.type) && i)
      return !0;
    if (this.match(65) && i) {
      const a = this.input.charCodeAt(this.nextTokenStartSince(s + 4));
      return a === 34 || a === 39;
    }
    return !1;
  }
  parseExportFrom(t, s) {
    this.eatContextual(98) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(t)) : s && this.unexpected(), this.semicolon();
  }
  shouldParseExportDeclaration() {
    const {
      type: t
    } = this.state;
    return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(Errors.DecoratorBeforeExport, {
      at: this.state.startLoc
    }), !0) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
  }
  checkExport(t, s, i, a) {
    if (s) {
      var o;
      if (i) {
        if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
          var l;
          const f = t.declaration;
          f.type === "Identifier" && f.name === "from" && f.end - f.start === 4 && !((l = f.extra) != null && l.parenthesized) && this.raise(Errors.ExportDefaultFromAsIdentifier, {
            at: f
          });
        }
      } else if ((o = t.specifiers) != null && o.length)
        for (const f of t.specifiers) {
          const {
            exported: y
          } = f, g = y.type === "Identifier" ? y.name : y.value;
          if (this.checkDuplicateExports(f, g), !a && f.local) {
            const {
              local: T
            } = f;
            T.type !== "Identifier" ? this.raise(Errors.ExportBindingIsString, {
              at: f,
              localName: T.value,
              exportName: g
            }) : (this.checkReservedWord(T.name, T.loc.start, !0, !1), this.scope.checkLocalExport(T));
          }
        }
      else if (t.declaration) {
        if (t.declaration.type === "FunctionDeclaration" || t.declaration.type === "ClassDeclaration") {
          const f = t.declaration.id;
          if (!f)
            throw new Error("Assertion failure");
          this.checkDuplicateExports(t, f.name);
        } else if (t.declaration.type === "VariableDeclaration")
          for (const f of t.declaration.declarations)
            this.checkDeclaration(f.id);
      }
    }
  }
  checkDeclaration(t) {
    if (t.type === "Identifier")
      this.checkDuplicateExports(t, t.name);
    else if (t.type === "ObjectPattern")
      for (const s of t.properties)
        this.checkDeclaration(s);
    else if (t.type === "ArrayPattern")
      for (const s of t.elements)
        s && this.checkDeclaration(s);
    else
      t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type === "AssignmentPattern" && this.checkDeclaration(t.left);
  }
  checkDuplicateExports(t, s) {
    this.exportedIdentifiers.has(s) && (s === "default" ? this.raise(Errors.DuplicateDefaultExport, {
      at: t
    }) : this.raise(Errors.DuplicateExport, {
      at: t,
      exportName: s
    })), this.exportedIdentifiers.add(s);
  }
  parseExportSpecifiers(t) {
    const s = [];
    let i = !0;
    for (this.expect(5); !this.eat(8); ) {
      if (i)
        i = !1;
      else if (this.expect(12), this.eat(8))
        break;
      const a = this.isContextual(130), o = this.match(133), l = this.startNode();
      l.local = this.parseModuleExportName(), s.push(this.parseExportSpecifier(l, o, t, a));
    }
    return s;
  }
  parseExportSpecifier(t, s, i, a) {
    return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : s ? t.exported = cloneStringLiteral(t.local) : t.exported || (t.exported = cloneIdentifier(t.local)), this.finishNode(t, "ExportSpecifier");
  }
  parseModuleExportName() {
    if (this.match(133)) {
      const t = this.parseStringLiteral(this.state.value), s = t.value.match(loneSurrogate);
      return s && this.raise(Errors.ModuleExportNameHasLoneSurrogate, {
        at: t,
        surrogateCharCode: s[0].charCodeAt(0)
      }), t;
    }
    return this.parseIdentifier(!0);
  }
  isJSONModuleImport(t) {
    return t.assertions != null ? t.assertions.some(({
      key: s,
      value: i
    }) => i.value === "json" && (s.type === "Identifier" ? s.name === "type" : s.value === "type")) : !1;
  }
  checkImportReflection(t) {
    const {
      specifiers: s
    } = t, i = s.length === 1 ? s[0].type : null;
    if (t.phase === "source")
      i !== "ImportDefaultSpecifier" && this.raise(Errors.SourcePhaseImportRequiresDefault, {
        at: s[0].loc.start
      });
    else if (t.phase === "defer")
      i !== "ImportNamespaceSpecifier" && this.raise(Errors.DeferImportRequiresNamespace, {
        at: s[0].loc.start
      });
    else if (t.module) {
      var a;
      i !== "ImportDefaultSpecifier" && this.raise(Errors.ImportReflectionNotBinding, {
        at: s[0].loc.start
      }), ((a = t.assertions) == null ? void 0 : a.length) > 0 && this.raise(Errors.ImportReflectionHasAssertion, {
        at: t.specifiers[0].loc.start
      });
    }
  }
  checkJSONModuleImport(t) {
    if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
      const {
        specifiers: s
      } = t;
      if (s != null) {
        const i = s.find((a) => {
          let o;
          if (a.type === "ExportSpecifier" ? o = a.local : a.type === "ImportSpecifier" && (o = a.imported), o !== void 0)
            return o.type === "Identifier" ? o.name !== "default" : o.value !== "default";
        });
        i !== void 0 && this.raise(Errors.ImportJSONBindingNotDefault, {
          at: i.loc.start
        });
      }
    }
  }
  isPotentialImportPhase(t) {
    return t ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
  }
  applyImportPhase(t, s, i, a) {
    s || (i === "module" ? (this.expectPlugin("importReflection", a), t.module = !0) : this.hasPlugin("importReflection") && (t.module = !1), i === "source" ? (this.expectPlugin("sourcePhaseImports", a), t.phase = "source") : i === "defer" ? (this.expectPlugin("deferredImportEvaluation", a), t.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t.phase = null));
  }
  parseMaybeImportPhase(t, s) {
    if (!this.isPotentialImportPhase(s))
      return this.applyImportPhase(t, s, null), null;
    const i = this.parseIdentifier(!0), {
      type: a
    } = this.state;
    return (tokenIsKeywordOrIdentifier(a) ? a !== 98 || this.lookaheadCharCode() === 102 : a !== 12) ? (this.resetPreviousIdentifierLeadingComments(i), this.applyImportPhase(t, s, i.name, i.loc.start), null) : (this.applyImportPhase(t, s, null), i);
  }
  isPrecedingIdImportPhase(t) {
    const {
      type: s
    } = this.state;
    return tokenIsIdentifier(s) ? s !== 98 || this.lookaheadCharCode() === 102 : s !== 12;
  }
  parseImport(t) {
    return this.match(133) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, !1));
  }
  parseImportSpecifiersAndAfter(t, s) {
    t.specifiers = [];
    const a = !this.maybeParseDefaultImportSpecifier(t, s) || this.eat(12), o = a && this.maybeParseStarImportSpecifier(t);
    return a && !o && this.parseNamedImportSpecifiers(t), this.expectContextual(98), this.parseImportSourceAndAttributes(t);
  }
  parseImportSourceAndAttributes(t) {
    var s;
    return (s = t.specifiers) != null || (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.finishNode(t, "ImportDeclaration");
  }
  parseImportSource() {
    return this.match(133) || this.unexpected(), this.parseExprAtom();
  }
  parseImportSpecifierLocal(t, s, i) {
    s.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(s, i));
  }
  finishImportSpecifier(t, s, i = 8201) {
    return this.checkLVal(t.local, {
      in: {
        type: s
      },
      binding: i
    }), this.finishNode(t, s);
  }
  parseImportAttributes() {
    this.expect(5);
    const t = [], s = /* @__PURE__ */ new Set();
    do {
      if (this.match(8))
        break;
      const i = this.startNode(), a = this.state.value;
      if (s.has(a) && this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
        at: this.state.startLoc,
        key: a
      }), s.add(a), this.match(133) ? i.key = this.parseStringLiteral(a) : i.key = this.parseIdentifier(!0), this.expect(14), !this.match(133))
        throw this.raise(Errors.ModuleAttributeInvalidValue, {
          at: this.state.startLoc
        });
      i.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(i, "ImportAttribute"));
    } while (this.eat(12));
    return this.expect(8), t;
  }
  parseModuleAttributes() {
    const t = [], s = /* @__PURE__ */ new Set();
    do {
      const i = this.startNode();
      if (i.key = this.parseIdentifier(!0), i.key.name !== "type" && this.raise(Errors.ModuleAttributeDifferentFromType, {
        at: i.key
      }), s.has(i.key.name) && this.raise(Errors.ModuleAttributesWithDuplicateKeys, {
        at: i.key,
        key: i.key.name
      }), s.add(i.key.name), this.expect(14), !this.match(133))
        throw this.raise(Errors.ModuleAttributeInvalidValue, {
          at: this.state.startLoc
        });
      i.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(i, "ImportAttribute"));
    } while (this.eat(12));
    return t;
  }
  maybeParseImportAttributes(t) {
    let s, i = !1;
    if (this.match(76)) {
      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
        return;
      this.next(), this.hasPlugin("moduleAttributes") ? s = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), s = this.parseImportAttributes()), i = !0;
    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
      this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== !0 && this.raise(Errors.ImportAttributesUseAssert, {
        at: this.state.startLoc
      }), this.addExtra(t, "deprecatedAssertSyntax", !0)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), s = this.parseImportAttributes();
    else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
      s = [];
    else if (this.hasPlugin("moduleAttributes"))
      s = [];
    else
      return;
    !i && this.hasPlugin("importAssertions") ? t.assertions = s : t.attributes = s;
  }
  maybeParseDefaultImportSpecifier(t, s) {
    if (s) {
      const i = this.startNodeAtNode(s);
      return i.local = s, t.specifiers.push(this.finishImportSpecifier(i, "ImportDefaultSpecifier")), !0;
    } else if (tokenIsKeywordOrIdentifier(this.state.type))
      return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), !0;
    return !1;
  }
  maybeParseStarImportSpecifier(t) {
    if (this.match(55)) {
      const s = this.startNode();
      return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, s, "ImportNamespaceSpecifier"), !0;
    }
    return !1;
  }
  parseNamedImportSpecifiers(t) {
    let s = !0;
    for (this.expect(5); !this.eat(8); ) {
      if (s)
        s = !1;
      else {
        if (this.eat(14))
          throw this.raise(Errors.DestructureNamedImport, {
            at: this.state.startLoc
          });
        if (this.expect(12), this.eat(8))
          break;
      }
      const i = this.startNode(), a = this.match(133), o = this.isContextual(130);
      i.imported = this.parseModuleExportName();
      const l = this.parseImportSpecifier(i, a, t.importKind === "type" || t.importKind === "typeof", o, void 0);
      t.specifiers.push(l);
    }
  }
  parseImportSpecifier(t, s, i, a, o) {
    if (this.eatContextual(93))
      t.local = this.parseIdentifier();
    else {
      const {
        imported: l
      } = t;
      if (s)
        throw this.raise(Errors.ImportBindingIsString, {
          at: t,
          importName: l.value
        });
      this.checkReservedWord(l.name, t.loc.start, !0, !0), t.local || (t.local = cloneIdentifier(l));
    }
    return this.finishImportSpecifier(t, "ImportSpecifier", o);
  }
  isThisParam(t) {
    return t.type === "Identifier" && t.name === "this";
  }
}
class Parser extends StatementParser {
  constructor(t, s) {
    t = getOptions(t), super(t, s), this.options = t, this.initializeScopes(), this.plugins = pluginsMap(this.options.plugins), this.filename = t.sourceFilename;
  }
  getScopeHandler() {
    return ScopeHandler;
  }
  parse() {
    this.enterInitialScopes();
    const t = this.startNode(), s = this.startNode();
    return this.nextToken(), t.errors = null, this.parseTopLevel(t, s), t.errors = this.state.errors, t;
  }
}
function pluginsMap(e) {
  const t = /* @__PURE__ */ new Map();
  for (const s of e) {
    const [i, a] = Array.isArray(s) ? s : [s, {}];
    t.has(i) || t.set(i, a || {});
  }
  return t;
}
function parse$1(e, t) {
  var s;
  if (((s = t) == null ? void 0 : s.sourceType) === "unambiguous") {
    t = Object.assign({}, t);
    try {
      t.sourceType = "module";
      const i = getParser(t, e), a = i.parse();
      if (i.sawUnambiguousESM)
        return a;
      if (i.ambiguousScriptDifferentAst)
        try {
          return t.sourceType = "script", getParser(t, e).parse();
        } catch {
        }
      else
        a.program.sourceType = "script";
      return a;
    } catch (i) {
      try {
        return t.sourceType = "script", getParser(t, e).parse();
      } catch {
      }
      throw i;
    }
  } else
    return getParser(t, e).parse();
}
function parseExpression(e, t) {
  const s = getParser(t, e);
  return s.options.strictMode && (s.state.strict = !0), s.getExpression();
}
function generateExportedTokenTypes(e) {
  const t = {};
  for (const s of Object.keys(e))
    t[s] = getExportedToken(e[s]);
  return t;
}
const tokTypes = generateExportedTokenTypes(tt);
function getParser(e, t) {
  let s = Parser;
  return e != null && e.plugins && (validatePlugins(e.plugins), s = getParserClass(e.plugins)), new s(e, t);
}
const parserClassCache = {};
function getParserClass(e) {
  const t = mixinPluginNames.filter((a) => hasPlugin(e, a)), s = t.join("/");
  let i = parserClassCache[s];
  if (!i) {
    i = Parser;
    for (const a of t)
      i = mixinPlugins[a](i);
    parserClassCache[s] = i;
  }
  return i;
}
var parse_1 = lib$3.parse = parse$1;
lib$3.parseExpression = parseExpression;
lib$3.tokTypes = tokTypes;
var lib$2 = {};
Object.defineProperty(lib$2, "__esModule", {
  value: !0
});
lib$2.default = hoistVariables;
var _t$8 = requireLib$1();
const {
  assignmentExpression: assignmentExpression$1,
  expressionStatement: expressionStatement$2,
  identifier: identifier$3
} = _t$8, visitor$1 = {
  Scope(e, t) {
    t.kind === "let" && e.skip();
  },
  FunctionParent(e) {
    e.skip();
  },
  VariableDeclaration(e, t) {
    if (t.kind && e.node.kind !== t.kind)
      return;
    const s = [], i = e.get("declarations");
    let a;
    for (const o of i) {
      a = o.node.id, o.node.init && s.push(expressionStatement$2(assignmentExpression$1("=", o.node.id, o.node.init)));
      for (const l of Object.keys(o.getBindingIdentifiers()))
        t.emit(identifier$3(l), l, o.node.init !== null);
    }
    e.parentPath.isFor({
      left: e.node
    }) ? e.replaceWith(a) : e.replaceWithMultiple(s);
  }
};
function hoistVariables(e, t, s = "var") {
  e.traverse(visitor$1, {
    kind: s,
    emit: t
  });
}
var hasRequiredReplacement;
function requireReplacement() {
  if (hasRequiredReplacement)
    return replacement;
  hasRequiredReplacement = 1, Object.defineProperty(replacement, "__esModule", {
    value: !0
  }), replacement._replaceWith = ce, replacement.replaceExpressionWithStatements = Pe, replacement.replaceInline = _e, replacement.replaceWith = fe, replacement.replaceWithMultiple = re, replacement.replaceWithSourceString = ie;
  var e = lib$5, t = requireLib(), s = requirePath(), i = cache, a = lib$3, o = requireLib$1(), l = lib$2;
  const {
    FUNCTION_TYPES: f,
    arrowFunctionExpression: y,
    assignmentExpression: g,
    awaitExpression: T,
    blockStatement: S,
    buildUndefinedNode: b,
    callExpression: v,
    cloneNode: $,
    conditionalExpression: U,
    expressionStatement: X,
    getBindingIdentifiers: k,
    identifier: D,
    inheritLeadingComments: B,
    inheritTrailingComments: Z,
    inheritsComments: H,
    isBlockStatement: q,
    isEmptyStatement: _,
    isExpression: j,
    isExpressionStatement: V,
    isIfStatement: ue,
    isProgram: ee,
    isStatement: se,
    isVariableDeclaration: be,
    removeComments: ve,
    returnStatement: F,
    sequenceExpression: R,
    validate: K,
    yieldExpression: z
  } = o;
  function re(ge) {
    var xe;
    this.resync(), ge = this._verifyNodeList(ge), B(ge[0], this.node), Z(ge[ge.length - 1], this.node), (xe = (0, i.getCachedPaths)(this.hub, this.parent)) == null || xe.delete(this.node), this.node = this.container[this.key] = null;
    const we = this.insertAfter(ge);
    return this.node ? this.requeue() : this.remove(), we;
  }
  function ie(ge) {
    this.resync();
    let xe;
    try {
      ge = `(${ge})`, xe = (0, a.parse)(ge);
    } catch (G) {
      const W = G.loc;
      throw W && (G.message += ` - make sure this is an expression.
` + (0, e.codeFrameColumns)(ge, {
        start: {
          line: W.line,
          column: W.column + 1
        }
      }), G.code = "BABEL_REPLACE_SOURCE_ERROR"), G;
    }
    const we = xe.program.body[0].expression;
    return t.default.removeProperties(we), this.replaceWith(we);
  }
  function fe(ge) {
    if (this.resync(), this.removed)
      throw new Error("You can't replace this node, we've already removed it");
    let xe = ge instanceof s.default ? ge.node : ge;
    if (!xe)
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === xe)
      return [this];
    if (this.isProgram() && !ee(xe))
      throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(xe))
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if (typeof xe == "string")
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let we = "";
    if (this.isNodeType("Statement") && j(xe) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(xe) && !this.parentPath.isExportDefaultDeclaration() && (xe = X(xe), we = "expression"), this.isNodeType("Expression") && se(xe) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(xe))
      return this.replaceExpressionWithStatements([xe]);
    const G = this.node;
    return G && (H(xe, G), ve(G)), this._replaceWith(xe), this.type = xe.type, this.setScope(), this.requeue(), [we ? this.get(we) : this];
  }
  function ce(ge) {
    var xe;
    if (!this.container)
      throw new ReferenceError("Container is falsy");
    this.inList ? K(this.parent, this.key, [ge]) : K(this.parent, this.key, ge), this.debug(`Replace with ${ge == null ? void 0 : ge.type}`), (xe = (0, i.getCachedPaths)(this.hub, this.parent)) == null || xe.set(ge, this).delete(this.node), this.node = this.container[this.key] = ge;
  }
  function Pe(ge) {
    this.resync();
    const xe = [], we = Ce(ge, xe);
    if (we) {
      for (const Se of xe)
        this.scope.push({
          id: Se
        });
      return this.replaceWith(we)[0].get("expressions");
    }
    const G = this.getFunctionParent(), W = G == null ? void 0 : G.is("async"), te = G == null ? void 0 : G.is("generator"), oe = y([], S(ge));
    this.replaceWith(v(oe, []));
    const me = this.get("callee");
    (0, l.default)(me.get("body"), (Se) => {
      this.scope.push({
        id: Se
      });
    }, "var");
    const pe = this.get("callee").getCompletionRecords();
    for (const Se of pe) {
      if (!Se.isExpressionStatement())
        continue;
      const Ie = Se.findParent((J) => J.isLoop());
      if (Ie) {
        let J = Ie.getData("expressionReplacementReturnUid");
        J ? J = D(J.name) : (J = me.scope.generateDeclaredUidIdentifier("ret"), me.get("body").pushContainer("body", F($(J))), Ie.setData("expressionReplacementReturnUid", J)), Se.get("expression").replaceWith(g("=", $(J), Se.node.expression));
      } else
        Se.replaceWith(F(Se.node.expression));
    }
    me.arrowFunctionToExpression();
    const ye = me, le = W && t.default.hasType(this.get("callee.body").node, "AwaitExpression", f), he = te && t.default.hasType(this.get("callee.body").node, "YieldExpression", f);
    return le && (ye.set("async", !0), he || this.replaceWith(T(this.node))), he && (ye.set("generator", !0), this.replaceWith(z(this.node, !0))), ye.get("body.body");
  }
  function Ce(ge, xe) {
    const we = [];
    let G = !0;
    for (const W of ge)
      if (_(W) || (G = !1), j(W))
        we.push(W);
      else if (V(W))
        we.push(W.expression);
      else if (be(W)) {
        if (W.kind !== "var")
          return;
        for (const te of W.declarations) {
          const oe = k(te);
          for (const me of Object.keys(oe))
            xe.push($(oe[me]));
          te.init && we.push(g("=", te.id, te.init));
        }
        G = !0;
      } else if (ue(W)) {
        const te = W.consequent ? Ce([W.consequent], xe) : b(), oe = W.alternate ? Ce([W.alternate], xe) : b();
        if (!te || !oe)
          return;
        we.push(U(W.test, te, oe));
      } else if (q(W)) {
        const te = Ce(W.body, xe);
        if (!te)
          return;
        we.push(te);
      } else if (_(W))
        ge.indexOf(W) === 0 && (G = !0);
      else
        return;
    return G && we.push(b()), we.length === 1 ? we[0] : R(we);
  }
  function _e(ge) {
    if (this.resync(), Array.isArray(ge))
      if (Array.isArray(this.container)) {
        ge = this._verifyNodeList(ge);
        const xe = this._containerInsertAfter(ge);
        return this.remove(), xe;
      } else
        return this.replaceWithMultiple(ge);
    else
      return this.replaceWith(ge);
  }
  return replacement;
}
var evaluation = {};
Object.defineProperty(evaluation, "__esModule", {
  value: !0
});
evaluation.evaluate = evaluate;
evaluation.evaluateTruthy = evaluateTruthy;
const VALID_OBJECT_CALLEES = ["Number", "String", "Math"], VALID_IDENTIFIER_CALLEES = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null], INVALID_METHODS = ["random"];
function isValidObjectCallee(e) {
  return VALID_OBJECT_CALLEES.includes(e);
}
function isValidIdentifierCallee(e) {
  return VALID_IDENTIFIER_CALLEES.includes(e);
}
function isInvalidMethod(e) {
  return INVALID_METHODS.includes(e);
}
function evaluateTruthy() {
  const e = this.evaluate();
  if (e.confident)
    return !!e.value;
}
function deopt(e, t) {
  t.confident && (t.deoptPath = e, t.confident = !1);
}
const Globals = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
function evaluateCached(e, t) {
  const {
    node: s
  } = e, {
    seen: i
  } = t;
  if (i.has(s)) {
    const a = i.get(s);
    if (a.resolved)
      return a.value;
    deopt(e, t);
    return;
  } else {
    const a = {
      resolved: !1
    };
    i.set(s, a);
    const o = _evaluate(e, t);
    return t.confident && (a.resolved = !0, a.value = o), o;
  }
}
function _evaluate(e, t) {
  if (t.confident) {
    if (e.isSequenceExpression()) {
      const s = e.get("expressions");
      return evaluateCached(s[s.length - 1], t);
    }
    if (e.isStringLiteral() || e.isNumericLiteral() || e.isBooleanLiteral())
      return e.node.value;
    if (e.isNullLiteral())
      return null;
    if (e.isTemplateLiteral())
      return evaluateQuasis(e, e.node.quasis, t);
    if (e.isTaggedTemplateExpression() && e.get("tag").isMemberExpression()) {
      const s = e.get("tag.object"), {
        node: {
          name: i
        }
      } = s, a = e.get("tag.property");
      if (s.isIdentifier() && i === "String" && !e.scope.getBinding(i) && a.isIdentifier() && a.node.name === "raw")
        return evaluateQuasis(e, e.node.quasi.quasis, t, !0);
    }
    if (e.isConditionalExpression()) {
      const s = evaluateCached(e.get("test"), t);
      return t.confident ? evaluateCached(s ? e.get("consequent") : e.get("alternate"), t) : void 0;
    }
    if (e.isExpressionWrapper())
      return evaluateCached(e.get("expression"), t);
    if (e.isMemberExpression() && !e.parentPath.isCallExpression({
      callee: e.node
    })) {
      const s = e.get("property"), i = e.get("object");
      if (i.isLiteral()) {
        const a = i.node.value, o = typeof a;
        let l = null;
        if (e.node.computed) {
          if (l = evaluateCached(s, t), !t.confident)
            return;
        } else
          s.isIdentifier() && (l = s.node.name);
        if ((o === "number" || o === "string") && l != null && (typeof l == "number" || typeof l == "string"))
          return a[l];
      }
    }
    if (e.isReferencedIdentifier()) {
      const s = e.scope.getBinding(e.node.name);
      if (s) {
        if (s.constantViolations.length > 0 || e.node.start < s.path.node.end) {
          deopt(s.path, t);
          return;
        }
        if (s.hasValue)
          return s.value;
      }
      const i = e.node.name;
      if (Globals.has(i)) {
        if (!s)
          return Globals.get(i);
        deopt(s.path, t);
        return;
      }
      const a = e.resolve();
      if (a === e) {
        deopt(e, t);
        return;
      } else
        return evaluateCached(a, t);
    }
    if (e.isUnaryExpression({
      prefix: !0
    })) {
      if (e.node.operator === "void")
        return;
      const s = e.get("argument");
      if (e.node.operator === "typeof" && (s.isFunction() || s.isClass()))
        return "function";
      const i = evaluateCached(s, t);
      if (!t.confident)
        return;
      switch (e.node.operator) {
        case "!":
          return !i;
        case "+":
          return +i;
        case "-":
          return -i;
        case "~":
          return ~i;
        case "typeof":
          return typeof i;
      }
    }
    if (e.isArrayExpression()) {
      const s = [], i = e.get("elements");
      for (const a of i) {
        const o = a.evaluate();
        if (o.confident)
          s.push(o.value);
        else {
          deopt(o.deopt, t);
          return;
        }
      }
      return s;
    }
    if (e.isObjectExpression()) {
      const s = {}, i = e.get("properties");
      for (const a of i) {
        if (a.isObjectMethod() || a.isSpreadElement()) {
          deopt(a, t);
          return;
        }
        const o = a.get("key");
        let l;
        if (a.node.computed) {
          if (l = o.evaluate(), !l.confident) {
            deopt(l.deopt, t);
            return;
          }
          l = l.value;
        } else
          o.isIdentifier() ? l = o.node.name : l = o.node.value;
        let y = a.get("value").evaluate();
        if (!y.confident) {
          deopt(y.deopt, t);
          return;
        }
        y = y.value, s[l] = y;
      }
      return s;
    }
    if (e.isLogicalExpression()) {
      const s = t.confident, i = evaluateCached(e.get("left"), t), a = t.confident;
      t.confident = s;
      const o = evaluateCached(e.get("right"), t), l = t.confident;
      switch (e.node.operator) {
        case "||":
          return t.confident = a && (!!i || l), t.confident ? i || o : void 0;
        case "&&":
          return t.confident = a && (!i || l), t.confident ? i && o : void 0;
        case "??":
          return t.confident = a && (i != null || l), t.confident ? i ?? o : void 0;
      }
    }
    if (e.isBinaryExpression()) {
      const s = evaluateCached(e.get("left"), t);
      if (!t.confident)
        return;
      const i = evaluateCached(e.get("right"), t);
      if (!t.confident)
        return;
      switch (e.node.operator) {
        case "-":
          return s - i;
        case "+":
          return s + i;
        case "/":
          return s / i;
        case "*":
          return s * i;
        case "%":
          return s % i;
        case "**":
          return Math.pow(s, i);
        case "<":
          return s < i;
        case ">":
          return s > i;
        case "<=":
          return s <= i;
        case ">=":
          return s >= i;
        case "==":
          return s == i;
        case "!=":
          return s != i;
        case "===":
          return s === i;
        case "!==":
          return s !== i;
        case "|":
          return s | i;
        case "&":
          return s & i;
        case "^":
          return s ^ i;
        case "<<":
          return s << i;
        case ">>":
          return s >> i;
        case ">>>":
          return s >>> i;
      }
    }
    if (e.isCallExpression()) {
      const s = e.get("callee");
      let i, a;
      if (s.isIdentifier() && !e.scope.getBinding(s.node.name) && (isValidObjectCallee(s.node.name) || isValidIdentifierCallee(s.node.name)) && (a = commonjsGlobal[s.node.name]), s.isMemberExpression()) {
        const o = s.get("object"), l = s.get("property");
        if (o.isIdentifier() && l.isIdentifier() && isValidObjectCallee(o.node.name) && !isInvalidMethod(l.node.name)) {
          i = commonjsGlobal[o.node.name];
          const f = l.node.name;
          Object.hasOwnProperty.call(i, f) && (a = i[f]);
        }
        if (o.isLiteral() && l.isIdentifier()) {
          const f = typeof o.node.value;
          (f === "string" || f === "number") && (i = o.node.value, a = i[l.node.name]);
        }
      }
      if (a) {
        const o = e.get("arguments").map((l) => evaluateCached(l, t));
        return t.confident ? a.apply(i, o) : void 0;
      }
    }
    deopt(e, t);
  }
}
function evaluateQuasis(e, t, s, i = !1) {
  let a = "", o = 0;
  const l = e.isTemplateLiteral() ? e.get("expressions") : e.get("quasi.expressions");
  for (const f of t) {
    if (!s.confident)
      break;
    a += i ? f.value.raw : f.value.cooked;
    const y = l[o++];
    y && (a += String(evaluateCached(y, s)));
  }
  if (s.confident)
    return a;
}
function evaluate() {
  const e = {
    confident: !0,
    deoptPath: null,
    seen: /* @__PURE__ */ new Map()
  };
  let t = evaluateCached(this, e);
  return e.confident || (t = void 0), {
    confident: e.confident,
    deopt: e.deoptPath,
    value: t
  };
}
var conversion = {}, lib$1 = {}, lib = {}, formatters$1 = {};
Object.defineProperty(formatters$1, "__esModule", {
  value: !0
});
formatters$1.statements = formatters$1.statement = formatters$1.smart = formatters$1.program = formatters$1.expression = void 0;
var _t$7 = requireLib$1();
const {
  assertExpressionStatement
} = _t$7;
function makeStatementFormatter(e) {
  return {
    code: (t) => `/* @babel/template */;
${t}`,
    validate: () => {
    },
    unwrap: (t) => e(t.program.body.slice(1))
  };
}
const smart$1 = makeStatementFormatter((e) => e.length > 1 ? e : e[0]);
formatters$1.smart = smart$1;
const statements$1 = makeStatementFormatter((e) => e);
formatters$1.statements = statements$1;
const statement$1 = makeStatementFormatter((e) => {
  if (e.length === 0)
    throw new Error("Found nothing to return.");
  if (e.length > 1)
    throw new Error("Found multiple statements but wanted one");
  return e[0];
});
formatters$1.statement = statement$1;
const expression$1 = {
  code: (e) => `(
${e}
)`,
  validate: (e) => {
    if (e.program.body.length > 1)
      throw new Error("Found multiple statements but wanted one");
    if (expression$1.unwrap(e).start === 0)
      throw new Error("Parse result included parens.");
  },
  unwrap: ({
    program: e
  }) => {
    const [t] = e.body;
    return assertExpressionStatement(t), t.expression;
  }
};
formatters$1.expression = expression$1;
const program$1 = {
  code: (e) => e,
  validate: () => {
  },
  unwrap: (e) => e.program
};
formatters$1.program = program$1;
var builder = {}, options = {};
Object.defineProperty(options, "__esModule", {
  value: !0
});
options.merge = merge;
options.normalizeReplacements = normalizeReplacements;
options.validate = validate$1;
const _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
function _objectWithoutPropertiesLoose(e, t) {
  if (e == null)
    return {};
  var s = {}, i = Object.keys(e), a, o;
  for (o = 0; o < i.length; o++)
    a = i[o], !(t.indexOf(a) >= 0) && (s[a] = e[a]);
  return s;
}
function merge(e, t) {
  const {
    placeholderWhitelist: s = e.placeholderWhitelist,
    placeholderPattern: i = e.placeholderPattern,
    preserveComments: a = e.preserveComments,
    syntacticPlaceholders: o = e.syntacticPlaceholders
  } = t;
  return {
    parser: Object.assign({}, e.parser, t.parser),
    placeholderWhitelist: s,
    placeholderPattern: i,
    preserveComments: a,
    syntacticPlaceholders: o
  };
}
function validate$1(e) {
  if (e != null && typeof e != "object")
    throw new Error("Unknown template options.");
  const t = e || {}, {
    placeholderWhitelist: s,
    placeholderPattern: i,
    preserveComments: a,
    syntacticPlaceholders: o
  } = t, l = _objectWithoutPropertiesLoose(t, _excluded);
  if (s != null && !(s instanceof Set))
    throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
  if (i != null && !(i instanceof RegExp) && i !== !1)
    throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
  if (a != null && typeof a != "boolean")
    throw new Error("'.preserveComments' must be a boolean, null, or undefined");
  if (o != null && typeof o != "boolean")
    throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
  if (o === !0 && (s != null || i != null))
    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
  return {
    parser: l,
    placeholderWhitelist: s || void 0,
    placeholderPattern: i ?? void 0,
    preserveComments: a ?? void 0,
    syntacticPlaceholders: o ?? void 0
  };
}
function normalizeReplacements(e) {
  if (Array.isArray(e))
    return e.reduce((t, s, i) => (t["$" + i] = s, t), {});
  if (typeof e == "object" || e == null)
    return e || void 0;
  throw new Error("Template replacements must be an array, object, null, or undefined");
}
var string = {}, parse = {};
Object.defineProperty(parse, "__esModule", {
  value: !0
});
parse.default = parseAndBuildMetadata;
var _t$6 = requireLib$1(), _parser = lib$3, _codeFrame = lib$5;
const {
  isCallExpression,
  isExpressionStatement,
  isFunction: isFunction$1,
  isIdentifier: isIdentifier$3,
  isJSXIdentifier,
  isNewExpression,
  isPlaceholder,
  isStatement: isStatement$1,
  isStringLiteral: isStringLiteral$2,
  removePropertiesDeep,
  traverse: traverse$1
} = _t$6, PATTERN = /^[_$A-Z0-9]+$/;
function parseAndBuildMetadata(e, t, s) {
  const {
    placeholderWhitelist: i,
    placeholderPattern: a,
    preserveComments: o,
    syntacticPlaceholders: l
  } = s, f = parseWithCodeFrame(t, s.parser, l);
  removePropertiesDeep(f, {
    preserveComments: o
  }), e.validate(f);
  const y = {
    syntactic: {
      placeholders: [],
      placeholderNames: /* @__PURE__ */ new Set()
    },
    legacy: {
      placeholders: [],
      placeholderNames: /* @__PURE__ */ new Set()
    },
    placeholderWhitelist: i,
    placeholderPattern: a,
    syntacticPlaceholders: l
  };
  return traverse$1(f, placeholderVisitorHandler, y), Object.assign({
    ast: f
  }, y.syntactic.placeholders.length ? y.syntactic : y.legacy);
}
function placeholderVisitorHandler(e, t, s) {
  var i;
  let a, o = s.syntactic.placeholders.length > 0;
  if (isPlaceholder(e)) {
    if (s.syntacticPlaceholders === !1)
      throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
    a = e.name.name, o = !0;
  } else {
    if (o || s.syntacticPlaceholders)
      return;
    if (isIdentifier$3(e) || isJSXIdentifier(e))
      a = e.name;
    else if (isStringLiteral$2(e))
      a = e.value;
    else
      return;
  }
  if (o && (s.placeholderPattern != null || s.placeholderWhitelist != null))
    throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
  if (!o && (s.placeholderPattern === !1 || !(s.placeholderPattern || PATTERN).test(a)) && !((i = s.placeholderWhitelist) != null && i.has(a)))
    return;
  t = t.slice();
  const {
    node: l,
    key: f
  } = t[t.length - 1];
  let y;
  isStringLiteral$2(e) || isPlaceholder(e, {
    expectedNode: "StringLiteral"
  }) ? y = "string" : isNewExpression(l) && f === "arguments" || isCallExpression(l) && f === "arguments" || isFunction$1(l) && f === "params" ? y = "param" : isExpressionStatement(l) && !isPlaceholder(e) ? (y = "statement", t = t.slice(0, -1)) : isStatement$1(e) && isPlaceholder(e) ? y = "statement" : y = "other";
  const {
    placeholders: g,
    placeholderNames: T
  } = o ? s.syntactic : s.legacy;
  g.push({
    name: a,
    type: y,
    resolve: (S) => resolveAncestors(S, t),
    isDuplicate: T.has(a)
  }), T.add(a);
}
function resolveAncestors(e, t) {
  let s = e;
  for (let o = 0; o < t.length - 1; o++) {
    const {
      key: l,
      index: f
    } = t[o];
    f === void 0 ? s = s[l] : s = s[l][f];
  }
  const {
    key: i,
    index: a
  } = t[t.length - 1];
  return {
    parent: s,
    key: i,
    index: a
  };
}
function parseWithCodeFrame(e, t, s) {
  const i = (t.plugins || []).slice();
  s !== !1 && i.push("placeholders"), t = Object.assign({
    allowReturnOutsideFunction: !0,
    allowSuperOutsideMethod: !0,
    sourceType: "module"
  }, t, {
    plugins: i
  });
  try {
    return (0, _parser.parse)(e, t);
  } catch (a) {
    const o = a.loc;
    throw o && (a.message += `
` + (0, _codeFrame.codeFrameColumns)(e, {
      start: o
    }), a.code = "BABEL_TEMPLATE_PARSE_ERROR"), a;
  }
}
var populate = {};
Object.defineProperty(populate, "__esModule", {
  value: !0
});
populate.default = populatePlaceholders;
var _t$5 = requireLib$1();
const {
  blockStatement: blockStatement$1,
  cloneNode: cloneNode$2,
  emptyStatement,
  expressionStatement: expressionStatement$1,
  identifier: identifier$2,
  isStatement,
  isStringLiteral: isStringLiteral$1,
  stringLiteral: stringLiteral$1,
  validate
} = _t$5;
function populatePlaceholders(e, t) {
  const s = cloneNode$2(e.ast);
  return t && (e.placeholders.forEach((i) => {
    if (!Object.prototype.hasOwnProperty.call(t, i.name)) {
      const a = i.name;
      throw new Error(`Error: No substitution given for "${a}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${a}'])}
            - { placeholderPattern: /^${a}$/ }`);
    }
  }), Object.keys(t).forEach((i) => {
    if (!e.placeholderNames.has(i))
      throw new Error(`Unknown substitution "${i}" given`);
  })), e.placeholders.slice().reverse().forEach((i) => {
    try {
      applyReplacement(i, s, t && t[i.name] || null);
    } catch (a) {
      throw a.message = `@babel/template placeholder "${i.name}": ${a.message}`, a;
    }
  }), s;
}
function applyReplacement(e, t, s) {
  e.isDuplicate && (Array.isArray(s) ? s = s.map((l) => cloneNode$2(l)) : typeof s == "object" && (s = cloneNode$2(s)));
  const {
    parent: i,
    key: a,
    index: o
  } = e.resolve(t);
  if (e.type === "string") {
    if (typeof s == "string" && (s = stringLiteral$1(s)), !s || !isStringLiteral$1(s))
      throw new Error("Expected string substitution");
  } else if (e.type === "statement")
    o === void 0 ? s ? Array.isArray(s) ? s = blockStatement$1(s) : typeof s == "string" ? s = expressionStatement$1(identifier$2(s)) : isStatement(s) || (s = expressionStatement$1(s)) : s = emptyStatement() : s && !Array.isArray(s) && (typeof s == "string" && (s = identifier$2(s)), isStatement(s) || (s = expressionStatement$1(s)));
  else if (e.type === "param") {
    if (typeof s == "string" && (s = identifier$2(s)), o === void 0)
      throw new Error("Assertion failure.");
  } else if (typeof s == "string" && (s = identifier$2(s)), Array.isArray(s))
    throw new Error("Cannot replace single expression with an array.");
  if (o === void 0)
    validate(i, a, s), i[a] = s;
  else {
    const l = i[a].slice();
    e.type === "statement" || e.type === "param" ? s == null ? l.splice(o, 1) : Array.isArray(s) ? l.splice(o, 1, ...s) : l[o] = s : l[o] = s, validate(i, a, l), i[a] = l;
  }
}
Object.defineProperty(string, "__esModule", {
  value: !0
});
string.default = stringTemplate;
var _options$2 = options, _parse$1 = parse, _populate$1 = populate;
function stringTemplate(e, t, s) {
  t = e.code(t);
  let i;
  return (a) => {
    const o = (0, _options$2.normalizeReplacements)(a);
    return i || (i = (0, _parse$1.default)(e, t, s)), e.unwrap((0, _populate$1.default)(i, o));
  };
}
var literal = {};
Object.defineProperty(literal, "__esModule", {
  value: !0
});
literal.default = literalTemplate;
var _options$1 = options, _parse = parse, _populate = populate;
function literalTemplate(e, t, s) {
  const {
    metadata: i,
    names: a
  } = buildLiteralData(e, t, s);
  return (o) => {
    const l = {};
    return o.forEach((f, y) => {
      l[a[y]] = f;
    }), (f) => {
      const y = (0, _options$1.normalizeReplacements)(f);
      return y && Object.keys(y).forEach((g) => {
        if (Object.prototype.hasOwnProperty.call(l, g))
          throw new Error("Unexpected replacement overlap.");
      }), e.unwrap((0, _populate.default)(i, y ? Object.assign(y, l) : l));
    };
  };
}
function buildLiteralData(e, t, s) {
  let i = "BABEL_TPL$";
  const a = t.join("");
  do
    i = "$$" + i;
  while (a.includes(i));
  const {
    names: o,
    code: l
  } = buildTemplateCode(t, i);
  return {
    metadata: (0, _parse.default)(e, e.code(l), {
      parser: s.parser,
      placeholderWhitelist: new Set(o.concat(s.placeholderWhitelist ? Array.from(s.placeholderWhitelist) : [])),
      placeholderPattern: s.placeholderPattern,
      preserveComments: s.preserveComments,
      syntacticPlaceholders: s.syntacticPlaceholders
    }),
    names: o
  };
}
function buildTemplateCode(e, t) {
  const s = [];
  let i = e[0];
  for (let a = 1; a < e.length; a++) {
    const o = `${t}${a - 1}`;
    s.push(o), i += o + e[a];
  }
  return {
    names: s,
    code: i
  };
}
Object.defineProperty(builder, "__esModule", {
  value: !0
});
builder.default = createTemplateBuilder;
var _options = options, _string = string, _literal = literal;
const NO_PLACEHOLDER = (0, _options.validate)({
  placeholderPattern: !1
});
function createTemplateBuilder(e, t) {
  const s = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), a = t || (0, _options.validate)(null);
  return Object.assign((o, ...l) => {
    if (typeof o == "string") {
      if (l.length > 1)
        throw new Error("Unexpected extra params.");
      return extendedTrace((0, _string.default)(e, o, (0, _options.merge)(a, (0, _options.validate)(l[0]))));
    } else if (Array.isArray(o)) {
      let f = s.get(o);
      return f || (f = (0, _literal.default)(e, o, a), s.set(o, f)), extendedTrace(f(l));
    } else if (typeof o == "object" && o) {
      if (l.length > 0)
        throw new Error("Unexpected extra params.");
      return createTemplateBuilder(e, (0, _options.merge)(a, (0, _options.validate)(o)));
    }
    throw new Error(`Unexpected template param ${typeof o}`);
  }, {
    ast: (o, ...l) => {
      if (typeof o == "string") {
        if (l.length > 1)
          throw new Error("Unexpected extra params.");
        return (0, _string.default)(e, o, (0, _options.merge)((0, _options.merge)(a, (0, _options.validate)(l[0])), NO_PLACEHOLDER))();
      } else if (Array.isArray(o)) {
        let f = i.get(o);
        return f || (f = (0, _literal.default)(e, o, (0, _options.merge)(a, NO_PLACEHOLDER)), i.set(o, f)), f(l)();
      }
      throw new Error(`Unexpected template param ${typeof o}`);
    }
  });
}
function extendedTrace(e) {
  let t = "";
  try {
    throw new Error();
  } catch (s) {
    s.stack && (t = s.stack.split(`
`).slice(3).join(`
`));
  }
  return (s) => {
    try {
      return e(s);
    } catch (i) {
      throw i.stack += `
    =============
${t}`, i;
    }
  };
}
Object.defineProperty(lib, "__esModule", {
  value: !0
});
lib.statements = lib.statement = lib.smart = lib.program = lib.expression = lib.default = void 0;
var formatters = formatters$1, _builder = builder;
const smart = (0, _builder.default)(formatters.smart);
lib.smart = smart;
const statement = (0, _builder.default)(formatters.statement);
lib.statement = statement;
const statements = (0, _builder.default)(formatters.statements);
lib.statements = statements;
const expression = (0, _builder.default)(formatters.expression);
lib.expression = expression;
const program = (0, _builder.default)(formatters.program);
lib.program = program;
var _default$1 = Object.assign(smart.bind(void 0), {
  smart,
  statement,
  statements,
  expression,
  program,
  ast: smart.ast
});
lib.default = _default$1;
Object.defineProperty(lib$1, "__esModule", {
  value: !0
});
lib$1.default = _default;
var _template = lib, _t$4 = requireLib$1();
const {
  NOT_LOCAL_BINDING,
  cloneNode: cloneNode$1,
  identifier: identifier$1,
  isAssignmentExpression,
  isAssignmentPattern,
  isFunction,
  isIdentifier: isIdentifier$2,
  isLiteral: isLiteral$1,
  isNullLiteral,
  isObjectMethod,
  isObjectProperty,
  isRegExpLiteral,
  isRestElement,
  isTemplateLiteral,
  isVariableDeclarator,
  toBindingIdentifierName
} = _t$4;
function getFunctionArity(e) {
  const t = e.params.findIndex((s) => isAssignmentPattern(s) || isRestElement(s));
  return t === -1 ? e.params.length : t;
}
const buildPropertyMethodAssignmentWrapper = _template.default.statement(`
  (function (FUNCTION_KEY) {
    function FUNCTION_ID() {
      return FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    }

    return FUNCTION_ID;
  })(FUNCTION)
`), buildGeneratorPropertyMethodAssignmentWrapper = _template.default.statement(`
  (function (FUNCTION_KEY) {
    function* FUNCTION_ID() {
      return yield* FUNCTION_KEY.apply(this, arguments);
    }

    FUNCTION_ID.toString = function () {
      return FUNCTION_KEY.toString();
    };

    return FUNCTION_ID;
  })(FUNCTION)
`), visitor = {
  "ReferencedIdentifier|BindingIdentifier"(e, t) {
    e.node.name !== t.name || e.scope.getBindingIdentifier(t.name) !== t.outerDeclar || (t.selfReference = !0, e.stop());
  }
};
function getNameFromLiteralId(e) {
  return isNullLiteral(e) ? "null" : isRegExpLiteral(e) ? `_${e.pattern}_${e.flags}` : isTemplateLiteral(e) ? e.quasis.map((t) => t.value.raw).join("") : e.value !== void 0 ? e.value + "" : "";
}
function wrap(e, t, s, i) {
  if (e.selfReference)
    if (i.hasBinding(s.name) && !i.hasGlobal(s.name))
      i.rename(s.name);
    else {
      if (!isFunction(t))
        return;
      let a = buildPropertyMethodAssignmentWrapper;
      t.generator && (a = buildGeneratorPropertyMethodAssignmentWrapper);
      const o = a({
        FUNCTION: t,
        FUNCTION_ID: s,
        FUNCTION_KEY: i.generateUidIdentifier(s.name)
      }).expression, l = o.callee.body.body[0].params;
      for (let f = 0, y = getFunctionArity(t); f < y; f++)
        l.push(i.generateUidIdentifier("x"));
      return o;
    }
  t.id = s, i.getProgramParent().references[s.name] = !0;
}
function visit(e, t, s) {
  const i = {
    selfAssignment: !1,
    selfReference: !1,
    outerDeclar: s.getBindingIdentifier(t),
    name: t
  }, a = s.getOwnBinding(t);
  return a ? a.kind === "param" && (i.selfReference = !0) : (i.outerDeclar || s.hasGlobal(t)) && s.traverse(e, visitor, i), i;
}
function _default({
  node: e,
  parent: t,
  scope: s,
  id: i
}, a = !1, o = !1) {
  if (e.id)
    return;
  if ((isObjectProperty(t) || isObjectMethod(t, {
    kind: "method"
  })) && (!t.computed || isLiteral$1(t.key)))
    i = t.key;
  else if (isVariableDeclarator(t)) {
    if (i = t.id, isIdentifier$2(i) && !a) {
      const g = s.parent.getBinding(i.name);
      if (g && g.constant && s.getBinding(i.name) === g) {
        e.id = cloneNode$1(i), e.id[NOT_LOCAL_BINDING] = !0;
        return;
      }
    }
  } else if (isAssignmentExpression(t, {
    operator: "="
  }))
    i = t.left;
  else if (!i)
    return;
  let l;
  if (i && isLiteral$1(i) ? l = getNameFromLiteralId(i) : i && isIdentifier$2(i) && (l = i.name), l === void 0 || !o && isFunction(e) && /[\uD800-\uDFFF]/.test(l))
    return;
  l = toBindingIdentifierName(l);
  const f = identifier$1(l);
  f[NOT_LOCAL_BINDING] = !0;
  const y = visit(e, l, s);
  return wrap(y, e, f, s) || e;
}
Object.defineProperty(conversion, "__esModule", {
  value: !0
});
conversion.arrowFunctionToExpression = arrowFunctionToExpression;
conversion.ensureBlock = ensureBlock;
conversion.toComputedKey = toComputedKey;
conversion.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
var _t$3 = requireLib$1(), _helperEnvironmentVisitor = lib$7, _helperFunctionName = lib$1, _visitors = visitors;
const {
  arrowFunctionExpression,
  assignmentExpression,
  binaryExpression,
  blockStatement,
  callExpression,
  conditionalExpression,
  expressionStatement,
  identifier,
  isIdentifier: isIdentifier$1,
  jsxIdentifier,
  logicalExpression,
  LOGICAL_OPERATORS,
  memberExpression,
  metaProperty,
  numericLiteral,
  objectExpression,
  restElement,
  returnStatement,
  sequenceExpression,
  spreadElement,
  stringLiteral,
  super: _super,
  thisExpression,
  toExpression,
  unaryExpression
} = _t$3;
function toComputedKey() {
  let e;
  if (this.isMemberExpression())
    e = this.node.property;
  else if (this.isProperty() || this.isMethod())
    e = this.node.key;
  else
    throw new ReferenceError("todo");
  return this.node.computed || isIdentifier$1(e) && (e = stringLiteral(e.name)), e;
}
function ensureBlock() {
  const e = this.get("body"), t = e.node;
  if (Array.isArray(e))
    throw new Error("Can't convert array path to a block statement");
  if (!t)
    throw new Error("Can't convert node without a body");
  if (e.isBlockStatement())
    return t;
  const s = [];
  let i = "body", a, o;
  e.isStatement() ? (o = "body", a = 0, s.push(e.node)) : (i += ".body.0", this.isFunction() ? (a = "argument", s.push(returnStatement(e.node))) : (a = "expression", s.push(expressionStatement(e.node)))), this.node.body = blockStatement(s);
  const l = this.get(i);
  return e.setup(l, o ? l.node[o] : l.node, o, a), this.node;
}
conversion.arrowFunctionToShadowed = function() {
  this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
};
function unwrapFunctionEnvironment() {
  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
    throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
  hoistFunctionEnvironment(this);
}
function setType(e, t) {
  e.node.type = t;
}
function arrowFunctionToExpression({
  allowInsertArrow: e = !0,
  allowInsertArrowWithRest: t = e,
  noNewArrows: s = !((i) => (i = arguments[0]) == null ? void 0 : i.specCompliant)()
} = {}) {
  if (!this.isArrowFunctionExpression())
    throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
  const {
    thisBinding: i,
    fnPath: a
  } = hoistFunctionEnvironment(this, s, e, t);
  if (a.ensureBlock(), setType(a, "FunctionExpression"), !s) {
    const o = i ? null : a.scope.generateUidIdentifier("arrowCheckId");
    return o && a.parentPath.scope.push({
      id: o,
      init: objectExpression([])
    }), a.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), identifier(o ? o.name : i)]))), a.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, !0) || a.node, identifier("bind")), [o ? identifier(o.name) : thisExpression()])), a.get("callee.object");
  }
  return a;
}
const getSuperCallsVisitor = (0, _visitors.merge)([{
  CallExpression(e, {
    allSuperCalls: t
  }) {
    e.get("callee").isSuper() && t.push(e);
  }
}, _helperEnvironmentVisitor.default]);
function hoistFunctionEnvironment(e, t = !0, s = !0, i = !0) {
  let a, o = e.findParent((v) => {
    if (v.isArrowFunctionExpression()) {
      var $;
      return ($ = a) != null || (a = v), !1;
    }
    return v.isFunction() || v.isProgram() || v.isClassProperty({
      static: !1
    }) || v.isClassPrivateProperty({
      static: !1
    });
  });
  const l = o.isClassMethod({
    kind: "constructor"
  });
  if (o.isClassProperty() || o.isClassPrivateProperty())
    if (a)
      o = a;
    else if (s)
      e.replaceWith(callExpression(arrowFunctionExpression([], toExpression(e.node)), [])), o = e.get("callee"), e = o.get("body");
    else
      throw e.buildCodeFrameError("Unable to transform arrow inside class property");
  const {
    thisPaths: f,
    argumentsPaths: y,
    newTargetPaths: g,
    superProps: T,
    superCalls: S
  } = getScopeInformation(e);
  if (l && S.length > 0) {
    if (!s)
      throw S[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
    if (!i)
      throw S[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
    const v = [];
    o.traverse(getSuperCallsVisitor, {
      allSuperCalls: v
    });
    const $ = getSuperBinding(o);
    v.forEach((U) => {
      const X = identifier($);
      X.loc = U.node.callee.loc, U.get("callee").replaceWith(X);
    });
  }
  if (y.length > 0) {
    const v = getBinding(o, "arguments", () => {
      const $ = () => identifier("arguments");
      return o.scope.path.isProgram() ? conditionalExpression(binaryExpression("===", unaryExpression("typeof", $()), stringLiteral("undefined")), o.scope.buildUndefinedNode(), $()) : $();
    });
    y.forEach(($) => {
      const U = identifier(v);
      U.loc = $.node.loc, $.replaceWith(U);
    });
  }
  if (g.length > 0) {
    const v = getBinding(o, "newtarget", () => metaProperty(identifier("new"), identifier("target")));
    g.forEach(($) => {
      const U = identifier(v);
      U.loc = $.node.loc, $.replaceWith(U);
    });
  }
  if (T.length > 0) {
    if (!s)
      throw T[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
    T.reduce(($, U) => $.concat(standardizeSuperProperty(U)), []).forEach(($) => {
      const U = $.node.computed ? "" : $.get("property").node.name, X = $.parentPath, k = X.isAssignmentExpression({
        left: $.node
      }), D = X.isCallExpression({
        callee: $.node
      }), B = X.isTaggedTemplateExpression({
        tag: $.node
      }), Z = getSuperPropBinding(o, k, U), H = [];
      if ($.node.computed && H.push($.get("property").node), k) {
        const _ = X.node.right;
        H.push(_);
      }
      const q = callExpression(identifier(Z), H);
      D ? (X.unshiftContainer("arguments", thisExpression()), $.replaceWith(memberExpression(q, identifier("call"))), f.push(X.get("arguments.0"))) : k ? X.replaceWith(q) : B ? ($.replaceWith(callExpression(memberExpression(q, identifier("bind"), !1), [thisExpression()])), f.push($.get("arguments.0"))) : $.replaceWith(q);
    });
  }
  let b;
  return (f.length > 0 || !t) && (b = getThisBinding(o, l), (t || l && hasSuperClass(o)) && (f.forEach((v) => {
    const $ = v.isJSX() ? jsxIdentifier(b) : identifier(b);
    $.loc = v.node.loc, v.replaceWith($);
  }), t || (b = null))), {
    thisBinding: b,
    fnPath: e
  };
}
function isLogicalOp(e) {
  return LOGICAL_OPERATORS.includes(e);
}
function standardizeSuperProperty(e) {
  if (e.parentPath.isAssignmentExpression() && e.parentPath.node.operator !== "=") {
    const s = e.parentPath, i = s.node.operator.slice(0, -1), a = s.node.right, o = isLogicalOp(i);
    if (e.node.computed) {
      const l = e.scope.generateDeclaredUidIdentifier("tmp"), f = e.node.object, y = e.node.property;
      s.get("left").replaceWith(memberExpression(f, assignmentExpression("=", l, y), !0)), s.get("right").replaceWith(t(o ? "=" : i, memberExpression(f, identifier(l.name), !0), a));
    } else {
      const l = e.node.object, f = e.node.property;
      s.get("left").replaceWith(memberExpression(l, f)), s.get("right").replaceWith(t(o ? "=" : i, memberExpression(l, identifier(f.name)), a));
    }
    return o ? s.replaceWith(logicalExpression(i, s.node.left, s.node.right)) : s.node.operator = "=", [s.get("left"), s.get("right").get("left")];
  } else if (e.parentPath.isUpdateExpression()) {
    const s = e.parentPath, i = e.scope.generateDeclaredUidIdentifier("tmp"), a = e.node.computed ? e.scope.generateDeclaredUidIdentifier("prop") : null, o = [assignmentExpression("=", i, memberExpression(e.node.object, a ? assignmentExpression("=", a, e.node.property) : e.node.property, e.node.computed)), assignmentExpression("=", memberExpression(e.node.object, a ? identifier(a.name) : e.node.property, e.node.computed), binaryExpression(e.parentPath.node.operator[0], identifier(i.name), numericLiteral(1)))];
    e.parentPath.node.prefix || o.push(identifier(i.name)), s.replaceWith(sequenceExpression(o));
    const l = s.get("expressions.0.right"), f = s.get("expressions.1.left");
    return [l, f];
  }
  return [e];
  function t(s, i, a) {
    return s === "=" ? assignmentExpression("=", i, a) : binaryExpression(s, i, a);
  }
}
function hasSuperClass(e) {
  return e.isClassMethod() && !!e.parentPath.parentPath.node.superClass;
}
const assignSuperThisVisitor = (0, _visitors.merge)([{
  CallExpression(e, {
    supers: t,
    thisBinding: s
  }) {
    e.get("callee").isSuper() && (t.has(e.node) || (t.add(e.node), e.replaceWithMultiple([e.node, assignmentExpression("=", identifier(s), identifier("this"))])));
  }
}, _helperEnvironmentVisitor.default]);
function getThisBinding(e, t) {
  return getBinding(e, "this", (s) => {
    if (!t || !hasSuperClass(e))
      return thisExpression();
    e.traverse(assignSuperThisVisitor, {
      supers: /* @__PURE__ */ new WeakSet(),
      thisBinding: s
    });
  });
}
function getSuperBinding(e) {
  return getBinding(e, "supercall", () => {
    const t = e.scope.generateUidIdentifier("args");
    return arrowFunctionExpression([restElement(t)], callExpression(_super(), [spreadElement(identifier(t.name))]));
  });
}
function getSuperPropBinding(e, t, s) {
  return getBinding(e, `superprop_${t ? "set" : "get"}:${s || ""}`, () => {
    const a = [];
    let o;
    if (s)
      o = memberExpression(_super(), identifier(s));
    else {
      const l = e.scope.generateUidIdentifier("prop");
      a.unshift(l), o = memberExpression(_super(), identifier(l.name), !0);
    }
    if (t) {
      const l = e.scope.generateUidIdentifier("value");
      a.push(l), o = assignmentExpression("=", o, identifier(l.name));
    }
    return arrowFunctionExpression(a, o);
  });
}
function getBinding(e, t, s) {
  const i = "binding:" + t;
  let a = e.getData(i);
  if (!a) {
    const o = e.scope.generateUidIdentifier(t);
    a = o.name, e.setData(i, a), e.scope.push({
      id: o,
      init: s(a)
    });
  }
  return a;
}
const getScopeInformationVisitor = (0, _visitors.merge)([{
  ThisExpression(e, {
    thisPaths: t
  }) {
    t.push(e);
  },
  JSXIdentifier(e, {
    thisPaths: t
  }) {
    e.node.name === "this" && (!e.parentPath.isJSXMemberExpression({
      object: e.node
    }) && !e.parentPath.isJSXOpeningElement({
      name: e.node
    }) || t.push(e));
  },
  CallExpression(e, {
    superCalls: t
  }) {
    e.get("callee").isSuper() && t.push(e);
  },
  MemberExpression(e, {
    superProps: t
  }) {
    e.get("object").isSuper() && t.push(e);
  },
  Identifier(e, {
    argumentsPaths: t
  }) {
    if (!e.isReferencedIdentifier({
      name: "arguments"
    }))
      return;
    let s = e.scope;
    do {
      if (s.hasOwnBinding("arguments")) {
        s.rename("arguments");
        return;
      }
      if (s.path.isFunction() && !s.path.isArrowFunctionExpression())
        break;
    } while (s = s.parent);
    t.push(e);
  },
  MetaProperty(e, {
    newTargetPaths: t
  }) {
    e.get("meta").isIdentifier({
      name: "new"
    }) && e.get("property").isIdentifier({
      name: "target"
    }) && t.push(e);
  }
}, _helperEnvironmentVisitor.default]);
function getScopeInformation(e) {
  const t = [], s = [], i = [], a = [], o = [];
  return e.traverse(getScopeInformationVisitor, {
    thisPaths: t,
    argumentsPaths: s,
    newTargetPaths: i,
    superProps: a,
    superCalls: o
  }), {
    thisPaths: t,
    argumentsPaths: s,
    newTargetPaths: i,
    superProps: a,
    superCalls: o
  };
}
var introspection = {};
Object.defineProperty(introspection, "__esModule", {
  value: !0
});
introspection._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
introspection._resolve = _resolve;
introspection.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
introspection.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
introspection.equals = equals;
introspection.getSource = getSource;
introspection.has = has;
introspection.is = void 0;
introspection.isCompletionRecord = isCompletionRecord;
introspection.isConstantExpression = isConstantExpression;
introspection.isInStrictMode = isInStrictMode;
introspection.isNodeType = isNodeType;
introspection.isStatementOrBlock = isStatementOrBlock;
introspection.isStatic = isStatic;
introspection.isnt = isnt;
introspection.matchesPattern = matchesPattern;
introspection.referencesImport = referencesImport;
introspection.resolve = resolve;
introspection.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
var _t$2 = requireLib$1();
const {
  STATEMENT_OR_BLOCK_KEYS,
  VISITOR_KEYS,
  isBlockStatement,
  isExpression,
  isIdentifier,
  isLiteral,
  isStringLiteral,
  isType,
  matchesPattern: _matchesPattern
} = _t$2;
function matchesPattern(e, t) {
  return _matchesPattern(this.node, e, t);
}
function has(e) {
  const t = this.node && this.node[e];
  return t && Array.isArray(t) ? !!t.length : !!t;
}
function isStatic() {
  return this.scope.isStatic(this.node);
}
introspection.is = has;
function isnt(e) {
  return !this.has(e);
}
function equals(e, t) {
  return this.node[e] === t;
}
function isNodeType(e) {
  return isType(this.type, e);
}
function canHaveVariableDeclarationOrExpression() {
  return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
}
function canSwapBetweenExpressionAndStatement(e) {
  return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? isBlockStatement(e) : this.isBlockStatement() ? isExpression(e) : !1;
}
function isCompletionRecord(e) {
  let t = this, s = !0;
  do {
    const {
      type: i,
      container: a
    } = t;
    if (!s && (t.isFunction() || i === "StaticBlock"))
      return !!e;
    if (s = !1, Array.isArray(a) && t.key !== a.length - 1)
      return !1;
  } while ((t = t.parentPath) && !t.isProgram() && !t.isDoExpression());
  return !0;
}
function isStatementOrBlock() {
  return this.parentPath.isLabeledStatement() || isBlockStatement(this.container) ? !1 : STATEMENT_OR_BLOCK_KEYS.includes(this.key);
}
function referencesImport(e, t) {
  if (!this.isReferencedIdentifier()) {
    if (this.isJSXMemberExpression() && this.node.property.name === t || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {
      value: t
    }) : this.node.property.name === t)) {
      const o = this.get("object");
      return o.isReferencedIdentifier() && o.referencesImport(e, "*");
    }
    return !1;
  }
  const s = this.scope.getBinding(this.node.name);
  if (!s || s.kind !== "module")
    return !1;
  const i = s.path, a = i.parentPath;
  if (!a.isImportDeclaration())
    return !1;
  if (a.node.source.value === e) {
    if (!t)
      return !0;
  } else
    return !1;
  return !!(i.isImportDefaultSpecifier() && t === "default" || i.isImportNamespaceSpecifier() && t === "*" || i.isImportSpecifier() && isIdentifier(i.node.imported, {
    name: t
  }));
}
function getSource() {
  const e = this.node;
  if (e.end) {
    const t = this.hub.getCode();
    if (t)
      return t.slice(e.start, e.end);
  }
  return "";
}
function willIMaybeExecuteBefore(e) {
  return this._guessExecutionStatusRelativeTo(e) !== "after";
}
function getOuterFunction(e) {
  return e.isProgram() ? e : (e.parentPath.scope.getFunctionParent() || e.parentPath.scope.getProgramParent()).path;
}
function isExecutionUncertain(e, t) {
  switch (e) {
    case "LogicalExpression":
      return t === "right";
    case "ConditionalExpression":
    case "IfStatement":
      return t === "consequent" || t === "alternate";
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForInStatement":
    case "ForOfStatement":
      return t === "body";
    case "ForStatement":
      return t === "body" || t === "update";
    case "SwitchStatement":
      return t === "cases";
    case "TryStatement":
      return t === "handler";
    case "AssignmentPattern":
      return t === "right";
    case "OptionalMemberExpression":
      return t === "property";
    case "OptionalCallExpression":
      return t === "arguments";
    default:
      return !1;
  }
}
function isExecutionUncertainInList(e, t) {
  for (let s = 0; s < t; s++) {
    const i = e[s];
    if (isExecutionUncertain(i.parent.type, i.parentKey))
      return !0;
  }
  return !1;
}
const SYMBOL_CHECKING = Symbol();
function _guessExecutionStatusRelativeTo(e) {
  return _guessExecutionStatusRelativeToCached(this, e, /* @__PURE__ */ new Map());
}
function _guessExecutionStatusRelativeToCached(e, t, s) {
  const i = {
    this: getOuterFunction(e),
    target: getOuterFunction(t)
  };
  if (i.target.node !== i.this.node)
    return _guessExecutionStatusRelativeToDifferentFunctionsCached(e, i.target, s);
  const a = {
    target: t.getAncestry(),
    this: e.getAncestry()
  };
  if (a.target.indexOf(e) >= 0)
    return "after";
  if (a.this.indexOf(t) >= 0)
    return "before";
  let o;
  const l = {
    target: 0,
    this: 0
  };
  for (; !o && l.this < a.this.length; ) {
    const T = a.this[l.this];
    l.target = a.target.indexOf(T), l.target >= 0 ? o = T : l.this++;
  }
  if (!o)
    throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
  if (isExecutionUncertainInList(a.this, l.this - 1) || isExecutionUncertainInList(a.target, l.target - 1))
    return "unknown";
  const f = {
    this: a.this[l.this - 1],
    target: a.target[l.target - 1]
  };
  if (f.target.listKey && f.this.listKey && f.target.container === f.this.container)
    return f.target.key > f.this.key ? "before" : "after";
  const y = VISITOR_KEYS[o.type], g = {
    this: y.indexOf(f.this.parentKey),
    target: y.indexOf(f.target.parentKey)
  };
  return g.target > g.this ? "before" : "after";
}
function _guessExecutionStatusRelativeToDifferentFunctionsInternal(e, t, s) {
  if (t.isFunctionDeclaration()) {
    if (t.parentPath.isExportDeclaration())
      return "unknown";
  } else
    return _guessExecutionStatusRelativeToCached(e, t, s) === "before" ? "before" : "unknown";
  const i = t.scope.getBinding(t.node.id.name);
  if (!i.references)
    return "before";
  const a = i.referencePaths;
  let o;
  for (const l of a) {
    if (!!l.find((g) => g.node === t.node))
      continue;
    if (l.key !== "callee" || !l.parentPath.isCallExpression())
      return "unknown";
    const y = _guessExecutionStatusRelativeToCached(e, l, s);
    if (o && o !== y)
      return "unknown";
    o = y;
  }
  return o;
}
function _guessExecutionStatusRelativeToDifferentFunctionsCached(e, t, s) {
  let i = s.get(e.node), a;
  if (!i)
    s.set(e.node, i = /* @__PURE__ */ new Map());
  else if (a = i.get(t.node))
    return a === SYMBOL_CHECKING ? "unknown" : a;
  i.set(t.node, SYMBOL_CHECKING);
  const o = _guessExecutionStatusRelativeToDifferentFunctionsInternal(e, t, s);
  return i.set(t.node, o), o;
}
function resolve(e, t) {
  return this._resolve(e, t) || this;
}
function _resolve(e, t) {
  if (!(t && t.indexOf(this) >= 0))
    if (t = t || [], t.push(this), this.isVariableDeclarator()) {
      if (this.get("id").isIdentifier())
        return this.get("init").resolve(e, t);
    } else if (this.isReferencedIdentifier()) {
      const s = this.scope.getBinding(this.node.name);
      if (!s || !s.constant || s.kind === "module")
        return;
      if (s.path !== this) {
        const i = s.path.resolve(e, t);
        return this.find((a) => a.node === i.node) ? void 0 : i;
      }
    } else {
      if (this.isTypeCastExpression())
        return this.get("expression").resolve(e, t);
      if (e && this.isMemberExpression()) {
        const s = this.toComputedKey();
        if (!isLiteral(s))
          return;
        const i = s.value, a = this.get("object").resolve(e, t);
        if (a.isObjectExpression()) {
          const o = a.get("properties");
          for (const l of o) {
            if (!l.isProperty())
              continue;
            const f = l.get("key");
            let y = l.isnt("computed") && f.isIdentifier({
              name: i
            });
            if (y = y || f.isLiteral({
              value: i
            }), y)
              return l.get("value").resolve(e, t);
          }
        } else if (a.isArrayExpression() && !isNaN(+i)) {
          const l = a.get("elements")[i];
          if (l)
            return l.resolve(e, t);
        }
      }
    }
}
function isConstantExpression() {
  if (this.isIdentifier()) {
    const e = this.scope.getBinding(this.node.name);
    return e ? e.constant : !1;
  }
  if (this.isLiteral())
    return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every((e) => e.isConstantExpression()) : !0;
  if (this.isUnaryExpression())
    return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
  if (this.isBinaryExpression()) {
    const {
      operator: e
    } = this.node;
    return e !== "in" && e !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
  }
  return !1;
}
function isInStrictMode() {
  return !!(this.isProgram() ? this : this.parentPath).find((s) => {
    if (s.isProgram({
      sourceType: "module"
    }) || s.isClass())
      return !0;
    if (s.isArrowFunctionExpression() && !s.get("body").isBlockStatement())
      return !1;
    let i;
    if (s.isFunction())
      i = s.node.body;
    else if (s.isProgram())
      i = s.node;
    else
      return !1;
    for (const a of i.directives)
      if (a.value.value === "use strict")
        return !0;
  });
}
var context = {}, hasRequiredContext$1;
function requireContext$1() {
  if (hasRequiredContext$1)
    return context;
  hasRequiredContext$1 = 1, Object.defineProperty(context, "__esModule", {
    value: !0
  }), context._call = i, context._getQueueContexts = q, context._resyncKey = $, context._resyncList = U, context._resyncParent = v, context._resyncRemoved = X, context.call = s, context.isBlacklisted = context.isDenylisted = a, context.popContext = k, context.pushContext = D, context.requeue = H, context.resync = b, context.setContext = S, context.setKey = Z, context.setScope = T, context.setup = B, context.skip = f, context.skipKey = y, context.stop = g, context.visit = l;
  var e = requireTraverseNode(), t = requirePath();
  function s(_) {
    const j = this.opts;
    if (this.debug(_), this.node && this._call(j[_]))
      return !0;
    if (this.node) {
      var V;
      return this._call((V = j[this.node.type]) == null ? void 0 : V[_]);
    }
    return !1;
  }
  function i(_) {
    if (!_)
      return !1;
    for (const j of _) {
      if (!j)
        continue;
      const V = this.node;
      if (!V)
        return !0;
      const ue = j.call(this.state, this, this.state);
      if (ue && typeof ue == "object" && typeof ue.then == "function")
        throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (ue)
        throw new Error(`Unexpected return value from visitor method ${j}`);
      if (this.node !== V || this._traverseFlags > 0)
        return !0;
    }
    return !1;
  }
  function a() {
    var _;
    const j = (_ = this.opts.denylist) != null ? _ : this.opts.blacklist;
    return j && j.indexOf(this.node.type) > -1;
  }
  function o(_, j) {
    _.context !== j && (_.context = j, _.state = j.state, _.opts = j.opts);
  }
  function l() {
    var _, j;
    if (!this.node || this.isDenylisted() || (_ = (j = this.opts).shouldSkip) != null && _.call(j, this))
      return !1;
    const V = this.context;
    return this.shouldSkip || this.call("enter") ? (this.debug("Skip..."), this.shouldStop) : (o(this, V), this.debug("Recursing into..."), this.shouldStop = (0, e.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), o(this, V), this.call("exit"), this.shouldStop);
  }
  function f() {
    this.shouldSkip = !0;
  }
  function y(_) {
    this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[_] = !0;
  }
  function g() {
    this._traverseFlags |= t.SHOULD_SKIP | t.SHOULD_STOP;
  }
  function T() {
    var _, j;
    if ((_ = this.opts) != null && _.noScope)
      return;
    let V = this.parentPath;
    ((this.key === "key" || this.listKey === "decorators") && V.isMethod() || this.key === "discriminant" && V.isSwitchStatement()) && (V = V.parentPath);
    let ue;
    for (; V && !ue; ) {
      var ee;
      if ((ee = V.opts) != null && ee.noScope)
        return;
      ue = V.scope, V = V.parentPath;
    }
    this.scope = this.getScope(ue), (j = this.scope) == null || j.init();
  }
  function S(_) {
    return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, _ && (this.context = _, this.state = _.state, this.opts = _.opts), this.setScope(), this;
  }
  function b() {
    this.removed || (this._resyncParent(), this._resyncList(), this._resyncKey());
  }
  function v() {
    this.parentPath && (this.parent = this.parentPath.node);
  }
  function $() {
    if (this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let _ = 0; _ < this.container.length; _++)
          if (this.container[_] === this.node) {
            this.setKey(_);
            return;
          }
      } else
        for (const _ of Object.keys(this.container))
          if (this.container[_] === this.node) {
            this.setKey(_);
            return;
          }
      this.key = null;
    }
  }
  function U() {
    if (!this.parent || !this.inList)
      return;
    const _ = this.parent[this.listKey];
    this.container !== _ && (this.container = _ || null);
  }
  function X() {
    (this.key == null || !this.container || this.container[this.key] !== this.node) && this._markRemoved();
  }
  function k() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }
  function D(_) {
    this.contexts.push(_), this.setContext(_);
  }
  function B(_, j, V, ue) {
    this.listKey = V, this.container = j, this.parentPath = _ || this.parentPath, this.setKey(ue);
  }
  function Z(_) {
    var j;
    this.key = _, this.node = this.container[this.key], this.type = (j = this.node) == null ? void 0 : j.type;
  }
  function H(_ = this) {
    if (_.removed)
      return;
    const j = this.contexts;
    for (const V of j)
      V.maybeQueue(_);
  }
  function q() {
    let _ = this, j = this.contexts;
    for (; !j.length && (_ = _.parentPath, !!_); )
      j = _.contexts;
    return j;
  }
  return context;
}
var removal = {}, removalHooks = {};
Object.defineProperty(removalHooks, "__esModule", {
  value: !0
});
removalHooks.hooks = void 0;
removalHooks.hooks = [function(e, t) {
  if (e.key === "test" && (t.isWhile() || t.isSwitchCase()) || e.key === "declaration" && t.isExportDeclaration() || e.key === "body" && t.isLabeledStatement() || e.listKey === "declarations" && t.isVariableDeclaration() && t.node.declarations.length === 1 || e.key === "expression" && t.isExpressionStatement())
    return t.remove(), !0;
}, function(e, t) {
  if (t.isSequenceExpression() && t.node.expressions.length === 1)
    return t.replaceWith(t.node.expressions[0]), !0;
}, function(e, t) {
  if (t.isBinary())
    return e.key === "left" ? t.replaceWith(t.node.right) : t.replaceWith(t.node.left), !0;
}, function(e, t) {
  if (t.isIfStatement() && e.key === "consequent" || e.key === "body" && (t.isLoop() || t.isArrowFunctionExpression()))
    return e.replaceWith({
      type: "BlockStatement",
      body: []
    }), !0;
}];
var hasRequiredRemoval;
function requireRemoval() {
  if (hasRequiredRemoval)
    return removal;
  hasRequiredRemoval = 1, Object.defineProperty(removal, "__esModule", {
    value: !0
  }), removal._assertUnremoved = T, removal._callRemovalHooks = f, removal._markRemoved = g, removal._remove = y, removal._removeFromScope = l, removal.remove = o;
  var e = removalHooks, t = cache, s = requirePath(), i = requireLib$1();
  const {
    getBindingIdentifiers: a
  } = i;
  function o() {
    var S;
    if (this._assertUnremoved(), this.resync(), (S = this.opts) != null && S.noScope || this._removeFromScope(), this._callRemovalHooks()) {
      this._markRemoved();
      return;
    }
    this.shareCommentsWithSiblings(), this._remove(), this._markRemoved();
  }
  function l() {
    const S = a(this.node, !1, !1, !0);
    Object.keys(S).forEach((b) => this.scope.removeBinding(b));
  }
  function f() {
    for (const S of e.hooks)
      if (S(this, this.parentPath))
        return !0;
  }
  function y() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
  }
  function g() {
    this._traverseFlags |= s.SHOULD_SKIP | s.REMOVED, this.parent && (0, t.getCachedPaths)(this.hub, this.parent).delete(this.node), this.node = null;
  }
  function T() {
    if (this.removed)
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
  return removal;
}
var modification = {}, hoister = {};
Object.defineProperty(hoister, "__esModule", {
  value: !0
});
hoister.default = void 0;
var _t$1 = requireLib$1(), _t2 = _t$1;
const {
  react
} = _t$1, {
  cloneNode,
  jsxExpressionContainer,
  variableDeclaration,
  variableDeclarator
} = _t2, referenceVisitor = {
  ReferencedIdentifier(e, t) {
    if (e.isJSXIdentifier() && react.isCompatTag(e.node.name) && !e.parentPath.isJSXMemberExpression())
      return;
    if (e.node.name === "this") {
      let i = e.scope;
      do
        if (i.path.isFunction() && !i.path.isArrowFunctionExpression())
          break;
      while (i = i.parent);
      i && t.breakOnScopePaths.push(i.path);
    }
    const s = e.scope.getBinding(e.node.name);
    if (s) {
      for (const i of s.constantViolations)
        if (i.scope !== s.path.scope) {
          t.mutableBinding = !0, e.stop();
          return;
        }
      s === t.scope.getBinding(e.node.name) && (t.bindings[e.node.name] = s);
    }
  }
};
class PathHoister {
  constructor(t, s) {
    this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [], this.scope = s, this.path = t, this.attachAfter = !1;
  }
  isCompatibleScope(t) {
    for (const s of Object.keys(this.bindings)) {
      const i = this.bindings[s];
      if (!t.bindingIdentifierEquals(s, i.identifier))
        return !1;
    }
    return !0;
  }
  getCompatibleScopes() {
    let t = this.path.scope;
    do {
      if (this.isCompatibleScope(t))
        this.scopes.push(t);
      else
        break;
      if (this.breakOnScopePaths.indexOf(t.path) >= 0)
        break;
    } while (t = t.parent);
  }
  getAttachmentPath() {
    let t = this._getAttachmentPath();
    if (!t)
      return;
    let s = t.scope;
    if (s.path === t && (s = t.scope.parent), s.path.isProgram() || s.path.isFunction())
      for (const i of Object.keys(this.bindings)) {
        if (!s.hasOwnBinding(i))
          continue;
        const a = this.bindings[i];
        if (a.kind === "param" || a.path.parentKey === "params")
          continue;
        if (this.getAttachmentParentForPath(a.path).key >= t.key) {
          this.attachAfter = !0, t = a.path;
          for (const l of a.constantViolations)
            this.getAttachmentParentForPath(l).key > t.key && (t = l);
        }
      }
    return t;
  }
  _getAttachmentPath() {
    const s = this.scopes.pop();
    if (s) {
      if (s.path.isFunction())
        if (this.hasOwnParamBindings(s)) {
          if (this.scope === s)
            return;
          const i = s.path.get("body").get("body");
          for (let a = 0; a < i.length; a++)
            if (!i[a].node._blockHoist)
              return i[a];
        } else
          return this.getNextScopeAttachmentParent();
      else if (s.path.isProgram())
        return this.getNextScopeAttachmentParent();
    }
  }
  getNextScopeAttachmentParent() {
    const t = this.scopes.pop();
    if (t)
      return this.getAttachmentParentForPath(t.path);
  }
  getAttachmentParentForPath(t) {
    do
      if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
        return t;
    while (t = t.parentPath);
  }
  hasOwnParamBindings(t) {
    for (const s of Object.keys(this.bindings)) {
      if (!t.hasOwnBinding(s))
        continue;
      const i = this.bindings[s];
      if (i.kind === "param" && i.constant)
        return !0;
    }
    return !1;
  }
  run() {
    if (this.path.traverse(referenceVisitor, this), this.mutableBinding)
      return;
    this.getCompatibleScopes();
    const t = this.getAttachmentPath();
    if (!t || t.getFunctionParent() === this.path.getFunctionParent())
      return;
    let s = t.scope.generateUidIdentifier("ref");
    const i = variableDeclarator(s, this.path.node), a = this.attachAfter ? "insertAfter" : "insertBefore", [o] = t[a]([t.isVariableDeclarator() ? i : variableDeclaration("var", [i])]), l = this.path.parentPath;
    return l.isJSXElement() && this.path.container === l.node.children && (s = jsxExpressionContainer(s)), this.path.replaceWith(cloneNode(s)), t.isVariableDeclarator() ? o.get("init") : o.get("declarations.0.init");
  }
}
hoister.default = PathHoister;
var hasRequiredModification;
function requireModification() {
  if (hasRequiredModification)
    return modification;
  hasRequiredModification = 1, Object.defineProperty(modification, "__esModule", {
    value: !0
  }), modification._containerInsert = Z, modification._containerInsertAfter = q, modification._containerInsertBefore = H, modification._verifyNodeList = se, modification.hoist = F, modification.insertAfter = ue, modification.insertBefore = B, modification.pushContainer = ve, modification.unshiftContainer = be, modification.updateSiblingKeys = ee;
  var e = cache, t = hoister, s = requirePath(), i = requireLib$1();
  const {
    arrowFunctionExpression: a,
    assertExpression: o,
    assignmentExpression: l,
    blockStatement: f,
    callExpression: y,
    cloneNode: g,
    expressionStatement: T,
    isAssignmentExpression: S,
    isCallExpression: b,
    isExportNamedDeclaration: v,
    isExpression: $,
    isIdentifier: U,
    isSequenceExpression: X,
    isSuper: k,
    thisExpression: D
  } = i;
  function B(R) {
    this._assertUnremoved();
    const K = this._verifyNodeList(R), {
      parentPath: z,
      parent: re
    } = this;
    if (z.isExpressionStatement() || z.isLabeledStatement() || v(re) || z.isExportDefaultDeclaration() && this.isDeclaration())
      return z.insertBefore(K);
    if (this.isNodeType("Expression") && !this.isJSXElement() || z.isForStatement() && this.key === "init")
      return this.node && K.push(this.node), this.replaceExpressionWithStatements(K);
    if (Array.isArray(this.container))
      return this._containerInsertBefore(K);
    if (this.isStatementOrBlock()) {
      const ie = this.node, fe = ie && (!this.isExpressionStatement() || ie.expression != null);
      return this.replaceWith(f(fe ? [ie] : [])), this.unshiftContainer("body", K);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
  function Z(R, K) {
    this.updateSiblingKeys(R, K.length);
    const z = [];
    this.container.splice(R, 0, ...K);
    for (let fe = 0; fe < K.length; fe++) {
      var re;
      const ce = R + fe, Pe = this.getSibling(ce);
      z.push(Pe), (re = this.context) != null && re.queue && Pe.pushContext(this.context);
    }
    const ie = this._getQueueContexts();
    for (const fe of z) {
      fe.setScope(), fe.debug("Inserted.");
      for (const ce of ie)
        ce.maybeQueue(fe, !0);
    }
    return z;
  }
  function H(R) {
    return this._containerInsert(this.key, R);
  }
  function q(R) {
    return this._containerInsert(this.key + 1, R);
  }
  const _ = (R) => R[R.length - 1];
  function j(R) {
    return X(R.parent) && (_(R.parent.expressions) !== R.node || j(R.parentPath));
  }
  function V(R, K) {
    if (!S(R) || !U(R.left))
      return !1;
    const z = K.getBlockParent();
    return z.hasOwnBinding(R.left.name) && z.getOwnBinding(R.left.name).constantViolations.length <= 1;
  }
  function ue(R) {
    if (this._assertUnremoved(), this.isSequenceExpression())
      return _(this.get("expressions")).insertAfter(R);
    const K = this._verifyNodeList(R), {
      parentPath: z,
      parent: re
    } = this;
    if (z.isExpressionStatement() || z.isLabeledStatement() || v(re) || z.isExportDefaultDeclaration() && this.isDeclaration())
      return z.insertAfter(K.map((ie) => $(ie) ? T(ie) : ie));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !z.isJSXElement() || z.isForStatement() && this.key === "init") {
      if (this.node) {
        const ie = this.node;
        let {
          scope: fe
        } = this;
        if (fe.path.isPattern())
          return o(ie), this.replaceWith(y(a([], ie), [])), this.get("callee.body").insertAfter(K), [this];
        if (j(this))
          K.unshift(ie);
        else if (b(ie) && k(ie.callee))
          K.unshift(ie), K.push(D());
        else if (V(ie, fe))
          K.unshift(ie), K.push(g(ie.left));
        else if (fe.isPure(ie, !0))
          K.push(ie);
        else {
          z.isMethod({
            computed: !0,
            key: ie
          }) && (fe = fe.parent);
          const ce = fe.generateDeclaredUidIdentifier();
          K.unshift(T(l("=", g(ce), ie))), K.push(T(g(ce)));
        }
      }
      return this.replaceExpressionWithStatements(K);
    } else {
      if (Array.isArray(this.container))
        return this._containerInsertAfter(K);
      if (this.isStatementOrBlock()) {
        const ie = this.node, fe = ie && (!this.isExpressionStatement() || ie.expression != null);
        return this.replaceWith(f(fe ? [ie] : [])), this.pushContainer("body", K);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  function ee(R, K) {
    if (!this.parent)
      return;
    const z = (0, e.getCachedPaths)(this.hub, this.parent) || [];
    for (const [, re] of z)
      typeof re.key == "number" && re.key >= R && (re.key += K);
  }
  function se(R) {
    if (!R)
      return [];
    Array.isArray(R) || (R = [R]);
    for (let K = 0; K < R.length; K++) {
      const z = R[K];
      let re;
      if (z ? typeof z != "object" ? re = "contains a non-object node" : z.type ? z instanceof s.default && (re = "has a NodePath when it expected a raw object") : re = "without a type" : re = "has falsy node", re) {
        const ie = Array.isArray(z) ? "array" : typeof z;
        throw new Error(`Node list ${re} with the index of ${K} and type of ${ie}`);
      }
    }
    return R;
  }
  function be(R, K) {
    return this._assertUnremoved(), K = this._verifyNodeList(K), s.default.get({
      parentPath: this,
      parent: this.node,
      container: this.node[R],
      listKey: R,
      key: 0
    }).setContext(this.context)._containerInsertBefore(K);
  }
  function ve(R, K) {
    this._assertUnremoved();
    const z = this._verifyNodeList(K), re = this.node[R];
    return s.default.get({
      parentPath: this,
      parent: this.node,
      container: re,
      listKey: R,
      key: re.length
    }).setContext(this.context).replaceWithMultiple(z);
  }
  function F(R = this.scope) {
    return new t.default(this, R).run();
  }
  return modification;
}
var family = {}, hasRequiredFamily;
function requireFamily() {
  if (hasRequiredFamily)
    return family;
  hasRequiredFamily = 1, Object.defineProperty(family, "__esModule", {
    value: !0
  }), family._getKey = V, family._getPattern = ue, family.get = j, family.getAllNextSiblings = q, family.getAllPrevSiblings = _, family.getBindingIdentifierPaths = be, family.getBindingIdentifiers = ee, family.getCompletionRecords = D, family.getNextSibling = H, family.getOpposite = S, family.getOuterBindingIdentifierPaths = ve, family.getOuterBindingIdentifiers = se, family.getPrevSibling = Z, family.getSibling = B;
  var e = requirePath(), t = requireLib$1();
  const {
    getBindingIdentifiers: s,
    getOuterBindingIdentifiers: i,
    isDeclaration: a,
    numericLiteral: o,
    unaryExpression: l
  } = t, f = 0, y = 1;
  function g(F) {
    return {
      type: f,
      path: F
    };
  }
  function T(F) {
    return {
      type: y,
      path: F
    };
  }
  function S() {
    return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
  }
  function b(F, R, K) {
    return F && R.push(...k(F, K)), R;
  }
  function v(F, R, K) {
    let z = [];
    for (let re = 0; re < F.length; re++) {
      const ie = F[re], fe = k(ie, K), ce = [], Pe = [];
      for (const Ce of fe)
        Ce.type === f && ce.push(Ce), Ce.type === y && Pe.push(Ce);
      ce.length && (z = ce), R.push(...Pe);
    }
    return R.push(...z), R;
  }
  function $(F) {
    F.forEach((R) => {
      R.type = y;
    });
  }
  function U(F, R) {
    F.forEach((K) => {
      K.path.isBreakStatement({
        label: null
      }) && (R ? K.path.replaceWith(l("void", o(0))) : K.path.remove());
    });
  }
  function X(F, R) {
    const K = [];
    if (R.canHaveBreak) {
      let z = [];
      for (let re = 0; re < F.length; re++) {
        const ie = F[re], fe = Object.assign({}, R, {
          inCaseClause: !1
        });
        ie.isBlockStatement() && (R.inCaseClause || R.shouldPopulateBreak) ? fe.shouldPopulateBreak = !0 : fe.shouldPopulateBreak = !1;
        const ce = k(ie, fe);
        if (ce.length > 0 && ce.every((Pe) => Pe.type === y)) {
          z.length > 0 && ce.every((Pe) => Pe.path.isBreakStatement({
            label: null
          })) ? ($(z), K.push(...z), z.some((Pe) => Pe.path.isDeclaration()) && (K.push(...ce), U(ce, !0)), U(ce, !1)) : (K.push(...ce), R.shouldPopulateBreak || U(ce, !0));
          break;
        }
        if (re === F.length - 1)
          K.push(...ce);
        else {
          z = [];
          for (let Pe = 0; Pe < ce.length; Pe++) {
            const Ce = ce[Pe];
            Ce.type === y && K.push(Ce), Ce.type === f && z.push(Ce);
          }
        }
      }
    } else if (F.length)
      for (let z = F.length - 1; z >= 0; z--) {
        const re = k(F[z], R);
        if (re.length > 1 || re.length === 1 && !re[0].path.isVariableDeclaration()) {
          K.push(...re);
          break;
        }
      }
    return K;
  }
  function k(F, R) {
    let K = [];
    if (F.isIfStatement())
      K = b(F.get("consequent"), K, R), K = b(F.get("alternate"), K, R);
    else {
      if (F.isDoExpression() || F.isFor() || F.isWhile() || F.isLabeledStatement())
        return b(F.get("body"), K, R);
      if (F.isProgram() || F.isBlockStatement())
        return X(F.get("body"), R);
      if (F.isFunction())
        return k(F.get("body"), R);
      if (F.isTryStatement())
        K = b(F.get("block"), K, R), K = b(F.get("handler"), K, R);
      else {
        if (F.isCatchClause())
          return b(F.get("body"), K, R);
        if (F.isSwitchStatement())
          return v(F.get("cases"), K, R);
        if (F.isSwitchCase())
          return X(F.get("consequent"), {
            canHaveBreak: !0,
            shouldPopulateBreak: !1,
            inCaseClause: !0
          });
        F.isBreakStatement() ? K.push(T(F)) : K.push(g(F));
      }
    }
    return K;
  }
  function D() {
    return k(this, {
      canHaveBreak: !1,
      shouldPopulateBreak: !1,
      inCaseClause: !1
    }).map((R) => R.path);
  }
  function B(F) {
    return e.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: F
    }).setContext(this.context);
  }
  function Z() {
    return this.getSibling(this.key - 1);
  }
  function H() {
    return this.getSibling(this.key + 1);
  }
  function q() {
    let F = this.key, R = this.getSibling(++F);
    const K = [];
    for (; R.node; )
      K.push(R), R = this.getSibling(++F);
    return K;
  }
  function _() {
    let F = this.key, R = this.getSibling(--F);
    const K = [];
    for (; R.node; )
      K.push(R), R = this.getSibling(--F);
    return K;
  }
  function j(F, R = !0) {
    R === !0 && (R = this.context);
    const K = F.split(".");
    return K.length === 1 ? this._getKey(F, R) : this._getPattern(K, R);
  }
  function V(F, R) {
    const K = this.node, z = K[F];
    return Array.isArray(z) ? z.map((re, ie) => e.default.get({
      listKey: F,
      parentPath: this,
      parent: K,
      container: z,
      key: ie
    }).setContext(R)) : e.default.get({
      parentPath: this,
      parent: K,
      container: K,
      key: F
    }).setContext(R);
  }
  function ue(F, R) {
    let K = this;
    for (const z of F)
      z === "." ? K = K.parentPath : Array.isArray(K) ? K = K[z] : K = K.get(z, R);
    return K;
  }
  function ee(F) {
    return s(this.node, F);
  }
  function se(F) {
    return i(this.node, F);
  }
  function be(F = !1, R = !1) {
    const z = [this], re = /* @__PURE__ */ Object.create(null);
    for (; z.length; ) {
      const ie = z.shift();
      if (!ie || !ie.node)
        continue;
      const fe = s.keys[ie.node.type];
      if (ie.isIdentifier()) {
        F ? (re[ie.node.name] = re[ie.node.name] || []).push(ie) : re[ie.node.name] = ie;
        continue;
      }
      if (ie.isExportDeclaration()) {
        const ce = ie.get("declaration");
        a(ce) && z.push(ce);
        continue;
      }
      if (R) {
        if (ie.isFunctionDeclaration()) {
          z.push(ie.get("id"));
          continue;
        }
        if (ie.isFunctionExpression())
          continue;
      }
      if (fe)
        for (let ce = 0; ce < fe.length; ce++) {
          const Pe = fe[ce], Ce = ie.get(Pe);
          Array.isArray(Ce) ? z.push(...Ce) : Ce.node && z.push(Ce);
        }
    }
    return re;
  }
  function ve(F = !1) {
    return this.getBindingIdentifierPaths(F, !0);
  }
  return family;
}
var comments = {};
Object.defineProperty(comments, "__esModule", {
  value: !0
});
comments.addComment = addComment;
comments.addComments = addComments;
comments.shareCommentsWithSiblings = shareCommentsWithSiblings;
var _t = requireLib$1();
const {
  addComment: _addComment,
  addComments: _addComments
} = _t;
function shareCommentsWithSiblings() {
  if (typeof this.key == "string")
    return;
  const e = this.node;
  if (!e)
    return;
  const t = e.trailingComments, s = e.leadingComments;
  if (!t && !s)
    return;
  const i = this.getSibling(this.key - 1), a = this.getSibling(this.key + 1), o = !!i.node, l = !!a.node;
  o && (s && i.addComments("trailing", removeIfExisting(s, i.node.trailingComments)), t && !l && i.addComments("trailing", t)), l && (t && a.addComments("leading", removeIfExisting(t, a.node.leadingComments)), s && !o && a.addComments("leading", s));
}
function removeIfExisting(e, t) {
  if (!(t != null && t.length))
    return e;
  const s = new Set(t);
  return e.filter((i) => !s.has(i));
}
function addComment(e, t, s) {
  _addComment(this.node, e, t, s);
}
function addComments(e, t) {
  _addComments(this.node, e, t);
}
var hasRequiredPath;
function requirePath() {
  if (hasRequiredPath)
    return path;
  hasRequiredPath = 1, Object.defineProperty(path, "__esModule", {
    value: !0
  }), path.default = path.SHOULD_STOP = path.SHOULD_SKIP = path.REMOVED = void 0;
  var e = virtualTypes$1, t = browserExports, s = requireLib(), i = requireScope(), a = requireLib$1(), o = a, l = cache, f = lib$6, y = ancestry, g = inference, T = requireReplacement(), S = evaluation, b = conversion, v = introspection, $ = requireContext$1(), U = requireRemoval(), X = requireModification(), k = requireFamily(), D = comments, B = virtualTypesValidator;
  const {
    validate: Z
  } = a, H = t("babel"), q = path.REMOVED = 1, _ = path.SHOULD_STOP = 2, j = path.SHOULD_SKIP = 4;
  class V {
    constructor(ee, se) {
      this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = se, this.hub = ee, this.data = null, this.context = null, this.scope = null;
    }
    static get({
      hub: ee,
      parentPath: se,
      parent: be,
      container: ve,
      listKey: F,
      key: R
    }) {
      if (!ee && se && (ee = se.hub), !be)
        throw new Error("To get a node path the parent needs to exist");
      const K = ve[R], z = l.getOrCreateCachedPaths(ee, be);
      let re = z.get(K);
      return re || (re = new V(ee, be), K && z.set(K, re)), re.setup(se, ve, F, R), re;
    }
    getScope(ee) {
      return this.isScope() ? new i.default(this) : ee;
    }
    setData(ee, se) {
      return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[ee] = se;
    }
    getData(ee, se) {
      this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
      let be = this.data[ee];
      return be === void 0 && se !== void 0 && (be = this.data[ee] = se), be;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(ee, se = SyntaxError) {
      return this.hub.buildError(this.node, ee, se);
    }
    traverse(ee, se) {
      (0, s.default)(this.node, ee, this.scope, se, this);
    }
    set(ee, se) {
      Z(this.node, ee, se), this.node[ee] = se;
    }
    getPathLocation() {
      const ee = [];
      let se = this;
      do {
        let be = se.key;
        se.inList && (be = `${se.listKey}[${be}]`), ee.unshift(be);
      } while (se = se.parentPath);
      return ee.join(".");
    }
    debug(ee) {
      H.enabled && H(`${this.getPathLocation()} ${this.type}: ${ee}`);
    }
    toString() {
      return (0, f.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(ee) {
      ee || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
    get shouldSkip() {
      return !!(this._traverseFlags & j);
    }
    set shouldSkip(ee) {
      ee ? this._traverseFlags |= j : this._traverseFlags &= ~j;
    }
    get shouldStop() {
      return !!(this._traverseFlags & _);
    }
    set shouldStop(ee) {
      ee ? this._traverseFlags |= _ : this._traverseFlags &= ~_;
    }
    get removed() {
      return !!(this._traverseFlags & q);
    }
    set removed(ee) {
      ee ? this._traverseFlags |= q : this._traverseFlags &= ~q;
    }
  }
  Object.assign(V.prototype, y, g, T, S, b, v, $, U, X, k, D), V.prototype._guessExecutionStatusRelativeToDifferentFunctions = v._guessExecutionStatusRelativeTo;
  for (const ue of o.TYPES) {
    const ee = `is${ue}`, se = o[ee];
    V.prototype[ee] = function(be) {
      return se(this.node, be);
    }, V.prototype[`assert${ue}`] = function(be) {
      if (!se(this.node, be))
        throw new TypeError(`Expected node path of type ${ue}`);
    };
  }
  Object.assign(V.prototype, B);
  for (const ue of Object.keys(e))
    ue[0] !== "_" && (o.TYPES.includes(ue) || o.TYPES.push(ue));
  return path.default = V, path;
}
var hasRequiredContext;
function requireContext() {
  if (hasRequiredContext)
    return context$1;
  hasRequiredContext = 1, Object.defineProperty(context$1, "__esModule", {
    value: !0
  }), context$1.default = void 0;
  var e = requirePath(), t = requireLib$1();
  const {
    VISITOR_KEYS: s
  } = t;
  class i {
    constructor(o, l, f, y) {
      this.queue = null, this.priorityQueue = null, this.parentPath = y, this.scope = o, this.state = f, this.opts = l;
    }
    shouldVisit(o) {
      const l = this.opts;
      if (l.enter || l.exit || l[o.type])
        return !0;
      const f = s[o.type];
      if (!(f != null && f.length))
        return !1;
      for (const y of f)
        if (o[y])
          return !0;
      return !1;
    }
    create(o, l, f, y) {
      return e.default.get({
        parentPath: this.parentPath,
        parent: o,
        container: l,
        key: f,
        listKey: y
      });
    }
    maybeQueue(o, l) {
      this.queue && (l ? this.queue.push(o) : this.priorityQueue.push(o));
    }
    visitMultiple(o, l, f) {
      if (o.length === 0)
        return !1;
      const y = [];
      for (let g = 0; g < o.length; g++) {
        const T = o[g];
        T && this.shouldVisit(T) && y.push(this.create(l, o, g, f));
      }
      return this.visitQueue(y);
    }
    visitSingle(o, l) {
      return this.shouldVisit(o[l]) ? this.visitQueue([this.create(o, o, l)]) : !1;
    }
    visitQueue(o) {
      this.queue = o, this.priorityQueue = [];
      const l = /* @__PURE__ */ new WeakSet();
      let f = !1;
      for (const y of o) {
        if (y.resync(), (y.contexts.length === 0 || y.contexts[y.contexts.length - 1] !== this) && y.pushContext(this), y.key === null)
          continue;
        const {
          node: g
        } = y;
        if (!l.has(g)) {
          if (g && l.add(g), y.visit()) {
            f = !0;
            break;
          }
          if (this.priorityQueue.length && (f = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = o, f))
            break;
        }
      }
      for (const y of o)
        y.popContext();
      return this.queue = null, f;
    }
    visit(o, l) {
      const f = o[l];
      return f ? Array.isArray(f) ? this.visitMultiple(f, o, l) : this.visitSingle(o, l) : !1;
    }
  }
  return context$1.default = i, context$1;
}
var hasRequiredTraverseNode;
function requireTraverseNode() {
  if (hasRequiredTraverseNode)
    return traverseNode;
  hasRequiredTraverseNode = 1, Object.defineProperty(traverseNode, "__esModule", {
    value: !0
  }), traverseNode.traverseNode = i;
  var e = requireContext(), t = requireLib$1();
  const {
    VISITOR_KEYS: s
  } = t;
  function i(a, o, l, f, y, g, T) {
    const S = s[a.type];
    if (!S)
      return !1;
    const b = new e.default(l, o, f, y);
    if (T)
      return g != null && g[y.parentKey] ? !1 : b.visitQueue([y]);
    for (const v of S)
      if (!(g != null && g[v]) && b.visit(a, v))
        return !0;
    return !1;
  }
  return traverseNode;
}
var hub = {};
Object.defineProperty(hub, "__esModule", {
  value: !0
});
hub.default = void 0;
class Hub {
  getCode() {
  }
  getScope() {
  }
  addHelper() {
    throw new Error("Helpers are not supported by the default hub.");
  }
  buildError(t, s, i = TypeError) {
    return new i(s);
  }
}
hub.default = Hub;
var hasRequiredLib;
function requireLib() {
  return hasRequiredLib || (hasRequiredLib = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "Hub", {
      enumerable: !0,
      get: function() {
        return f.default;
      }
    }), Object.defineProperty(e, "NodePath", {
      enumerable: !0,
      get: function() {
        return o.default;
      }
    }), Object.defineProperty(e, "Scope", {
      enumerable: !0,
      get: function() {
        return l.default;
      }
    }), e.visitors = e.default = void 0;
    var t = visitors;
    e.visitors = t;
    var s = requireLib$1(), i = cache, a = requireTraverseNode(), o = requirePath(), l = requireScope(), f = hub;
    const {
      VISITOR_KEYS: y,
      removeProperties: g,
      traverseFast: T
    } = s;
    function S(v, $ = {}, U, X, k, D) {
      if (v) {
        if (!$.noScope && !U && v.type !== "Program" && v.type !== "File")
          throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${v.type} node without passing scope and parentPath.`);
        if (!k && D)
          throw new Error("visitSelf can only be used when providing a NodePath.");
        y[v.type] && (t.explode($), (0, a.traverseNode)(v, $, U, X, k, null, D));
      }
    }
    e.default = S, S.visitors = t, S.verify = t.verify, S.explode = t.explode, S.cheap = function(v, $) {
      T(v, $);
    }, S.node = function(v, $, U, X, k, D) {
      (0, a.traverseNode)(v, $, U, X, k, D);
    }, S.clearNode = function(v, $) {
      g(v, $);
    }, S.removeProperties = function(v, $) {
      return T(v, S.clearNode, $), v;
    };
    function b(v, $) {
      v.node.type === $.type && ($.has = !0, v.stop());
    }
    S.hasType = function(v, $, U) {
      if (U != null && U.includes(v.type))
        return !1;
      if (v.type === $)
        return !0;
      const X = {
        has: !1,
        type: $
      };
      return S(v, {
        noScope: !0,
        denylist: U,
        enter: b
      }, null, X), X.has;
    }, S.cache = i;
  }(lib$c)), lib$c;
}
var libExports = requireLib();
const traverse = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
let u;
function h(e) {
  return u ? !1 : (u = e, !0);
}
const d = {};
let m = 0;
const p = 0;
function I(e) {
  const t = { ...e };
  if (t.id && d[t.id])
    return d[t.id].info;
  t.plugins = t.plugins ? [...t.plugins] : [];
  const s = t.id || ++m, { value: i, dom: a, ...o } = t, l = u.editor.create(t.dom, {
    theme: "vs-dark",
    tabSize: 4,
    detectIndentation: !1,
    scrollbar: { alwaysConsumeMouseWheel: !1 },
    definitionLinkOpensInPeek: !0,
    ...o
  }), f = M({
    ...t,
    uri: u.Uri.file(`/root${s}/Untitled-${p}`),
    getPlugins: () => t.plugins
  });
  l.setModel(f);
  const y = {
    editor: l,
    getValue: () => {
      var g;
      return ((g = l.getModel()) == null ? void 0 : g.getValue()) || "";
    },
    validate: () => {
      const g = l.getModel();
      if (g) {
        const T = t.plugins.find((S) => S.isMatch(g.getLanguageId()));
        if (T)
          return T.validate(g);
      }
      return Promise.resolve(!0);
    },
    getAst() {
      var g;
      const T = l.getModel();
      return T && ((g = t.plugins.find((S) => S.isMatch(T.getLanguageId()))) == null ? void 0 : g.getAst(T.uri.toString()));
    },
    addPlugin(g) {
      t.plugins.push(g), u.editor.getModels().forEach((T) => {
        g.isMatch(T.getLanguageId()) && g.parse({ text: f.getValue(), uri: f.uri, language: T.getLanguageId() });
      });
    },
    // @ts-ignore
    getPlugins(g) {
      return typeof g == "string" ? t.plugins.find((T) => T.name === g) : [...t.plugins];
    },
    removePlugin(g) {
      const T = t.plugins.findIndex((S) => S.name === g);
      T !== -1 && (t.plugins[T].destroy(), t.plugins.splice(T, -1));
    },
    clearPlugin() {
      t.plugins.forEach((g) => g.destroy()), t.plugins = [];
    }
  };
  return d[s] = { option: t, info: y, listeners: [], untitledI: p }, y;
}
function M({
  value: e,
  language: t,
  uri: s,
  getPlugins: i
}) {
  if (typeof e == "object")
    return e;
  const a = typeof s == "string" ? u.Uri.parse(s) : s;
  let o = u.editor.getModel(a);
  if (!o) {
    o = u.editor.createModel(e || "", t, a);
    const l = () => {
      var f;
      (f = i().find((y) => y.isMatch(t))) == null || f.parse({ text: o.getValue(), uri: o.uri, language: t });
    };
    l(), o.onDidChangeContent(l);
  }
  return o;
}
function x(e) {
  var t;
  (t = e.getAction("editor.action.formatDocument")) == null || t.run();
}
function P(e, t) {
  e.pushEditOperations([], [{ range: e.getFullModelRange(), text: t || "" }], (s) => null);
}
const r = "modelValue", c = "update:modelValue", L = /* @__PURE__ */ defineComponent$3({
  name: "VueMonacoEditor",
  components: {},
  props: {
    /** 编辑器的值 - 优先取该字段 */
    [r]: {
      type: [String, Object]
    },
    /** 编辑器的值 */
    value: {
      type: [String, Object]
    },
    language: {
      type: String,
      required: !0
    },
    editorOption: {
      type: Object
    }
  },
  emits: {
    [c]: (e) => !0,
    input: (e) => !0
  },
  setup(e, t) {
    h(O);
    const s = computed(() => e[r] !== void 0 ? r : "value"), i = s.value === r ? c : "input", {
      editorOption: a,
      [s.value]: o,
      ...l
    } = e, f = ref$3(), y = ref$3(markRaw$1(document.createElement("div")));
    Object.assign(y.value.style, {
      width: "100%",
      height: "100%"
    });
    const g = ref$3(markRaw$1(I({
      automaticLayout: !0,
      suggest: {
        filterGraceful: !0,
        preview: !0,
        showColors: !0,
        showConstants: !0,
        showConstructors: !0,
        showDeprecated: !0,
        showEnumMembers: !0,
        showEnums: !0,
        showEvents: !0,
        showFields: !0,
        showFiles: !0,
        showFolders: !0,
        showFunctions: !0,
        showIcons: !0,
        showInterfaces: !0,
        showIssues: !0,
        showKeywords: !0,
        showMethods: !0,
        showModules: !0,
        showOperators: !0,
        showReferences: !0,
        showSnippets: !0,
        showStatusBar: !0,
        showStructs: !0,
        showTypeParameters: !0,
        showUnits: !0,
        showUsers: !0,
        showValues: !0,
        showVariables: !0,
        showWords: !0
      },
      dom: y.value,
      value: o,
      ...l,
      ...a
    })));
    onMounted$2(() => {
      f.value && f.value.appendChild(y.value);
    }), T();
    function T() {
      x(g.value.editor);
      const b = g.value.editor.getModel();
      b && b.onDidChangeContent(() => t.emit(i, b.getValue()));
    }
    e[s.value] && S(e[s.value]);
    function S(b) {
      if (typeof b == "object")
        return g.value.editor.setModel(b);
      const v = g.value.editor.getModel();
      v && P(v, b || "");
    }
    return watch(() => e[s.value], S), {
      domRef: f,
      editorInfo: g
    };
  },
  render() {
    return h$1("div", {
      ref: "domRef"
    });
  }
});
function getType(e) {
  return Object.prototype.toString.call(e).slice(8, -1);
}
function isArray(e) {
  return getType(e) === "Array";
}
function isPlainObject(e) {
  return getType(e) === "Object";
}
function toAst(e, t) {
  if (e)
    try {
      return parse_1(e, {
        sourceType: "module",
        errorRecovery: !0,
        allowImportExportEverywhere: !0,
        createImportExpressions: !0,
        plugins: ["typescript"],
        ...t
      });
    } catch {
    }
}
function getModulesFromAst(e) {
  return getNodeOfTypes(e, ["ImportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]).map((s) => s == null ? void 0 : s.source).filter(Boolean);
}
function getNodeOfTypes(e, t) {
  const s = [];
  return traverseAllFields(e, (i) => {
    t.includes(i == null ? void 0 : i.type) && s.push(i);
  }), s;
}
function traverseAllFields(e, t) {
  Object.keys(e).forEach((s) => {
    t(e[s]), (isArray(e[s]) || isPlainObject(e[s])) && traverseAllFields(e[s], t);
  });
}
function getModuleName(e) {
  return e.split("/").slice(0, e.charAt(0) === "@" ? 2 : 1).join("/");
}
function isModulePath(e) {
  const t = e.charAt(0);
  return !["/", "\\", "."].some((s) => s === t);
}
function resolvePath(e, t) {
  const s = e.split("/");
  if (s.unshift(e[0] === "@" ? s.splice(0, 2).join("/") : s.splice(0, 1)[0]), t.charAt(0) === "/")
    return `${s[0]}${t}`;
  const i = t.split("/");
  s.pop();
  for (var a = 0; a < i.length; a++)
    i[a] != "." && (i[a] == ".." ? s.pop() : s.push(i[a]));
  return s.join("/");
}
var Language = /* @__PURE__ */ ((e) => (e.javascript = "javascript", e.typescript = "typescript", e))(Language || {});
const fileInfoMap = {}, modMap = {}, NODE_MODULES_FOLDER = "file:///node_modules/";
async function loadDts({ text: e, uri: t, isLib: s, loadMod: i, language: a, declarationModel: o, astOption: l }) {
  if (!e)
    return;
  s && addLib(e, t.slice(-5) === "index" ? `${t}.d.ts` : `${t}.d.ts`, a), s && o && editor.createModel(e, a, Uri.parse(`${t}.d.ts`));
  const f = toAst(e, l);
  if (!f)
    return;
  const y = fileInfoMap[t] = {
    ast: f,
    importModules: getModulesFromAst(f),
    filepaths: []
  };
  if (i)
    try {
      await Promise.all(
        y.importModules.map((g) => {
          const T = isModulePath(g.value) ? `${NODE_MODULES_FOLDER}${g.value}` : resolvePath(t, g.value);
          let S = g.value === getModuleName(g.value) ? `${T}/index` : T;
          if (y.filepaths.push(S), !(modMap[S] === "loading" || modMap[S] === "success"))
            return modMap[S] = "loading", new Promise(
              (b) => b(
                i(
                  g.value,
                  T.slice(NODE_MODULES_FOLDER.length),
                  (v) => typeof v == "string" ? S = v : v && S.charAt(S.length - 1) !== "/" && (S += "/index")
                )
              )
            ).then((b) => {
              modMap[S] = "success", loadDts({
                text: b,
                uri: S,
                isLib: !0,
                loadMod: i,
                language: a,
                declarationModel: o,
                astOption: l
              });
            }).catch((b) => {
              throw modMap[S] = "error", b;
            });
        })
      );
    } catch (g) {
      throw g;
    }
}
function addLib(e, t, s) {
  languages.typescript[`${s}Defaults`].addExtraLib(
    e,
    Uri.isUri(t) ? decodeURIComponent(t.toString()) : t
  );
}
let _tsInstance = {};
async function getSyntaxWorker(e, t) {
  const s = `${e.toString()}${t || ""}`;
  return _tsInstance[s] || (_tsInstance[s] = getSyntaxWorkerFunc(
    t === "typescript" ? "getTypeScriptWorker" : "getJavaScriptWorker"
  ).then((i) => i(e)).catch((i) => {
    throw delete _tsInstance[s], i;
  })), _tsInstance[s];
}
const _tsWorker = {};
async function getSyntaxWorkerFunc(e) {
  return _tsWorker[e] || (_tsWorker[e] = languages.typescript[e]().catch((t) => {
    throw delete _tsWorker[e], t;
  })), _tsWorker[e];
}
function typescript(e) {
  return {
    name: "typescript",
    isMatch(t) {
      return !!Language[t];
    },
    parse({ text: t, language: s, uri: i }) {
      Language[s] && loadDts({
        text: t,
        language: s,
        uri: i.toString(),
        loadMod: e == null ? void 0 : e.loadMod,
        declarationModel: e == null ? void 0 : e.declarationModel,
        astOption: e == null ? void 0 : e.astOption
      });
    },
    getAst(t) {
      var s;
      return (s = fileInfoMap[t]) == null ? void 0 : s.ast;
    },
    async validate(t) {
      const s = await getSyntaxWorker(t.uri, t.getLanguageId()), i = await Promise.all([
        s.getSyntacticDiagnostics(t.uri.toString()),
        s.getSemanticDiagnostics(t.uri.toString())
      ]);
      return i.some((a) => a.length) ? Promise.reject(i) : Promise.resolve(!0);
    },
    destroy() {
    }
  };
}
const { defineComponent: defineComponent$2, nextTick: nextTick$1, onMounted: onMounted$1, ref: ref$2, set: set$1, version: version$2 } = window.Vue, { HWrapper: HWrapper$1 } = window.HCondition, { toast } = window.Ui, unspecialKeyReg = /^[a-z_][a-z_0-9]*$/i, isAttrFunctionReg = /^(function\s|((\(.*\)|[_a-z0-9]+)\s?=>))/i;
function toStr(e, t = 1) {
  const s = "".padStart(t * 4, " "), i = "".padStart((t - 1) * 4, " ");
  switch (Object.prototype.toString.call(e).slice(8, -1)) {
    case "Object": {
      let a = "{", o, l;
      return Object.keys(e).forEach((f) => {
        o = toStr(e[f], t + 1), l = unspecialKeyReg.test(f) ? f : `'${f}'`, a += `
${s}${typeof e[f] == "function" && !(o.slice(0, 9) === "function " || isAttrFunctionReg.test(o)) ? "" : `${l}: `}${o},`;
      }), a += a.length === 1 ? "}" : `
${i}}`, a;
    }
    case "Array": {
      let a = "[";
      return e.forEach((o) => {
        a += `
${s}${toStr(o, t + 1)},`;
      }), a += a.length === 1 ? "]" : `
${i}]`, a;
    }
    case "Function":
      return e.toString();
    case "String":
      return `'${e}'`;
    case "Number":
      return e.toString();
    default:
      return e == null ? void 0 : e.toString();
  }
}
self.MonacoEnvironment = {
  getWorker(e, t) {
    return t === "typescript" || t === "javascript" ? new tsWorker() : new editorWorker();
  }
};
let flag = !1;
function initLanguages() {
  flag || (flag = !0, languages.typescript.typescriptDefaults.setCompilerOptions({
    allowNonTsExtensions: !0,
    moduleResolution: languages.typescript.ModuleResolutionKind.NodeJs,
    module: languages.typescript.ModuleKind.CommonJS,
    noEmit: !0
    // isolatedModules: true,
    // moduleDetection: 'force',
    // jsx: languages.typescript.JsxEmit.React,
    // jsxFactory: 'JSXAlone.createElement',
  }));
}
const _sfc_main$2 = defineComponent$2({
  template: `
        <ElCard class="box">
            <div>
                <ElAlert type="success" :closable="false">
                    <span>当前条件:　</span>
                    <span>{{ conditions.query }}</span>
                </ElAlert>
                <div style="margin: 10px 0; display: flex; flex-flow: row wrap">
                    <ElButton @click="clear" type="danger" size="small">清空所有条件并重置</ElButton>
                    <ElButton
                        v-if="!!conditions.setQuery"
                        @click="conditions.setQuery(conditions)"
                        type="primary"
                        size="small"
                    >
                        手动设置query
                    </ElButton>
                    <ElButton style="margin-left: auto" @click="setValue" size="small" type="success">
                        同步编辑器中的条件
                    </ElButton>
                </div>
                <HWrapper
                    :backfill="conditions.query"
                    :datum="conditions.condition"
                    v-bind="conditions.wrapperOption"
                    :key="conditions.wrapperOption.key"
                    @ready="querySearch($event, 'ready')"
                    @search="querySearch($event, 'search')"
                ></HWrapper>
                <!-- @reset="reset($event)" -->
            </div>
            <VueMonacoEditor
                class="vue-monaco-editor"
                ref="editorRef"
                :value="parseToEditorValue(conditions)"
                language="typescript"
            ></VueMonacoEditor>
        </ElCard>
    `,
  components: {
    HWrapper: HWrapper$1,
    VueMonacoEditor: L
  },
  setup() {
    onMounted$1(initLanguages);
    const conditions = ref$2(conditionFactory());
    function querySearch(e, t) {
      conditions.value.query = e, console.log(`${t}-搜索事件: `, { ...e }, `
句柄: `, conditions.value);
    }
    function reset(e) {
      conditions.value.query.a = "", nextTick$1(() => {
        conditions.value.query.a = "999", console.log("reset", "a 重置后设置为`999`了", conditions.value.query);
      });
    }
    function parseToEditorValue({ wrapperOption: e, condition: t, query: s }) {
      return [
        "",
        `import { defineCondition, HCondition } from '${version$2.charAt(0) === "3" ? "@xiaohaih/condition-plus" : "@xiaohaih/condition-el"}';`,
        "// 条件容器的配置项",
        "const wrapper: HCondition.WrapperProps & {",
        "    class?: string; style?: Record<string, any>;",
        "    key: string;",
        `} = ${toStr(e)};`,
        "// 当前的条件值",
        `const query = ${toStr(s)};`,
        "// 条件配置项",
        `const condition = defineCondition(${toStr(t)});`
      ].join(`
`);
    }
    const modLoadHelper = [
      [
        "@xiaohaih/condition-core",
        // (modName: string, absolutePath: string, mod: string) =>
        //     `http://localhost:7890/core/dist/${
        //         modName === mod ? 'index.d.ts' : `${absolutePath.slice(mod.length + 1)}.d.ts`
        //     }`,
        (e, t, s) => `https://fastly.jsdelivr.net/npm/@xiaohaih/condition-core@latest/dist/${e === s ? "index.d.ts" : `${t.slice(s.length + 1)}.d.ts`}`
      ],
      [
        "@xiaohaih/condition-el",
        // (modName: string, absolutePath: string, mod: string) =>
        //     `http://localhost:7890/element-ui/dist/${
        //         modName === mod ? 'index.d.ts' : `${absolutePath.slice(mod.length + 1)}.d.ts`
        //     }`,
        (e, t, s) => `https://fastly.jsdelivr.net/npm/@xiaohaih/condition-el@latest/dist/${e === s ? "index.d.ts" : `${t.slice(s.length + 1)}.d.ts`}`
      ],
      [
        "@xiaohaih/condition-plus",
        // (modName: string, absolutePath: string, mod: string) =>
        //     `http://localhost:7890/element-plus/dist/${
        //         modName === mod ? 'index.d.ts' : `${absolutePath.slice(mod.length + 1)}.d.ts`
        //     }`,
        (e, t, s) => `https://fastly.jsdelivr.net/npm/@xiaohaih/condition-el-plus@latest/dist/${e === s ? "index.d.ts" : `${t.slice(s.length + 1)}.d.ts`}`
      ],
      [
        "element-ui",
        (e, t, s) => `https://fastly.jsdelivr.net/npm/element-ui@latest/types/${e === s ? "index.d.ts" : e === "./element-ui" ? "element-ui.d.ts" : t.slice(0, 17) === "element-ui/types/" ? `${t.slice(17)}.d.ts` : `${t.slice(11)}.d.ts`}`
      ],
      // element-plus 文件夹都省略了路径, 又存在大量重名(同关键字既可以是目录又可以是文件)
      // 所以用 element-ui 的类型
      [
        "element-plus",
        (e, t, s) => `https://fastly.jsdelivr.net/npm/element-ui@latest/types/${e === s ? "index.d.ts" : e === "./element-ui" ? "element-ui.d.ts" : t.slice(0, 17) === "element-ui/types/" ? `${t.slice(17)}.d.ts` : `${t.slice(13)}.d.ts`}`
      ],
      [
        "vue-demi",
        (e, t, s) => `https://fastly.jsdelivr.net/npm/vue-demi@0.14.6/lib/v${version$2.charAt(0)}/index.d.ts`
      ],
      [
        "@vue/composition-api",
        (e, t, s) => "https://fastly.jsdelivr.net/npm/@vue/composition-api@1.7.2/dist/vue-composition-api.d.ts"
      ],
      version$2.charAt(0) === "3" ? [
        "vue",
        (e, t, s) => `https://fastly.jsdelivr.net/npm/vue@3.4.0-beta.4/dist/${e === s ? "vue.d.ts" : t.slice(0, 10) === "vue/types/" ? `${t.slice(10)}.d.ts` : `${t.slice(4)}.d.ts`}`
      ] : [
        "vue",
        (e, t, s) => `https://fastly.jsdelivr.net/npm/vue@2.6.0/types/${e === s ? "index.d.ts" : t.slice(0, 10) === "vue/types/" ? `${t.slice(10)}.d.ts` : `${t.slice(4)}.d.ts`}`
      ],
      [
        "@vue/compiler-dom",
        (e, t, s) => "https://fastly.jsdelivr.net/npm/@vue/compiler-dom@3.4.0-beta.4/dist/compiler-dom.d.ts"
      ],
      [
        "@vue/shared",
        (e, t, s) => "https://fastly.jsdelivr.net/npm/@vue/shared@3.4.0-beta.4/dist/shared.d.ts"
      ],
      [
        "@babel/types",
        (e, t, s) => "https://fastly.jsdelivr.net/npm/@babel/types@7.23.6/lib/index.d.ts"
      ],
      [
        "source-map-js",
        (e, t, s) => "https://fastly.jsdelivr.net/npm/source-map-js@1.0.2/source-map.d.ts"
      ],
      [
        "@vue/runtime-dom",
        (e, t, s) => "https://fastly.jsdelivr.net/npm/@vue/runtime-dom@3.4.0-beta.4/dist/runtime-dom.d.ts"
      ],
      [
        "@vue/runtime-core",
        (e, t, s) => "https://fastly.jsdelivr.net/npm/@vue/runtime-core@3.4.0-beta.4/dist/runtime-core.d.ts"
      ],
      [
        "@vue/reactivity",
        (e, t, s) => "https://fastly.jsdelivr.net/npm/@vue/reactivity@3.4.0-beta.4/dist/reactivity.d.ts"
      ],
      [
        "csstype",
        (e, t, s) => "https://fastly.jsdelivr.net/npm/csstype@3.1.3/index.d.ts"
      ]
    ];
    async function loadModule(e, t, s) {
      const i = modLoadHelper.find(([a]) => t.slice(0, a.length) === a);
      return i ? fetch(i[1](e, t, i[0])).then((a) => a.text()) : "";
    }
    onMounted$1(() => {
      editorRef.value.editorInfo.addPlugin(typescript({ loadMod: loadModule }));
    });
    const editorRef = ref$2([]);
    async function setValue() {
      var e;
      try {
        await ((e = editorRef.value) == null ? void 0 : e.editorInfo.validate());
        const ast = editorRef.value.editorInfo.getAst();
        if (!ast)
          return;
        traverse(ast, {
          VariableDeclarator(path) {
            var t, s, i, a;
            if (((t = path.node.id) == null ? void 0 : t.name) === "wrapper") {
              const { code } = _default$4(path.node.init);
              let aaa = {};
              eval(`aaa=${code}`), Object.assign(conditions.value.wrapperOption, aaa);
            }
            if (((s = path.node.id) == null ? void 0 : s.name) === "query") {
              const { code } = _default$4(path.node.init);
              let aaa = {};
              eval(`aaa=${code}`), Object.assign(conditions.value.query, aaa);
            }
            if (((i = path.node.id) == null ? void 0 : i.name) === "condition") {
              const { code } = _default$4((a = path.node.init) == null ? void 0 : a.arguments[0], { jsescOption: { wrap: !1 } });
              let aaa = {};
              eval(
                `aaa=${code.replace(
                  /(\(\{)\n\s*((.|\n|\s)*?)\n*\s*(\}\))/gi,
                  (o) => o.replace(/\/\/.*/g, "").replace(/(\n|\s)+/g, " ")
                )}`
              ), Object.keys(aaa).forEach((o) => {
                Object.assign(conditions.value.condition[o], aaa[o]);
              });
            }
          }
        });
      } catch (t) {
        toast.warning("同步报错, 打开控制台看报错明细"), console.error(t);
      }
    }
    function clear() {
      conditions.value.query = {}, conditions.value.condition = {};
    }
    return {
      conditions,
      querySearch,
      reset,
      parseToEditorValue,
      loadModule,
      editorRef,
      setValue,
      clear,
      log: console.log
    };
  }
}), content_vue_vue_type_style_index_0_lang = "", content_vue_vue_type_style_index_1_lang = "", { defineComponent: defineComponent$1, nextTick, onMounted, ref: ref$1, set, version: version$1 } = window.Vue, { HWrapper, defineCondition } = window.HCondition, _sfc_main$1 = defineComponent$1({
  name: "",
  template: `
        <div>
            <HWrapper
                style="display: flex; flex-wrap: wrap"
                ref="formRef"
                :datum="formCondition"
                :rules="rules"
                :backfill="query"
                :render-btn="false"
                :realtime="true"
                @search="query = $event"
            ></HWrapper>
            <div style="min-height: 50px; line-height: 50px">{{ query }}</div>
            <ElButton @click="validate">校验</ElButton>
            <ElButton @click="validateField">逐个校验</ElButton>
            <ElButton @click="clearValidate">清空校验</ElButton>
        </div>
    `,
  components: { HWrapper },
  // props: {},
  setup(e, t) {
    const s = ref$1(), i = ref$1({
      // input1: '1',
      // input2: '2',
      // select1: '1',
      // select2: '22',
      // cas1: 'aa',
      // cas2: 'cas2AA1',
      // datepikcer1: '2024-03-24',
      // datepikcer2: ['2024-03-24', '2024-03-28'],
      // check1: ['check1'],
      // check2: ['che1'],
      // radio1: 'radio1',
      // radio2: 'rad1',
    }), a = defineCondition({
      input1: {
        t: "input",
        label: "input1",
        placeholder: "哈哈哈"
      },
      input2: {
        t: "input",
        label: "input2222",
        placeholder: "666",
        rules: [{ required: !0, message: "必填项" }]
      },
      select1: {
        t: "select",
        label: "sel1",
        placeholder: "哈哈哈",
        options: [
          { label: "第一", value: "1" },
          { label: "第二", value: "2" },
          { label: "第三", value: "3" }
        ]
      },
      select2: {
        t: "select",
        label: "sel2",
        placeholder: "test",
        labelKey: "dictLabel",
        valueKey: "dictValue",
        options: [],
        getOptions(S) {
          setTimeout(() => {
            S([
              { dictLabel: "第一一", dictValue: "11" },
              { dictLabel: "第二二", dictValue: "22" },
              { dictLabel: "第三三", dictValue: "33" }
            ]);
          }, 1e3);
        },
        rules: [{ required: !0, message: "必填项" }]
      },
      datepikcer1: {
        t: "datepicker",
        label: "date1",
        placeholder: "fff"
        // format: 'MM-DD',
        // valueFormat: 'YYYY-MM-DD',
      },
      date11: {
        t: "datepicker",
        type: "daterange",
        label: "date2",
        fields: ["date11", "date22"],
        placeholder: "999",
        startPlaceholder: "起",
        endPlaceholder: "止",
        rules: [{ required: !0, message: "必填项" }]
      },
      cas1: {
        t: "cascader",
        label: "cas1",
        placeholder: "fff",
        fields: ["cas1", "cas1_1"],
        props: { checkStrictly: !0 },
        options: [
          {
            label: "aa",
            value: "aa",
            children: [
              { label: "AA1", value: "AA1" },
              { label: "AA2", value: "AA2" }
            ]
          },
          {
            label: "bb",
            value: "bb",
            children: [
              { label: "BB1", value: "BB1" },
              { label: "BB2", value: "BB2" }
            ]
          }
        ]
      },
      cas2: {
        t: "cascader",
        type: "daterange",
        label: "cas2",
        placeholder: "999",
        rules: [{ required: !0, message: "必填项" }],
        getOptions(S) {
          S([
            {
              label: "cas2aa",
              value: "cas2aa",
              children: [
                { label: "cas2AA1", value: "cas2AA1" },
                { label: "cas2AA2", value: "cas2AA2" }
              ]
            },
            {
              label: "cas2bb",
              value: "cas2bb",
              children: [
                { label: "cas2BB1", value: "cas2BB1" },
                { label: "cas2BB2", value: "cas2BB2" }
              ]
            }
          ]);
        }
      },
      check1: {
        t: "checkbox",
        label: "check1",
        placeholder: "ddd",
        type: "button",
        options: [
          { label: "check1", value: "check1" },
          { label: "check2", value: "check2" }
        ]
      },
      check2: {
        t: "checkbox",
        label: "check2",
        placeholder: "ddd",
        rules: [{ required: !0, message: "必填项" }],
        getOptions(S) {
          setTimeout(() => {
            S([
              { label: "che1", value: "che1" },
              { label: "che2", value: "che2" }
            ]);
          }, 1e3);
        }
      },
      radio1: {
        t: "radio",
        label: "radio1",
        placeholder: "ddd",
        type: "button",
        options: [
          { label: "radio1", value: "radio1" },
          { label: "radio2", value: "radio2" }
        ]
      },
      radio2: {
        t: "radio",
        label: "radio2-cancelable",
        placeholder: "ddd",
        rules: [{ required: !0, message: "必填项" }],
        cancelable: !0,
        getOptions(S) {
          setTimeout(() => {
            S([
              { label: "rad1", value: "rad1" },
              { label: "rad2", value: "rad2" }
            ]);
          }, 1e3);
        }
      }
    }), o = Object.keys(a);
    let l = 0;
    const f = {
      input1: [{ required: !0, message: "formRules" }],
      input2: [
        {
          validator: (S, b, v) => b !== "123" ? v("not 123 from formRules") : v(),
          message: "not 123 from formRules"
        }
      ],
      select1: [{ required: !0, message: "select form FormRules" }],
      datepikcer1: [{ required: !0, message: "datepicker form FormRules" }],
      cas1: [{ required: !0, message: "cascader form FormRules" }],
      check1: [{ required: !0, message: "check form FormRules" }],
      radio1: [{ required: !0, message: "radio form FormRules" }]
    };
    function y() {
      var S, b;
      (b = (S = s.value) == null ? void 0 : S.formRef) == null || b.validate();
    }
    function g() {
      var S, b;
      T(), (b = (S = s.value) == null ? void 0 : S.formRef) == null || b.validateField(o[l % o.length]), l = (l + 1) % o.length;
    }
    function T() {
      var S, b;
      (b = (S = s.value) == null ? void 0 : S.formRef) == null || b.clearValidate();
    }
    return {
      formRef: s,
      query: i,
      formCondition: a,
      rules: f,
      validate: y,
      validateField: g,
      clearValidate: T
    };
  }
}), { defineComponent, markRaw, ref, version } = window.Vue, _sfc_main = defineComponent({
  name: "App",
  template: `
        <div style="width: 100%; height: 100%; display: flex; flex-direction: column">
            <ElAlert type="warning" style="flex: none; margin-bottom: 10px" :closable="false">
                vue 版本: {{ vueVersion }} - 表单校验
            </ElAlert>
            <Content2></Content2>
            <ElAlert type="error" style="flex: none; margin-bottom: 10px" :closable="false">
                vue 版本: {{ vueVersion }} - 条件
            </ElAlert>
            <Content></Content>
        </div>
    `,
  components: {
    Content: _sfc_main$2,
    Content2: _sfc_main$1
  },
  setup() {
    return {
      vueVersion: version
    };
  }
});
export {
  _sfc_main as default
};
